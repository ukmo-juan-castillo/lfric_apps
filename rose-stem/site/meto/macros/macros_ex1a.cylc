{# ########################################################################### #}
{# (c) Crown copyright 2024 Met Office. All rights reserved. #}
{# The file LICENCE, distributed with this code, contains details of the terms #}
{# under which the code may be used. #}
{# ########################################################################### #}
{% do LOG.debug("Entered site/meto/macros/macros_ex1a.cylc") %}

{% if site_vars.node_type == "genoa" %}
    {% set ex1a_cores_per_node = 192 %}
{% else %}
    {% set ex1a_cores_per_node = 128 %}
{% endif %}
{% set ex1a_socket_per_node = 2 %}

{% macro normal_queue(mpi_ranks,
                        threads,
                        xios_nodes,
                        ocean_nodes,
                        river_nodes,
                        ranks_per_node,
                        ranks_depth_pad=1) %}

    {# The depth setting, padded or otherwise, is tied to threads #}
    {% set depth_val =  threads|int %}
    {# If the depth padding is present, and it is greater than the thread qty, #}
    {# we will use it instead. There may be occations where users use a pad, and  #}
    {# threads where there are memory concerns #}
    {% if (ranks_depth_pad|int > threads|int) %}
        {% set depth_val =  ranks_depth_pad|int %}
    {% endif %}

    {# If an override is set on ex1a #}
    {% if (ranks_per_node > 0) and ((ranks_per_node|int * depth_val|int) <= ex1a_cores_per_node|int) %}
        {% set lfric_nodes = (mpi_ranks|float / ranks_per_node|float)|round(0, 'ceil')|int %}
    {% else %}
        {% set checking_total_cpus = (mpi_ranks|int * depth_val|int)|int %}
        {# Threads use cpus, and change how any decomposition can be placed into a numa and a node #}
        {% if depth_val|int > 1 %}
            {# Setup some default values #}
            {% set found_multiplier = namespace(bool=false) %}
            {% set last_valid_index = namespace(int=0) %}
            {% set checking_maths = namespace(int=0) %}
            {# Work through all ideal fits for threading decomps into a node. #}
            {# We want to get to or as close to the cores_per_node. #}
            {% set ex1a_cores_per_node_threshold = ex1a_cores_per_node|int + 1 %}
            {% for check_iterator in range(ex1a_cores_per_node_threshold) %}
                {% set checking_maths.int = (check_iterator|int * depth_val|int)|int %}
                {# Check if the value so far fits accross numas and into the node and store it #}
                {# The last to fit will be kept #}
                {% if (check_iterator|int % ex1a_socket_per_node|int == 0) %}
                    {% if (checking_maths.int <= ex1a_cores_per_node|int) and (checking_maths.int <= checking_total_cpus|int) %}
                        {% set found_multiplier.bool = true %}
                        {% set last_valid_index.int = check_iterator|int %}
                    {% endif %}
                {% endif %}
            {% endfor %}
            {# Else fail safe - this will likely be due to not splitting over the numas #}
                {% if found_multiplier.bool %}
                    {% set cpus_per_node_max = ( last_valid_index.int|int * depth_val|int )|int  %}
                {% else %}
                    {% if (checking_total_cpus|int >= ex1a_cores_per_node|int) %}
                        {% set cpus_per_node_max = ex1a_cores_per_node|int  %}
                    {% else %}
                        {% set cpus_per_node_max = checking_total_cpus|int  %}
                    {% endif %}
                {% endif %}
        {% else %}
            {# If a single thread, we will be  #}
            {% set cpus_per_node_max = ex1a_cores_per_node|int  %}
        {% endif %}

        {% set possible_nodes = ((checking_total_cpus|float / cpus_per_node_max|float)|round(method='ceil'))|int %}

        {% set lfric_nodes = possible_nodes %}

    {% endif %}
    {% if site_vars["ex_trustzone"] == "collab" %}
            -q=collab
    {% else %}
            -q=normal
    {% endif %}
            -l select={{ lfric_nodes +
                         ocean_nodes|int +
                         river_nodes|int +
                         xios_nodes|int }}:coretype={{site_vars.node_type}}:mem={{site_vars.node_mem}}GB{{site_vars.crayhost}}
{% endmacro %}


{% macro shared_queue(cores) %}
    {% if site_vars["ex_trustzone"] == "collab" %}
            -q=collabshared
    {% else %}
            -q=shared
    {% endif %}
            -l ncpus={{ cores }}

{% endmacro %}


{% macro set_task_resources(mpi_ranks,
                        memory,
                        threads=1,
                        xios_nodes=0,
                        ocean_nodes=0,
                        river_nodes=0,
                        ranks_per_node=0,
                        ranks_depth_pad=1) %}

    {% set total_other_ranks = xios_nodes + ocean_nodes + river_nodes %}
    {% set lfric_cores = mpi_ranks * threads %}
    {% if lfric_cores >= ex1a_cores_per_node or total_other_ranks > 0 %}
        {# This needs to be run on the normal queue #}
        {{ normal_queue(mpi_ranks, threads, xios_nodes, ocean_nodes, river_nodes, ranks_per_node, ranks_depth_pad) }}
    {% else %}
        {# This is small enough to run on the shared queue #}
        {{ shared_queue(mpi_ranks * threads) }}
        {{ set_memory(memory) }}
    {% endif %}

{% endmacro %}


{% macro set_memory(mem) %}
    {% set value = mem[0]|int %}
    {% set unit = mem[1] %}
            -l mem={{value}}{{unit}}
{% endmacro %}

{% do LOG.debug("Finished in site/meto/macros/macros_ex1a.cylc") %}
