!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!>@brief
!>@details

module tl_test_rhs_alg_mod


  use constants_mod,                  only: i_def, r_def, str_def
  use gungho_modeldb_mod,             only: modeldb_type
  use field_array_mod,                only: field_array_type
  use field_mod,                      only: field_type
  use mesh_mod,                       only: mesh_type
  use field_collection_mod,           only: field_collection_type
  use function_space_mod,             only: function_space_type
  use derived_config_mod,             only: bundle_size
  use moist_dyn_mod,                  only: num_moist_factors
  use sci_assign_field_random_kernel_mod, only: assign_field_random_kernel_type
  use field_indices_mod,              only: igh_u, igh_t, igh_d, igh_p
  use sci_field_bundle_builtins_mod,  only: clone_bundle,      &
                                            add_bundle,        &
                                            minus_bundle,      &
                                            set_bundle_scalar
  use timestepping_config_mod,        only: dt
  use rhs_alg_mod,                    only: rhs_alg
  use tl_rhs_alg_mod,                 only: tl_rhs_alg
  use log_mod,                        only: log_event, LOG_LEVEL_INFO, &
                                            LOG_LEVEL_ERROR
  use tl_test_convergence_rate_check, only: convergence_rate_check

  implicit none

  private

  public :: test_rhs_alg

  contains

  !> @brief Tests the tangent linear model right-hand side algorithm
  !> @param[in] modedb    The working data set for a model run
  !> @param[in] mesh      The current 3d mesh
  !> @param[in] twod_mesh The current 2d mesh
  subroutine test_rhs_alg( modeldb, &
                           mesh,    &
                           twod_mesh )

    implicit none

    type(mesh_type), pointer, intent(in) :: mesh
    type(mesh_type), pointer, intent(in) :: twod_mesh

    type(modeldb_type), target, intent(in) :: modeldb

    character(str_def) :: label = "rhs_alg"

    type(field_collection_type ), pointer :: ls_fields => null()


    type( field_type ) :: state(bundle_size)
    type( field_type ) :: ls_state(bundle_size)
    type( field_type ) :: p_state(bundle_size)
    type( field_type ) :: random(bundle_size)
    type( field_type ) :: p_rhs(bundle_size)
    type( field_type ) :: n1_rhs(bundle_size)
    type( field_type ) :: n2_rhs(bundle_size)
    type( field_type ) :: diff(bundle_size)

    type(field_type), pointer :: ls_u => null()
    type(field_type), pointer :: ls_rho => null()
    type(field_type), pointer :: ls_theta => null()
    type(field_type), pointer :: ls_exner => null()
    type(field_type), pointer :: ls_moist_dyn(:) => null()
    type(field_type), dimension(num_moist_factors) :: p_moist_dyn
    type(field_type), dimension(num_moist_factors) :: n_moist_dyn
    type(field_type), dimension(num_moist_factors) :: r_moist_dyn

    type(field_collection_type), pointer :: moisture_fields => null()
    type(field_array_type), pointer      :: ls_moist_dyn_array => null()

    real(r_def) :: gamma_u, gamma_rho, gamma_exner, gamma_theta, &
                   gamma_moist_dyn
    real(r_def) :: norm_u, norm_rho, norm_exner, norm_theta, norm_moist_dyn
    real(r_def) :: norm_moist_dyn_tmp
    real(r_def) :: norm_diff, norm_diff_prev

    real(r_def), parameter :: tol = 1.e-2_r_def

    integer :: i, n

    call log_event( "TL Test: " // trim(label), &
                     LOG_LEVEL_INFO )

    ls_fields         => modeldb%model_data%ls_fields
    moisture_fields => modeldb%fields%get_field_collection("moisture_fields")
    call moisture_fields%get_field("ls_moist_dyn", ls_moist_dyn_array)
    ls_moist_dyn => ls_moist_dyn_array%bundle

    ! Input
    call ls_fields%get_field('ls_u', ls_u)
    call ls_fields%get_field('ls_rho', ls_rho)
    call ls_fields%get_field('ls_theta', ls_theta)
    call ls_fields%get_field('ls_exner', ls_exner)


    call ls_state(igh_u)%initialise( vector_space = ls_u%get_function_space() )
    call ls_state(igh_t)%initialise( vector_space = ls_theta%get_function_space() )
    call ls_state(igh_d)%initialise( vector_space = ls_rho%get_function_space() )
    call ls_state(igh_p)%initialise( vector_space = ls_exner%get_function_space() )
    call clone_bundle(ls_state, state, bundle_size)
    call clone_bundle(ls_state, p_state, bundle_size)
    call clone_bundle(ls_state, random, bundle_size)
    call clone_bundle(ls_state, p_rhs, bundle_size)
    call clone_bundle(ls_state, n1_rhs, bundle_size)
    call clone_bundle(ls_state, n2_rhs, bundle_size)
    call clone_bundle(ls_state, diff, bundle_size)

    call clone_bundle(ls_moist_dyn, p_moist_dyn, num_moist_factors)
    call clone_bundle(ls_moist_dyn, r_moist_dyn, num_moist_factors)
    call clone_bundle(ls_moist_dyn, n_moist_dyn, num_moist_factors)

    call invoke( name = "copy_fields_to_ls_state",   &
                 setval_X(ls_state(igh_u), ls_u    ), &
                 setval_X(ls_state(igh_t), ls_theta), &
                 setval_X(ls_state(igh_d), ls_rho  ), &
                 setval_X(ls_state(igh_p), ls_exner) )

    call invoke( assign_field_random_kernel_type( random(igh_u), 1.0_r_def ) , &
                 assign_field_random_kernel_type( random(igh_d), 1.0_r_def ) , &
                 assign_field_random_kernel_type( random(igh_t), 1.0_r_def ) , &
                 assign_field_random_kernel_type( random(igh_p), 1.0_r_def ) )

    do i = 1, num_moist_factors
      call invoke( assign_field_random_kernel_type( r_moist_dyn(i), 1.0_r_def ) )
    enddo

    gamma_u = 1.e2_r_def
    gamma_theta = 1.e2_r_def
    gamma_rho = 1.e2_r_def
    gamma_exner = 1.e1_r_def
    gamma_moist_dyn = 1.e-1_r_def

    call set_bundle_scalar( 0.0_r_def, n1_rhs, bundle_size )
    call rhs_alg( n1_rhs, dt, ls_state, ls_state, ls_moist_dyn, &
                  .true., .true., .false. )

    do n=1,2
      gamma_u = gamma_u / 2.0_r_def
      gamma_theta = gamma_theta / 2.0_r_def
      gamma_rho = gamma_rho / 2.0_r_def
      gamma_exner = gamma_exner / 2.0_r_def
      gamma_moist_dyn = gamma_moist_dyn / 2.0_r_def

      call set_bundle_scalar( 0.0_r_def, n2_rhs, bundle_size )
      call set_bundle_scalar( 0.0_r_def, p_rhs, bundle_size )
      call invoke( a_times_X( p_state(igh_u), gamma_u, random(igh_u) ),       &
                   a_times_X( p_state(igh_t), gamma_theta, random(igh_t) ),   &
                   a_times_X( p_state(igh_d), gamma_rho, random(igh_d) ),     &
                   a_times_X( p_state(igh_p), gamma_exner, random(igh_p) ) )

      ! state = ls_state + p_state
      call add_bundle( ls_state, p_state, state, bundle_size )

      do i = 1, num_moist_factors
        call invoke( &
          a_times_X( p_moist_dyn(i), gamma_moist_dyn, r_moist_dyn(i) ), &
          setval_X( n_moist_dyn(i), ls_moist_dyn(i) ),                       &
          inc_X_plus_Y( n_moist_dyn(i), p_moist_dyn(i) ) )
      enddo

      call rhs_alg( n2_rhs, dt, state, state, n_moist_dyn, &
                    .true., .true., .false. )

      call tl_rhs_alg(p_rhs, dt, p_state, p_state, p_moist_dyn, &
                      ls_state, ls_moist_dyn,                   &
                      .true., .false., dt)

      ! diff = n2_rhs - n1_rhs
      call minus_bundle( n2_rhs, n1_rhs, diff, bundle_size )

      call invoke( &
                 inc_X_minus_Y( diff(igh_u), p_rhs(igh_u) ), &
                 inc_X_minus_Y( diff(igh_t), p_rhs(igh_t) ), &
                 inc_X_minus_Y( diff(igh_d), p_rhs(igh_d) ), &
                 inc_X_minus_Y( diff(igh_p), p_rhs(igh_p) ) )

      call invoke( X_innerproduct_X( norm_u,     diff(igh_u) ) , &
                   X_innerproduct_X( norm_rho,   diff(igh_d) ) , &
                   X_innerproduct_X( norm_theta, diff(igh_t) ) , &
                   X_innerproduct_X( norm_exner, diff(igh_p) ) )

      print*, norm_u, norm_rho, norm_theta, norm_exner
      norm_diff = norm_u + norm_rho + norm_theta + norm_exner
      norm_diff = sqrt(norm_diff)
      print*,'norm', norm_diff

      if (n == 2) then
        call convergence_rate_check( norm_diff, norm_diff_prev, &
                                     label, tol=tol )
      endif

      norm_diff_prev = norm_diff
    enddo

  end subroutine test_rhs_alg
end module tl_test_rhs_alg_mod
