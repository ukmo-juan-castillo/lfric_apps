!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Tangent linear for the advective update A of a variable f by a wind U
!!        Nonlinear code is A = U.grad(f)
!!        Linear code is    A = U.grad(ls_f) + ls_U.grad(f)
!> @todo There are number of workarounds in this algorithm for aspects which
!!       aren't yet supported by PSyclone/LFRic:
!!       1. Issue #868 Multidata fields are not natively supported in PSyclone.
!!                     Currently we treat these as normal fields but need to
!!                     additionally pass in ndata_h or ndata_v to the kernels
!!                     as extra integer arguments.
!!       2. Issue #1246 Region stencils require both the global maximum size of
!!                      the stencil and local column size of the stencil.
!!                      PSyclone currently only passes in the local size and so
!!                      until this is resolved we also pass in the global maximum
!!                      size as an integer argument.
module tl_wt_advective_update_alg_mod

  use constants_mod,                      only: r_def, i_def, l_def
  use fem_constants_mod,                  only: get_inverse_lumped_mass_matrix
  use field_mod,                          only: field_type
  use finite_element_config_mod,          only: element_order
  use fs_continuity_mod,                  only: W1, Wtheta
  use function_space_mod,                 only: function_space_type
  use function_space_collection_mod,      only: function_space_collection
  use mesh_mod,                           only: mesh_type
  use transport_config_mod,               only: operators,            &
                                                fv_horizontal_order,  &
                                                fv_vertical_order,    &
                                                operators_fv,         &
                                                operators_fem,        &
                                                consistent_metric
  use log_mod,                            only: log_event,         &
                                                LOG_LEVEL_ERROR
  use tl_poly_advective_kernel_mod,       only: tl_poly_advective_kernel_type
  use tl_poly1d_vert_adv_kernel_mod,      only: tl_poly1d_vert_adv_kernel_type
  use transport_enumerated_types_mod,     only: direction_v,                  &
                                                direction_h,                  &
                                                direction_3d,                 &
                                                vertical_monotone_koren
  use transport_metadata_mod,             only: transport_metadata_type
  use wt_advective_update_alg_mod,        only: get_adv_ndata_v,                &
                                                get_vert_adv_coeffs,            &
                                                get_reversible_adv_ndata_v,     &
                                                get_reversible_vert_adv_coeffs, &
                                                hori_wt_update_alg
  use tl_transport_runtime_collection_mod, &
                                          only: tl_transport_runtime
  use transport_runtime_alg_mod,          only: transport_runtime_type
  use transport_runtime_collection_mod,   only: get_transport_runtime

  implicit none

  private

  public :: tl_wt_advective_update_alg
  public :: tl_vert_wt_update_alg

contains

  !=============================================================================
  !> @brief Compute advective update of a Wtheta field for tangent linear app.
  !> @details Compute tangent linear advective update using desired spatial
  !!          reconstruction. Options for this are either FE or FV reconstructions.
  !> @param[in,out] rhs                 ACTIVE Change in Advective increment
  !> @param[in]     adv_field           ACTIVE Change in Field to advect
  !> @param[in]     wind                ACTIVE Change in Advecting wind field
  !> @param[in]     ls_adv_field        Lin state for Field to advect
  !> @param[in]     ls_wind             Lin state for Advecting wind field
  !> @param[in]     dt                  Timestep
  !> @param[in]     direction           Direction of the transport
  !> @param[in]     transport_metadata  Contains transport configuration options
  !> @param[in]     final_rk_stage      Whether this is the last Runge-Kutta stage
  subroutine tl_wt_advective_update_alg(rhs, adv_field, wind,    &
                                        ls_adv_field, ls_wind,   &
                                        dt, direction,           &
                                        transport_metadata, final_rk_stage)


    use reference_element_mod,          only: reference_element_type
    use mesh_mod,                       only: mesh_type

    implicit none

    type(field_type),              intent(in)    :: adv_field, wind
    type(field_type),              intent(in)    :: ls_adv_field, ls_wind
    type(field_type),              intent(inout) :: rhs
    real(kind=r_def),              intent(in)    :: dt
    integer(kind=i_def),           intent(in)    :: direction
    type(transport_metadata_type), intent(in)    :: transport_metadata
    logical(kind=l_def),           intent(in)    :: final_rk_stage

    type(field_type)                       :: u_grad_f
    type(field_type),              pointer :: wind_v => null()
    type(field_type),              pointer :: wind_h => null()
    type(field_type),              pointer :: ls_wind_v => null()
    type(field_type),              pointer :: ls_wind_h => null()
    type(transport_runtime_type),  pointer :: transport_runtime => null()
    type(field_type), pointer              :: mt_lumped_inv => null()
    type(mesh_type), pointer               :: mesh => null()

    mesh => wind%get_mesh()
    call u_grad_f%initialise( adv_field%get_function_space() )
    call invoke( setval_c(u_grad_f, 0.0_r_def) )

    select case( operators )

    case default
      call log_event( "Gungho: Unrecognised option for wtheta reconstruction.", LOG_LEVEL_ERROR )

    case( operators_fv )

      select case ( direction )

      case ( direction_3d )
        transport_runtime => get_transport_runtime(mesh)
        wind_h => tl_transport_runtime%get_horizontal_advecting_wind(mesh%get_id())
        wind_v => tl_transport_runtime%get_vertical_advecting_wind(mesh%get_id())
        ls_wind_h => transport_runtime%get_horizontal_advecting_wind(mesh%get_id())
        ls_wind_v => transport_runtime%get_vertical_advecting_wind(mesh%get_id())

        ! Horizontal update
        ! TODO: we may need a special tl_hori_wt_update
        call hori_wt_update_alg(u_grad_f, ls_wind_h, adv_field, transport_metadata)
        call hori_wt_update_alg(u_grad_f, wind_h, ls_adv_field, transport_metadata)

        if ( consistent_metric ) then
          call log_event( "TL: consistent metric not implemented", LOG_LEVEL_ERROR )
        end if

        call tl_vert_wt_update_alg(u_grad_f, wind_v, adv_field, &
                                   ls_wind_v, ls_adv_field,     &
                                   transport_metadata, final_rk_stage)

        nullify( wind_h, wind_v, ls_wind_h, ls_wind_v, transport_runtime )

      case ( direction_h )
        ! TODO: we may need a special tl_hori_wt_update
        call hori_wt_update_alg(u_grad_f, ls_wind, adv_field, transport_metadata)
        call hori_wt_update_alg(u_grad_f, wind, ls_adv_field, transport_metadata)

        ! TODO: Otherwise can remove the tl_poly_advective_kernel_type?
        ! This is temporarily preserved in the comments
        ! call horizontal_wt_reconstruct_alg(h_reconstruction, ls_wind, adv_field)
        ! call horizontal_wt_reconstruct_alg(ls_h_reconstruction, ls_wind, ls_adv_field)
        ! ! Combine to get horizontal part of ls_u.grad(f) + u.grad(ls_f)
        ! call invoke( tl_poly_advective_kernel_type( u_grad_f,         &
        !                                             wind,             &
        !                                             h_reconstruction, &
        !                                             ls_wind,          &
        !                                             ls_h_reconstruction) )

      case ( direction_v )
        call tl_vert_wt_update_alg(u_grad_f, wind, adv_field, &
                                   ls_wind, ls_adv_field,     &
                                   transport_metadata, final_rk_stage)
      case default
        call log_event('T.L. advective update: direction not recognised', LOG_LEVEL_ERROR)
      end select


    case(operators_fem)
      call log_event( "TL: fem not available", LOG_LEVEL_ERROR )
    end select

    mt_lumped_inv => get_inverse_lumped_mass_matrix(Wtheta, mesh%get_id())

    ! Scale by lumped inverse mass matrix
    call invoke( X_times_Y(rhs, u_grad_f, mt_lumped_inv) )

    nullify( mt_lumped_inv )

  end subroutine tl_wt_advective_update_alg

  !=============================================================================
  !> @brief Tangent Linear vertical advective update of a Wtheta field.
  !> @param[in,out] u_grad_f            Vertical part of u.grad(f)
  !> @param[in]     wind                Advecting wind field
  !> @param[in]     field               Wtheta field to advect
  !> @param[in]     ls_wind             Linearised advecting wind field
  !> @param[in]     ls_field            Linearised Wtheta field to advect
  !> @param[in]     transport_metadata  Contains transport configuration options
  !> @param[in]     final_rk_stage      Whether this is the last Runge-Kutta stage
  subroutine tl_vert_wt_update_alg(u_grad_f, wind, field, ls_wind, ls_field, &
                                   transport_metadata, final_rk_stage)

    use tl_poly1d_vert_adv_kernel_mod,     only: tl_poly1d_vert_adv_kernel_type

    implicit none

    type(field_type),              intent(in)    :: field, wind
    type(field_type),              intent(in)    :: ls_field, ls_wind
    type(field_type),              intent(inout) :: u_grad_f
    type(transport_metadata_type), intent(in)    :: transport_metadata
    logical(kind=l_def),           intent(in)    :: final_rk_stage

    integer(kind=i_def)          :: mesh_id
    integer(kind=i_def)          :: vertical_order
    integer(kind=i_def), pointer :: ndata_v => null()
    type(mesh_type),     pointer :: mesh => null()
    type(field_type),    pointer :: vert_adv_coeffs => null()
    logical(kind=l_def)          :: logspace
    logical(kind=l_def)          :: reversible
    integer(kind=i_def)          :: monotonicity

    reversible = ( transport_metadata%get_reversible() .and. final_rk_stage )
    logspace = transport_metadata%get_log_space()
    monotonicity = transport_metadata%get_vertical_monotone()

    mesh => wind%get_mesh()
    mesh_id = mesh%get_id()

    ! vertical update
    if ( reversible ) then
      ndata_v => get_reversible_adv_ndata_v(mesh_id)
      vert_adv_coeffs => get_reversible_vert_adv_coeffs(mesh_id)
      vertical_order = fv_vertical_order
    else
      ndata_v => get_adv_ndata_v(mesh_id)
      vert_adv_coeffs => get_vert_adv_coeffs(mesh_id)
      vertical_order = fv_vertical_order + 1_i_def
    end if

    if ( monotonicity == vertical_monotone_koren ) then
      call log_event('T.L. Wtheta advective update not implemented with Koren scheme', LOG_LEVEL_ERROR)

    else
      call invoke( tl_poly1d_vert_adv_kernel_type(u_grad_f,        &
                                                  wind,            &
                                                  field,           &
                                                  ls_wind,         &
                                                  ls_field,        &
                                                  vert_adv_coeffs, &
                                                  ndata_v,         &
                                                  vertical_order,  &
                                                  logspace ) )
    end if

    nullify( vert_adv_coeffs, ndata_v )

  end subroutine tl_vert_wt_update_alg

end module tl_wt_advective_update_alg_mod
