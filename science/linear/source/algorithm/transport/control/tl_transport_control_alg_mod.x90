!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module controlling the tangent linear transport.

module tl_transport_control_alg_mod

  use constants_mod,                     only: i_def, r_def, l_def
  use field_mod,                         only: field_type
  use formulation_config_mod,            only: moisture_formulation,    &
                                               moisture_formulation_dry
  use log_mod,                           only: log_event,      &
                                               LOG_LEVEL_INFO, &
                                               LOG_LEVEL_ERROR
  use model_clock_mod,                   only: model_clock_type
  use transport_config_mod,              only: cheap_update
  use transport_controller_mod,          only: transport_controller_type
  use tl_transport_controller_mod,       only: tl_transport_controller_type
  use transport_metadata_mod,            only: transport_metadata_type
  use transport_metadata_collection_mod, only: transport_metadata_collection

  implicit none

  private

  ! Set number of mixing ratio species to transport
  ! Only transport first four species of moisture (and not graupel or snow)
  integer(kind=i_def), parameter :: nummr_to_transport = 4

  ! Contained suroutines
  public :: tl_transport_control_alg

contains

  !=============================================================================
  !> @brief Advection of prognostic variables for the tangent linear model.
  !> @param[in,out] advection_inc      ACTIVE Advection increment of the dynamics
  !!                                   prognostics [u, rho, theta, exner]
  !> @param[in]     advected_fields    ACTIVE Fields to advect: [u, rho, theta, exner]
  !> @param[in]     wind_np1           ACTIVE End of timestep wind field
  !> @param[in]     wind_n             ACTIVE Start of timestep wind field
  !> @param[in,out] mr_out             ACTIVE Moisture fields after transport
  !> @param[in]     mr_in              ACTIVE Moisture fields before transport
  !> @param[in]     ls_advected_fields PASSIVE Fields to advect: [u, rho, theta, exner]
  !> @param[in]     ls_wind_np1        PASSIVE End of timestep wind field
  !> @param[in]     ls_wind_n          PASSIVE Start of timestep wind field
  !> @param[in]     ls_mr_in           PASSIVE Moisture fields before transport
  !> @param[in]     model_clock        Time within the model
  !> @param[in]     outer              Outer (advection) iteration number
  !>
  subroutine tl_transport_control_alg(advection_inc, advected_fields,          &
                                      wind_np1, wind_n, mr_out, mr_in,         &
                                      ls_advected_fields,                      &
                                      ls_wind_np1, ls_wind_n, ls_mr_in,        &
                                      model_clock, outer )

    use derived_config_mod,              only: bundle_size
    use sci_field_bundle_builtins_mod,   only: clone_bundle, set_bundle_scalar
    use field_indices_mod,               only: igh_u, igh_t, igh_d, igh_p
    use fs_continuity_mod,               only: Wtheta
    use mr_indices_mod,                  only: nummr
    use operator_mod,                    only: operator_type
    use tl_moist_mr_transport_alg_mod,   only: tl_moist_mr_transport_alg
    use tl_theta_transport_alg_mod,      only: tl_theta_transport_alg
    use tl_transport_field_mod,          only: tl_transport_field
    use tl_wind_transport_alg_mod,       only: tl_wind_transport_alg
    use timing_mod,                      only: start_timing, stop_timing, &
                                               tik, LPROF

    implicit none

    ! Arguments
    type(field_type),            intent(inout) :: advection_inc(bundle_size)
    type(field_type),            intent(in)    :: advected_fields(bundle_size)
    type(field_type),            intent(in)    :: wind_np1
    type(field_type),            intent(in)    :: wind_n
    type(field_type),            intent(in)    :: ls_wind_np1
    type(field_type),            intent(in)    :: ls_wind_n
    type(field_type),            intent(inout) :: mr_out(nummr)
    type(field_type),            intent(in)    :: mr_in(nummr)
    type(field_type),            intent(in)    :: ls_advected_fields(bundle_size)
    type(field_type),            intent(in)    :: ls_mr_in(nummr)
    class(model_clock_type),     intent(in)    :: model_clock
    integer(kind=i_def),         intent(in)    :: outer

    ! Internal variables
    type(field_type)    :: fields_np1(bundle_size)
    logical(kind=l_def) :: cheap_update_step
    integer(tik)        :: id

    type(transport_metadata_type), pointer :: transport_metadata
    type(tl_transport_controller_type)     :: tl_transport_controller

    if ( LPROF ) call start_timing( id, 'tl_transport_control' )

    ! ======================================================================== !
    ! Pre-transport initialisation tasks
    ! ======================================================================== !

    ! Initialise fields
    call clone_bundle(advected_fields, fields_np1, bundle_size)
    call set_bundle_scalar(0.0_r_def, fields_np1, bundle_size)

    cheap_update_step = .false.
    if (cheap_update) then
      call log_event(                                                          &
              "Transport cheap update not available for TLM", LOG_LEVEL_ERROR  &
      )
    end if

    ! Initialise the transport controllers -------------------------------------
    call tl_transport_controller%initialise(                                   &
            model_clock, advected_fields(igh_d), ls_advected_fields(igh_d),    &
            wind_n, wind_np1, ls_wind_n, ls_wind_np1,                          &
            outer=outer, cheap_update_step=cheap_update_step                   &
    )

    ! ======================================================================== !
    ! TRANSPORT OF PROGNOSTICS
    ! ======================================================================== !

    ! ------------------------------------------------------------------------ !
    ! Transport dry density
    call log_event( "Transporting density...", LOG_LEVEL_INFO)
    transport_metadata =>                                                      &
        transport_metadata_collection%get_transport_metadata('density')

    call tl_transport_field(                                                   &
            fields_np1(igh_d), advected_fields(igh_d),                         &
            ls_advected_fields(igh_d), tl_transport_controller,                &
            transport_metadata                                                 &
    )
    call invoke( X_minus_Y(advection_inc(igh_d), fields_np1(igh_d),            &
                           advected_fields(igh_d)) )

    ! ------------------------------------------------------------------------ !
    ! Transport wind field
    call log_event( "Transporting wind...", LOG_LEVEL_INFO)
    transport_metadata =>                                                      &
        transport_metadata_collection%get_transport_metadata('wind')

    call tl_wind_transport_alg(                                                &
            advection_inc(igh_u), advected_fields(igh_u),                      &
            ls_advected_fields(igh_u), tl_transport_controller,                &
            transport_metadata                                                 &
    )
    ! We don't change advection_inc(igh_u) as tl_wind_transport_alg
    ! already returns weak increment

    ! ------------------------------------------------------------------------ !
    ! Don't transport Exner pressure
    call invoke( setval_c(advection_inc(igh_p), 0.0_r_def) )

    ! ------------------------------------------------------------------------ !
    ! Transport moisture mixing ratio fields
    if ( moisture_formulation /= moisture_formulation_dry ) then
      call log_event(                                                          &
              "Transporting moisture mixing ratio fields...", LOG_LEVEL_INFO   &
      )
      transport_metadata =>                                                    &
          transport_metadata_collection%get_transport_metadata('moisture')
      call tl_moist_mr_transport_alg(                                          &
              mr_out, mr_in, ls_mr_in, nummr_to_transport,                     &
              tl_transport_controller, transport_metadata                      &
      )
    end if

    ! ------------------------------------------------------------------------ !
    ! Transport potential temperature (must be after moisture)
    ! NB: moisture not passed through as theta_vd transport not yet implemented
    ! Note: theta increment is pointwise
    call log_event( "Transporting potential temperature...", LOG_LEVEL_INFO)
    transport_metadata =>                                                      &
        transport_metadata_collection%get_transport_metadata('potential_temperature')

    call tl_theta_transport_alg(                                               &
            fields_np1(igh_t), advection_inc(igh_t), advected_fields(igh_t),   &
            ls_advected_fields(igh_t), tl_transport_controller,                &
            transport_metadata                                                 &
    )

    call tl_transport_controller%finalise()

    if ( LPROF ) call stop_timing( id, 'tl_transport_control' )

  end subroutine tl_transport_control_alg

end module tl_transport_control_alg_mod
