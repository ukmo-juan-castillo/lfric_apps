!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module controlling the tangent linear transport.

module tl_transport_control_alg_mod

  use constants_mod,                     only: i_def, r_def, l_def
  use field_mod,                         only: field_type
  use formulation_config_mod,            only: moisture_formulation,    &
                                               moisture_formulation_dry
  use log_mod,                           only: log_event,      &
                                               LOG_LEVEL_INFO, &
                                               LOG_LEVEL_ERROR
  use model_clock_mod,                   only: model_clock_type
  use tl_transport_runtime_collection_mod, &
                                         only: tl_transport_runtime
  use transport_config_mod,              only: cheap_update
  use transport_metadata_mod,            only: transport_metadata_type
  use transport_runtime_collection_mod,  only: set_transport_runtime
  use transport_metadata_collection_mod, only: transport_metadata_collection

  implicit none

  private

  ! Set number of mixing ratio species to transport
  ! Only transport first four species of moisture (and not graupel or snow)
  integer(kind=i_def), parameter :: nummr_to_transport = 4

  ! Contained suroutines
  public :: tl_transport_control_alg

contains

  !=============================================================================
  !> @brief Advection of prognostic variables for the tangent linear model.
  !> @param[in,out] advection_inc      ACTIVE Advection increment of the dynamics
  !!                                   prognostics [u, rho, theta, exner]
  !> @param[in]     advected_fields    ACTIVE Fields to advect: [u, rho, theta, exner]
  !> @param[in]     wind_np1           ACTIVE End of timestep wind field
  !> @param[in]     wind_n             ACTIVE Start of timestep wind field
  !> @param[in,out] mr_out             ACTIVE Moisture fields after transport
  !> @param[in]     mr_in              ACTIVE Moisture fields before transport
  !> @param[in]     ls_advected_fields PASSIVE Fields to advect: [u, rho, theta, exner]
  !> @param[in]     ls_wind_np1        PASSIVE End of timestep wind field
  !> @param[in]     ls_wind_n          PASSIVE Start of timestep wind field
  !> @param[in]     ls_mr_in           PASSIVE Moisture fields before transport
  !> @param[in]     model_clock        Time within the model
  !> @param[in]     outer              Outer (advection) iteration number
  !>
  subroutine tl_transport_control_alg(advection_inc, advected_fields,   &
                                      wind_np1, wind_n, mr_out, mr_in,  &
                                      ls_advected_fields,               &
                                      ls_wind_np1, ls_wind_n, ls_mr_in, &
                                      model_clock, outer )

    use check_configuration_mod,         only: check_any_shifted
    use derived_config_mod,              only: bundle_size
    use extrusion_mod,                   only: SHIFTED
    use sci_field_bundle_builtins_mod,   only: clone_bundle, set_bundle_scalar
    use field_indices_mod,               only: igh_u, igh_t, igh_d, igh_p
    use fs_continuity_mod,               only: Wtheta
    use mesh_mod,                        only: mesh_type
    use mesh_collection_mod,             only: mesh_collection
    use mr_indices_mod,                  only: nummr
    use operator_mod,                    only: operator_type
    use tl_moist_mr_transport_alg_mod,   only: tl_moist_mr_transport_alg
    use tl_theta_transport_alg_mod,      only: tl_theta_transport_alg
    use tl_transport_field_mod,          only: tl_transport_field
    use tl_wind_transport_alg_mod,       only: tl_wind_transport_alg
    use io_config_mod,                   only: subroutine_timers
    use timer_mod,                       only: timer

    implicit none

    ! Arguments
    type(field_type),            intent(inout) :: advection_inc(bundle_size)
    type(field_type),            intent(in)    :: advected_fields(bundle_size)
    type(field_type),            intent(in)    :: wind_np1
    type(field_type),            intent(in)    :: wind_n
    type(field_type),            intent(in)    :: ls_wind_np1
    type(field_type),            intent(in)    :: ls_wind_n
    type(field_type),            intent(inout) :: mr_out(nummr)
    type(field_type),            intent(in)    :: mr_in(nummr)
    type(field_type),            intent(in)    :: ls_advected_fields(bundle_size)
    type(field_type),            intent(in)    :: ls_mr_in(nummr)
    class(model_clock_type),     intent(in)    :: model_clock
    integer(kind=i_def),         intent(in)    :: outer

    ! Internal variables
    type(field_type)    :: fields_np1(bundle_size)
    logical(kind=l_def) :: any_shifted
    logical(kind=l_def) :: cheap_update_flag
    real(r_def)         :: cast_dt
    type(mesh_type),     pointer :: primary_mesh => null()
    type(mesh_type),     pointer :: shifted_mesh => null()

    type(transport_metadata_type), pointer :: transport_metadata => null()

    if ( subroutine_timers ) call timer('tl_transport_control')

    ! ------------------------------------------------------------------------ !
    ! Pre-transport initialisation tasks
    ! ------------------------------------------------------------------------ !

    ! Check if any horizontal method is ffsl
    any_shifted = check_any_shifted()
    cheap_update_flag = .false.
    if (cheap_update) then
      call log_event( "Transport cheap update not available for TLM", LOG_LEVEL_ERROR )
    end if

    ! Create transport_runtime object (advecting wind etc)
    if ( any_shifted ) then
      primary_mesh => ls_wind_n%get_mesh()
      shifted_mesh => mesh_collection%get_mesh(primary_mesh, SHIFTED)

      call set_transport_runtime( ls_wind_n, ls_wind_np1,                      &
                                  model_clock, outer,                          &
                                  cheap_update_flag,                           &
                                  rho_d_n_rdef=advected_fields(igh_d),         &
                                  shifted_mesh=shifted_mesh )
      call tl_transport_runtime%initialise( wind_n, wind_np1,                  &
                                            model_clock, outer,                &
                                            cheap_update_flag,                 &
                                            rho_d_n_rdef=ls_advected_fields(igh_d), &
                                            shifted_mesh=shifted_mesh )

      nullify(primary_mesh, shifted_mesh)
    else
      call set_transport_runtime( ls_wind_n, ls_wind_np1,                      &
                                  model_clock, outer,                          &
                                  cheap_update_flag,                           &
                                  rho_d_n_rdef=advected_fields(igh_d) )
      call tl_transport_runtime%initialise( wind_n, wind_np1,                  &
                                            model_clock, outer,                &
                                            cheap_update_flag,                 &
                                            rho_d_n_rdef=ls_advected_fields(igh_d) )
    end if

    ! Initialise fields
    call clone_bundle(advected_fields, fields_np1, bundle_size)
    call set_bundle_scalar(0.0_r_def, fields_np1, bundle_size)

    ! ------------------------------------------------------------------------ !
    ! Transport of prognostic variables
    ! ------------------------------------------------------------------------ !

    cast_dt = real( model_clock%get_seconds_per_step(), r_def )

    ! ------------------------------------------------------------------------ !
    ! Transport dry density
    call log_event( "Transporting density...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('density')
    call tl_transport_field( fields_np1(igh_d), advected_fields(igh_d), &
                             ls_advected_fields(igh_d), cast_dt,        &
                             transport_metadata )
    call invoke( X_minus_Y( advection_inc(igh_d), fields_np1(igh_d), &
                            advected_fields(igh_d) ) )

    ! TODO: implement computation of consistent quantities here

    ! ------------------------------------------------------------------------ !
    ! Transport wind field
    call log_event( "Transporting wind...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('wind')
    call tl_wind_transport_alg( advection_inc(igh_u), advected_fields(igh_u), &
                                ls_advected_fields(igh_u), cast_dt,           &
                                transport_metadata )
    ! We don't change advection_inc(igh_u) as tl_wind_transport_alg
    ! already returns weak increment

    ! ------------------------------------------------------------------------ !
    ! Don't transport Exner pressure
    call invoke( setval_c(advection_inc(igh_p), 0.0_r_def) )

    ! ------------------------------------------------------------------------ !
    ! Transport moisture mixing ratio fields
    if ( moisture_formulation /= moisture_formulation_dry ) then

      call log_event("Transporting moisture mixing ratio fields...", LOG_LEVEL_INFO)
      transport_metadata => transport_metadata_collection%get_transport_metadata('moisture')
      call tl_moist_mr_transport_alg( mr_out, mr_in, ls_mr_in,      &
                                      nummr_to_transport, cast_dt, &
                                      transport_metadata )

    end if

    ! ------------------------------------------------------------------------ !
    ! Transport potential temperature (must be after moisture)
    ! NB: moisture not passed through as theta_vd transport not yet implemented
    ! Note: theta increment is pointwise
    call log_event( "Transporting potential temperature...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('potential_temperature')
    call tl_theta_transport_alg( fields_np1(igh_t), advection_inc(igh_t),   &
                                 advected_fields(igh_t),                    &
                                 ls_advected_fields(igh_t), cast_dt,        &
                                 transport_metadata )

    if ( subroutine_timers ) call timer('tl_transport_control')

  end subroutine tl_transport_control_alg

end module tl_transport_control_alg_mod
