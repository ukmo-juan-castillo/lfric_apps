!-----------------------------------------------------------------------------
! (C) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!>@brief Algorithm to compute adjoint of the vorticity: curl(u)
module adj_compute_vorticity_alg_mod

  use constants_mod, only: r_def, i_def, l_def

  implicit none

  private
  public :: adj_compute_vorticity_alg

contains

  !> @brief Algorithm to compute the adjoint of vorticity field
  !> @param[in,out] xi Vorticity field = curl(u)
  !> @param[in]     u Velocity field
  !> @param[in]     weak_form_u Is u in weak form or not
  subroutine adj_compute_vorticity_alg(xi, u, weak_form_u, w1_flag)

    use field_mod,                      only : field_type
    use operator_mod,                   only : operator_type
    use sci_mass_matrix_solver_alg_mod, only : mass_matrix_solver_alg
    use sci_enforce_bc_kernel_mod,      only : enforce_bc_kernel_type
    use sci_fem_constants_mod,          only : get_inverse_lumped_mass_matrix_fe, &
                                               get_curl_fe, get_qr_fe
    use adj_transpose_matrix_vector_kernel_mod, &
                                        only : adj_transpose_matrix_vector_kernel_type
    use finite_element_config_mod,      only : vorticity_in_w1
    use fs_continuity_mod,              only : W1
    use function_space_collection_mod,  only : function_space_collection
    use adj_w2_to_w1_projection_kernel_mod, &
                                        only : adj_w2_to_w1_projection_kernel_type
    use function_space_mod,             only : function_space_type
    use log_mod,                        only : LOG_LEVEL_INFO
    use mesh_mod,                       only : mesh_type
    use quadrature_xyoz_mod,            only : quadrature_xyoz_type
    use adj_strong_curl_kernel_mod,     only : adj_strong_curl_kernel_type

    implicit none

    type(field_type),     intent(inout)       :: xi
    type(field_type),     intent(inout)       :: u
    logical(kind=l_def),  intent(in)          :: weak_form_u
    logical(kind=l_def), optional, intent(in) :: w1_flag

    type(field_type)                    :: advected_u, r_xi, u_in_w1, r_u
    type(field_type),           pointer :: m1_lumped_inv
    type(operator_type),        pointer :: curl
    type(function_space_type) , pointer :: w1_fs
    type(quadrature_xyoz_type), pointer :: qr
    integer(kind=i_def)                 :: element_order_h, element_order_v
    logical(kind=l_def)                 :: w1_vorticity_flag

    type(mesh_type), pointer :: mesh

    mesh => u%get_mesh()
    element_order_h = u%get_element_order_h()
    element_order_v = u%get_element_order_v()

    if ( present(w1_flag) ) then
      w1_vorticity_flag = w1_flag
    else
      w1_vorticity_flag = vorticity_in_w1
    end if

    ! Initialising advected_u
    if ( weak_form_u ) then
      call advected_u%initialise( vector_space = u%get_function_space()  )
    else
      call u%copy_field_properties(advected_u)
    end if
    call invoke( setval_c(advected_u, 0.0_r_def) )

    if ( w1_vorticity_flag ) then
      ! Compute adjoint of vorticity in W1 as the weak curl of the W2 winds
      m1_lumped_inv => get_inverse_lumped_mass_matrix_fe(W1, mesh%get_id())
      curl          => get_curl_fe(mesh%get_id())

      call r_xi%initialise( vector_space = xi%get_function_space() )
      call invoke( setval_c( r_xi, 0.0_r_def ) )
      call mass_matrix_solver_alg( r_xi, xi )
      call invoke( setval_c(xi, 0.0_r_def),                                         &
                   enforce_bc_kernel_type(r_xi),                                    &
                   adj_transpose_matrix_vector_kernel_type(r_xi, advected_u, curl), &
                   setval_c(r_xi, 0.0_r_def) )
    else
      ! Compute adjoint of vorticity in W2 as the strong curl of the projected W1 winds
      qr => get_qr_fe()

      w1_fs => function_space_collection%get_fs( mesh, element_order_h, element_order_v, W1 )
      call u_in_w1%initialise( vector_space = w1_fs )
      call r_u%initialise( vector_space = w1_fs )
      call invoke( setval_c( u_in_w1, 0.0_r_def ), &
                   setval_c( r_u, 0.0_r_def ) )
      call invoke( adj_strong_curl_kernel_type(xi, u_in_w1) )
      call mass_matrix_solver_alg( r_u, u_in_w1, .false.)
      call invoke( adj_w2_to_w1_projection_kernel_type(r_u, advected_u, qr), &
                   setval_c(u_in_w1, 0.0_r_def),                             &
                   setval_c(r_u, 0.0_r_def)                                  &
                  )
    end if

    if ( weak_form_u ) then
      call mass_matrix_solver_alg(advected_u, u)
    else
      call invoke( inc_X_plus_Y(u, advected_u) )
    end if
    call invoke( setval_c(advected_u, 0.0_r_def) )

  end subroutine adj_compute_vorticity_alg

end module adj_compute_vorticity_alg_mod
