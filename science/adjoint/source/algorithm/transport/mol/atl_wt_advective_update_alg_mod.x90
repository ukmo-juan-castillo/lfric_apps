!-----------------------------------------------------------------------------
! (c) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Adjoint of tangent linear for the advective update A of a variable f by a wind U

module atl_wt_advective_update_alg_mod

  use constants_mod,                      only: r_def, i_def, l_def
  use sci_fem_constants_mod,              only: get_inverse_lumped_mass_matrix_fe
  use field_mod,                          only: field_type
  use finite_element_config_mod,          only: element_order_h, element_order_v
  use fs_continuity_mod,                  only: Wtheta, W2H, W2V
  use function_space_mod,                 only: function_space_type
  use function_space_collection_mod,      only: function_space_collection
  use mesh_mod,                           only: mesh_type
  use transport_config_mod,               only: operators,            &
                                                fv_horizontal_order,  &
                                                fv_vertical_order,    &
                                                operators_fv,         &
                                                operators_fem,        &
                                                consistent_metric
  use log_mod,                            only: log_event,         &
                                                LOG_LEVEL_ERROR
  use transport_enumerated_types_mod,     only: direction_v,                  &
                                                direction_h,                  &
                                                direction_3d,                 &
                                                monotone_koren
  use transport_metadata_mod,             only: transport_metadata_type
  use wt_advective_update_alg_mod,        only: hori_wt_update_alg
  use remap_on_extended_mesh_alg_mod,     only: remap_on_extended_mesh
  use split_w2_field_kernel_mod,          only: split_w2_field_kernel_type
  use integer_field_mod,                  only: integer_field_type
  use sci_geometric_constants_mod,        only: get_face_selector_ew,            &
                                                get_face_selector_ns

  implicit none

  private

  public :: atl_wt_advective_update_alg
  public :: atl_hori_wt_update_alg
  public :: atl_vert_wt_update_alg

contains

  !=============================================================================
  !> @brief Compute advective update of a Wtheta field for adjoint app.
  !> @param[in,out] rhs                     ACTIVE Change in Advective increment
  !> @param[in]     adv_field               ACTIVE Change in Field to advect
  !> @param[in]     wind                    ACTIVE Change in Advecting wind field
  !> @param[in]     ls_adv_field            Lin state for Field to advect
  !> @param[in]     ls_wind                 Lin state for Advecting wind field
  !> @param[in]     dt                      Timestep
  !> @param[in]     direction               Direction of the transport
  !> @param[in]     transport_metadata      Contains transport configuration options
  !> @param[in]     final_rk_stage          Whether this is the last Runge-Kutta stage
  !> @param[in]     adj_lookup_table_cache  Lookup table cache
  subroutine atl_wt_advective_update_alg( rhs, adv_field, wind,               &
                                          ls_adv_field, ls_wind,              &
                                          dt, direction,                      &
                                          transport_metadata, final_rk_stage, &
                                          adj_lookup_table_cache )

    use adj_trans_lookup_cache_mod,      only : adj_trans_lookup_cache_type
    use reference_element_mod,           only : reference_element_type
    use mesh_mod,                        only : mesh_type
    use adj_wt_advective_update_alg_mod, only : adj_hori_wt_update_alg
    use adj_split_w2_field_kernel_mod,   only : adj_split_w2_field_kernel_type

    implicit none

    type(field_type),                  intent(inout) :: adv_field, wind
    type(field_type),                  intent(in)    :: ls_adv_field, ls_wind
    type(field_type),                  intent(inout) :: rhs
    real(kind=r_def),                  intent(in)    :: dt
    integer(kind=i_def),               intent(in)    :: direction
    type(transport_metadata_type),     intent(in)    :: transport_metadata
    logical(kind=l_def),               intent(in)    :: final_rk_stage
    type(adj_trans_lookup_cache_type), intent(in)    :: adj_lookup_table_cache

    type(field_type)                       :: u_grad_f
    type(field_type)                       :: wind_v
    type(field_type)                       :: wind_h
    type(field_type)                       :: ls_wind_v
    type(field_type)                       :: ls_wind_h
    type(function_space_type),     pointer :: w2h_fs, w2v_fs
    type(integer_field_type),      pointer :: face_selector_ew
    type(integer_field_type),      pointer :: face_selector_ns
    type(field_type),              pointer :: mt_lumped_inv
    type(mesh_type),               pointer :: mesh

    mesh => wind%get_mesh()
    call u_grad_f%initialise( adv_field%get_function_space() )
    mt_lumped_inv => get_inverse_lumped_mass_matrix_fe( Wtheta, mesh%get_id() )
    call invoke( X_times_Y(u_grad_f, rhs, mt_lumped_inv), &
                 setval_c(rhs, 0.0_r_def) )

    select case( operators )

    case default
      call log_event( "Gungho: Unrecognised option for wtheta reconstruction.", LOG_LEVEL_ERROR )

    case( operators_fv )

      select case ( direction )

      case ( direction_3d )
        w2h_fs => function_space_collection%get_fs(                            &
            mesh, element_order_h, element_order_v, W2H                        &
        )
        w2v_fs => function_space_collection%get_fs(                            &
            mesh, element_order_h, element_order_v, W2V                        &
        )
        face_selector_ew => get_face_selector_ew(mesh%get_id())
        face_selector_ns => get_face_selector_ns(mesh%get_id())
        call wind_h%initialise(w2h_fs)
        call wind_v%initialise(w2v_fs)
        call ls_wind_h%initialise(w2h_fs)
        call ls_wind_v%initialise(w2v_fs)

        call invoke( setval_c(wind_h, 0.0_r_def),                              &
                     setval_c(wind_v, 0.0_r_def),                              &
                     split_w2_field_kernel_type(ls_wind_h, ls_wind_v, ls_wind, &
                                                face_selector_ew,              &
                                                face_selector_ns))

        if ( consistent_metric ) then
          call log_event( "ATL: consistent metric not implemented", LOG_LEVEL_ERROR )
        end if

        call atl_vert_wt_update_alg( u_grad_f, wind_v, adv_field, &
                                     ls_wind_v, ls_adv_field,     &
                                     transport_metadata, final_rk_stage )

        ! Horizontal update
        call atl_hori_wt_update_alg( u_grad_f, wind_h, ls_wind_h, ls_adv_field, transport_metadata )
        call adj_hori_wt_update_alg( u_grad_f, ls_wind_h, ls_wind_h, adv_field, transport_metadata, &
                                     adj_lookup_table_cache )

        call invoke( adj_split_w2_field_kernel_type(wind_h, wind_v, wind,          &
                                                    face_selector_ew,              &
                                                    face_selector_ns))


      case ( direction_h )
        call atl_hori_wt_update_alg( u_grad_f, wind, ls_wind, ls_adv_field, transport_metadata )
        call adj_hori_wt_update_alg( u_grad_f, ls_wind, ls_wind, adv_field, transport_metadata, &
                                     adj_lookup_table_cache )


      case ( direction_v )
        call atl_vert_wt_update_alg( u_grad_f, wind, adv_field, &
                                     ls_wind, ls_adv_field,     &
                                     transport_metadata, final_rk_stage )
      case default
        call log_event('A.T.L. advective update: direction not recognised', LOG_LEVEL_ERROR)
      end select


    case(operators_fem)
      call log_event( "ATL: fem not available", LOG_LEVEL_ERROR )
    end select

  end subroutine atl_wt_advective_update_alg

  !=============================================================================
  !> @brief Compute the adjoint of tangent linear of the horizontal advective update of a Wtheta field.
  !> @param[in,out] u_grad_f            Horizontal part of u.grad(f)
  !> @param[in]     wind                Advecting wind field
  !> @param[in]     wind_dir            Wind field used to determine direction in kernel
  !> @param[in]     ls_field            Linearisation state Wtheta field
  !> @param[in]     transport_metadata  Contains transport configuration options
  subroutine atl_hori_wt_update_alg(u_grad_f, wind, wind_dir, ls_field, transport_metadata)

    use poly1d_reconstruction_kernel_mod, only : poly1d_reconstruction_kernel_type
    use poly2d_reconstruction_kernel_mod, only : poly2d_reconstruction_kernel_type
    use polyh_wtheta_koren_kernel_mod,    only : polyh_wtheta_koren_kernel_type
    use atl_poly_adv_update_kernel_mod,   only : atl_poly_adv_update_kernel_type
    use transport_config_mod,             only : oned_reconstruction,  &
                                                 panel_edge_treatment, &
                                                 panel_edge_treatment_none
    use transport_enumerated_types_mod,   only : monotone_koren
    use transport_constants_mod,          only : get_hori_wt_mol_coeffs

    implicit none

    type(field_type),              intent(inout) :: u_grad_f
    type(field_type),              intent(inout) :: wind
    type(field_type),              intent(in)    :: wind_dir
    type(field_type),              intent(in)    :: ls_field
    type(transport_metadata_type), intent(in)    :: transport_metadata

    type(field_type)          :: ls_h_reconstruction
    type(field_type), pointer :: adv_coeffs

    type(mesh_type),           pointer :: mesh
    type(function_space_type), pointer :: multidata_fs

    integer(kind=i_def) :: mesh_id
    integer(kind=i_def) :: stencil_extent
    integer(kind=i_def) :: stencil_size

    type(field_type), target  :: ls_remap_field, ls_field_big_halo
    type(field_type), pointer :: ls_field_ptr

    type(field_type) :: ls_h_reconstruction_big_halo
    type(field_type) :: wind_dir_big_halo

    logical(kind=l_def) :: monotone
    integer(kind=i_def) :: remap_depth

    mesh => wind%get_mesh()
    mesh_id = mesh%get_id()
    if (oned_reconstruction) then
      stencil_size = fv_horizontal_order + 1
    else if (mod(fv_horizontal_order, 2) == 0) then
      stencil_size = 1 + 2*fv_horizontal_order + fv_horizontal_order**2
    else
      stencil_size = MAX(1, 4*fv_horizontal_order + fv_horizontal_order**2)
    end if

    stencil_extent = fv_horizontal_order/2_i_def
    adv_coeffs => get_hori_wt_mol_coeffs(mesh_id)

    ! Copy field to a large halo version
    call ls_field_big_halo%initialise( ls_field%get_function_space(), &
                                       halo_depth=mesh%get_halo_depth() )
    call invoke( setval_X( ls_field_big_halo, ls_field ) )

    ! Compute reconstruction on a Wtheta multidata field
    ! each Wt point contains 4 values assigned to each edge,
    ! in the order (W,S,E,N) which is the same order as a W2 field
    multidata_fs => function_space_collection%get_fs(                          &
        mesh, element_order_h, element_order_v, Wtheta, 4, ndata_first=.false. &
    )
    call ls_h_reconstruction%initialise( multidata_fs )
    monotone = (transport_metadata%get_horizontal_monotone() == monotone_koren)
    if ( panel_edge_treatment /= panel_edge_treatment_none                     &
         .and. (monotone .or. oned_reconstruction) ) then
      remap_depth = int(fv_horizontal_order/2)
      call remap_on_extended_mesh(ls_remap_field, ls_field_big_halo,           &
                                  monotone,                                    &
                                  transport_metadata%get_enforce_min_value(),  &
                                  transport_metadata%get_min_value(),          &
                                  remap_depth)
      ls_field_ptr => ls_remap_field
    else
      ls_field_ptr => ls_field_big_halo
    end if

    if ( transport_metadata%get_horizontal_monotone() == monotone_koren ) then
      call invoke( name="wt_koren",                              &
                   polyh_wtheta_koren_kernel_type(               &
                                            ls_h_reconstruction, &
                                            ls_field_ptr,        &
                                            stencil_extent))

    else
      if ( oned_reconstruction ) then
        ! Use 1d reconstruction
        call invoke( name="wt_1d_recon",                           &
                     poly1d_reconstruction_kernel_type(            &
                                              ls_h_reconstruction, &
                                              ls_field_ptr,        &
                                              stencil_extent,      &
                                              adv_coeffs,          &
                                              fv_horizontal_order ) )
      else
        ! Use 2d reconstruction
        call invoke( name="wt_2d_recon",                           &
                     poly2d_reconstruction_kernel_type(            &
                                              ls_h_reconstruction, &
                                              ls_field_big_halo,   &
                                              stencil_extent,      &
                                              adv_coeffs,          &
                                              stencil_size) )
      end if

    end if

    stencil_extent = 1_i_def

    ! Stencil fields need bigger halos due to atl_poly being a stencil operation with GH_INC.
    call wind_dir_big_halo%initialise( wind_dir%get_function_space(), &
                                       halo_depth=stencil_extent + 1_i_def )
    call ls_h_reconstruction_big_halo%initialise( ls_h_reconstruction%get_function_space(), &
                                                  halo_depth=stencil_extent + 1_i_def )

    call invoke( setval_X( ls_h_reconstruction_big_halo, ls_h_reconstruction ), &
                 setval_X( wind_dir_big_halo, wind_dir ),                       &
                 atl_poly_adv_update_kernel_type( u_grad_f,                     &
                                                  ls_h_reconstruction_big_halo, &
                                                  stencil_extent,               &
                                                  wind,                         &
                                                  wind_dir_big_halo,            &
                                                  stencil_extent) )

  end subroutine atl_hori_wt_update_alg

  !=============================================================================
  !> @brief Adjoint of tangent linear vertical advective update of a Wtheta field.
  !> @param[in,out] u_grad_f            Vertical part of u.grad(f)
  !> @param[in,out] wind                Advecting wind field
  !> @param[in,out] field               Wtheta field to advect
  !> @param[in]     ls_wind             Linearised advecting wind field
  !> @param[in]     ls_field            Linearised Wtheta field to advect
  !> @param[in]     transport_metadata  Contains transport configuration options
  !> @param[in]     final_rk_stage      Whether this is the last Runge-Kutta stage
  subroutine atl_vert_wt_update_alg(u_grad_f, wind, field, ls_wind, ls_field, &
                                   transport_metadata, final_rk_stage)

    use atl_poly1d_vert_adv_kernel_mod,     only: atl_poly1d_vert_adv_kernel_type
    use transport_constants_mod,            only: get_vert_wt_mol_coeffs, &
                                                  get_reversible_vert_wt_mol_coeffs

    implicit none

    type(field_type),              intent(inout) :: field, wind
    type(field_type),              intent(in)    :: ls_field, ls_wind
    type(field_type),              intent(inout) :: u_grad_f
    type(transport_metadata_type), intent(in)    :: transport_metadata
    logical(kind=l_def),           intent(in)    :: final_rk_stage

    integer(kind=i_def)          :: mesh_id
    integer(kind=i_def)          :: vertical_order
    integer(kind=i_def)          :: ndata_v
    type(mesh_type),     pointer :: mesh
    type(field_type),    pointer :: vert_adv_coeffs
    logical(kind=l_def)          :: logspace
    logical(kind=l_def)          :: reversible
    integer(kind=i_def)          :: monotonicity

    reversible = ( transport_metadata%get_reversible() .and. final_rk_stage )
    logspace = transport_metadata%get_log_space()
    monotonicity = transport_metadata%get_vertical_monotone()

    mesh => wind%get_mesh()
    mesh_id = mesh%get_id()

    if ( reversible ) then
      vert_adv_coeffs => get_reversible_vert_wt_mol_coeffs(mesh_id)
      vertical_order = fv_vertical_order
    else
      vert_adv_coeffs => get_vert_wt_mol_coeffs(mesh_id)
      vertical_order = fv_vertical_order + 1_i_def
    end if

    ndata_v = 2_i_def*(vertical_order + 1_i_def)

    if ( monotonicity == monotone_koren ) then
      call log_event('A.T.L. Wtheta advective update not implemented with Koren scheme', LOG_LEVEL_ERROR)

    else
      call invoke( atl_poly1d_vert_adv_kernel_type( u_grad_f,        &
                                                    wind,            &
                                                    field,           &
                                                    ls_wind,         &
                                                    ls_field,        &
                                                    vert_adv_coeffs, &
                                                    ndata_v,         &
                                                    vertical_order,  &
                                                    logspace ) )
    end if

  end subroutine atl_vert_wt_update_alg

end module atl_wt_advective_update_alg_mod
