!-----------------------------------------------------------------------------
! (c) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Adjoint reconstruction of a W3 field at W2 points for use in the transport scheme.
module adj_reconstruct_w3_field_alg_mod

  use constants_mod,                        only: r_tran, i_def, l_def
  use r_tran_field_mod,                     only: r_tran_field_type

  use invoke_adj_poly1d_recon_lookup_mod,   only: invoke_adj_poly1d_recon_lookup
  use invoke_adj_poly2d_recon_lookup_mod,   only: invoke_adj_poly2d_recon_lookup
  use adj_trans_lookup_cache_mod,           only: adj_trans_lookup_cache_type
  use adj_lookup_table_mod,                 only: adj_lookup_table_type
  use integer_field_mod,                    only: integer_field_type
  use function_space_mod,                   only: function_space_type
  use transport_config_mod,                 only: fv_horizontal_order,  &
                                                  oned_reconstruction,  &
                                                  panel_edge_treatment, &
                                                  panel_edge_treatment_none
  use log_mod,                              only: log_event,         &
                                                  LOG_LEVEL_ERROR
  use mesh_mod,                             only: mesh_type
  use transport_enumerated_types_mod,       only: monotone_koren
  use transport_metadata_mod,               only: transport_metadata_type
  use transport_constants_mod,              only: get_hori_w3_mol_coeffs
  use remap_on_extended_mesh_alg_mod,       only: remap_on_extended_mesh

  implicit none

  private

  public :: adj_hori_w3_reconstruct_alg

contains

  !=============================================================================
  !> @brief Adjoint of reconstruction of a W3 field in the horizontal component of W2
  !> @param[in,out] field_new               The resulting horizontal W2 field
  !> @param[in,out] field_old               The input W3 field
  !> @param[in]     transport_metadata      Contains transport configuration options
  !> @param[in]     adj_lookup_table_cache  Lookup table cache
  subroutine adj_hori_w3_reconstruct_alg( field_new, field_old, &
                                          transport_metadata, adj_lookup_table_cache )

    implicit none

    type(r_tran_field_type),           intent(inout) :: field_new
    type(r_tran_field_type),           intent(inout) :: field_old
    type(transport_metadata_type),     intent(in)    :: transport_metadata
    type(adj_trans_lookup_cache_type), intent(in)    :: adj_lookup_table_cache

    type(mesh_type),         pointer :: mesh
    integer(kind=i_def)              :: mesh_id
    integer(kind=i_def)              :: stencil_extent
    integer(kind=i_def)              :: stencil_size
    type(r_tran_field_type), pointer :: flux_coeffs

    type(r_tran_field_type), target  :: remap_field, field_old_big_halo
    type(r_tran_field_type), pointer :: field_ptr

    logical(kind=l_def) :: monotone
    integer(kind=i_def) :: remap_depth

    type(adj_lookup_table_type), pointer :: lookup_poly
    type(integer_field_type),    pointer :: lookup_poly_field
    type(integer_field_type),    pointer :: num_sets_poly_field
    integer(kind=i_def)                  :: nsets
    integer(kind=i_def)                  :: nindices

    nullify(mesh, flux_coeffs, field_ptr, &
            lookup_poly, lookup_poly_field, num_sets_poly_field)

    mesh => field_new%get_mesh()
    mesh_id = mesh%get_id()

    ! Get extents and data sizes for this mesh
    stencil_extent = fv_horizontal_order/2_i_def
    if (oned_reconstruction) then
      stencil_size = fv_horizontal_order + 1
    else if (mod(fv_horizontal_order, 2) == 0) then
      stencil_size = 1 + 2*fv_horizontal_order + fv_horizontal_order**2
    else
      stencil_size = MAX(1, 4*fv_horizontal_order + fv_horizontal_order**2)
    end if

    flux_coeffs => get_hori_w3_mol_coeffs(mesh_id)

    ! Copy field to a large halo version
    call field_old_big_halo%initialise( field_old%get_function_space(), &
                                        halo_depth=mesh%get_halo_depth() )
    call invoke( setval_c( field_old_big_halo, 0.0_r_tran ) )

    monotone = (transport_metadata%get_horizontal_monotone() == monotone_koren)
    if ( panel_edge_treatment /= panel_edge_treatment_none                     &
         .and. (monotone .or. oned_reconstruction) ) then
      remap_depth = int(fv_horizontal_order/2)
      call remap_on_extended_mesh(remap_field, field_old_big_halo,             &
                                  monotone,                                    &
                                  transport_metadata%get_enforce_min_value(),  &
                                  transport_metadata%get_min_value(),          &
                                  remap_depth)
      field_ptr => remap_field
    else
      field_ptr => field_old_big_halo
    end if

    if ( transport_metadata%get_horizontal_monotone() == monotone_koren ) then
      call log_event( "ADJ Koren not available for cross stencil of size 5", LOG_LEVEL_ERROR )

    else if ( oned_reconstruction ) then
      ! Use 1d flux reconstruction
      lookup_poly => adj_lookup_table_cache%get_lookup_poly1d()
      lookup_poly_field => lookup_poly%get_lookup_field()
      num_sets_poly_field => lookup_poly%get_set_count_field()
      nindices = lookup_poly%get_nindices()
      nsets = lookup_poly%get_nsets_max()

      ! Invoke lookup table kernel.
      call invoke_adj_poly1d_recon_lookup( field_new, field_ptr, &
                                           lookup_poly_field, num_sets_poly_field, &
                                           flux_coeffs, nsets, nindices, &
                                           stencil_extent )
    else
      ! Use 2d flux reconstruction
      stencil_extent = fv_horizontal_order / 2_i_def
      lookup_poly => adj_lookup_table_cache%get_lookup_poly2d(field_new%which_function_space())
      lookup_poly_field => lookup_poly%get_lookup_field()
      num_sets_poly_field => lookup_poly%get_set_count_field()
      nindices = lookup_poly%get_nindices()
      nsets = lookup_poly%get_nsets_max()

      call invoke_adj_poly2d_recon_lookup( field_new, field_old_big_halo, &
                                           lookup_poly_field, num_sets_poly_field, &
                                           flux_coeffs, nsets, nindices, &
                                           stencil_extent )
    end if

    call invoke( inc_X_plus_Y( field_old, field_ptr ) )

  end subroutine adj_hori_w3_reconstruct_alg

end module adj_reconstruct_w3_field_alg_mod
