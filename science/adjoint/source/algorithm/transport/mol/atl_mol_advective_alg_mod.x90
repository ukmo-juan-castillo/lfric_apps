!-----------------------------------------------------------------------------
! (c) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Contains adjoint routine for advecting (advection-form) fields using MOL.

module atl_mol_advective_alg_mod

  ! Infrastructure
  use constants_mod,                  only: r_def, i_def, l_def
  use field_mod,                      only: field_type
  use mesh_mod,                       only: mesh_type

  ! Algorithms and transport code
  use adj_trans_lookup_cache_mod,     only: adj_trans_lookup_cache_type
  use advective_and_flux_alg_mod,     only: advective_and_flux_alg
  use atl_advective_and_flux_alg_mod, only: atl_advective_and_flux_alg
  use end_of_transport_step_alg_mod,  only: end_of_advective_step_alg
  use atl_end_transport_step_alg_mod,  &
                                      only: atl_end_advective_step_alg
  use runge_kutta_init_mod,           only: get_rk_transport_weights
  use split_transport_utils_mod,      only: get_splitting_direction
  use transport_controller_mod,       only: transport_controller_type
  use tl_transport_controller_mod,    only: tl_transport_controller_type
  use transport_counter_mod,          only: transport_counter_type
  use transport_metadata_mod,         only: transport_metadata_type
  use wind_precomputations_alg_mod,   only: wind_precomputations_type

  ! Configuration
  use transport_config_mod,           only: runge_kutta_method
  use linear_config_mod,              only: transport_efficiency

  implicit none

  public  :: atl_mol_advective_alg

contains

  !=============================================================================
  !> @brief Adjoint of tangent linear advection of a field with the MOL scheme.
  !> @param[in,out] field_np1                ACTIVE  Field at the end of the time step
  !> @param[in]     field                    ACTIVE  Field at the start of the transport step
  !> @param[in]     ls_field                 PASSIVE Field at the start of the transport step
  !> @param[in]     direction                Direction of advection (vertical, horizontal, or 3d)
  !> @param[in,out] tl_transport_controller  Object controlling transport
  !> @param[in]     adj_lookup_table_cache   Lookup table cache
  subroutine atl_mol_advective_alg( field_np1, field, ls_field, &
                                    tl_transport_controller, adj_lookup_table_cache )

    implicit none

    type(field_type),                   intent(inout) :: field_np1
    type(field_type),                   intent(inout) :: field
    type(field_type),                   intent(in)    :: ls_field
    type(tl_transport_controller_type), intent(inout) :: tl_transport_controller
    type(adj_trans_lookup_cache_type),  intent(in)    :: adj_lookup_table_cache

    ! Internal variables
    integer(kind=i_def)                      :: stage, s, direction
    integer(kind=i_def)                      :: nstage, substep
    integer(kind=i_def)                      :: ls_stage, ls_nstage
    integer(kind=i_def)                      :: number_substeps
    integer(kind=i_def)                      :: ls_number_substeps, ls_substep
    integer(kind=i_def)                      :: step
    integer(kind=i_def)                      :: splitting
    real(kind=r_def)                         :: dt_mol_substep
    logical(kind=l_def)                      :: final_rk_stage
    type(mesh_type),                 pointer :: mesh
    type(field_type)                         :: rhs, field_n
    type(field_type)                         :: rhs_field, dummy
    type(field_type)                         :: ls_field_np1, ls_field_n
    type(field_type),                pointer :: advecting_wind
    type(field_type),                pointer :: ls_advecting_wind
    type(field_type),            allocatable :: stored_ls_field(:,:)
    type(field_type),            allocatable :: rk_field(:)
    real(kind=r_def),            allocatable :: rk_weights(:,:)
    type(transport_metadata_type),   pointer :: transport_metadata
    type(transport_metadata_type),   pointer :: ls_transport_metadata
    type(transport_counter_type),    pointer :: transport_counter
    type(transport_counter_type),    pointer :: ls_transport_counter
    type(transport_controller_type), pointer :: transport_controller
    type(transport_controller_type), pointer :: ls_transport_controller
    type(transport_controller_type), pointer :: pert_transport_controller
    type(wind_precomputations_type), pointer :: ls_wind_precomputations
    type(wind_precomputations_type), pointer :: pert_wind_precomputations

    ! ------------------------------------------------------------------------ !
    ! Extract transport objects and initialise temporary fields
    ! ------------------------------------------------------------------------ !
    mesh => field%get_mesh()
    transport_controller => tl_transport_controller%get_ls_wind_ls_rho_controller()
    ls_transport_controller => tl_transport_controller%get_ls_wind_pert_rho_controller()
    pert_transport_controller => tl_transport_controller%get_pert_wind_ls_rho_controller()

    transport_metadata => pert_transport_controller%get_transport_metadata()
    ls_transport_metadata => transport_controller%get_transport_metadata()

    transport_counter => pert_transport_controller%get_transport_counter()
    ls_transport_counter => transport_controller%get_transport_counter()

    ls_wind_precomputations => ls_transport_controller%get_wind_precomputations()
    pert_wind_precomputations => pert_transport_controller%get_wind_precomputations()

    step = transport_counter%get_split_step_of_substep_counter()
    splitting = transport_metadata%get_splitting()
    direction = get_splitting_direction(splitting, step)

    advecting_wind => pert_wind_precomputations%get_wind(mesh%get_id(), direction)
    ls_advecting_wind => ls_wind_precomputations%get_wind(mesh%get_id(), direction)
    number_substeps = ls_wind_precomputations%get_number_mol_substeps(         &
            mesh%get_id(), direction, splitting, step                          &
    )
    dt_mol_substep = ls_wind_precomputations%get_dt_mol_substep(               &
            mesh%get_id(), direction, splitting, step                          &
    )

    call get_rk_transport_weights(nstage, rk_weights, runge_kutta_method)

    if (transport_efficiency) then
      ls_number_substeps = 1
      ls_nstage =1
    else
      ls_number_substeps = number_substeps
      ls_nstage = nstage
    end if

    allocate( rk_field(nstage) )
    allocate( stored_ls_field(ls_number_substeps, ls_nstage) )

    do stage = 1, nstage
      call rk_field(stage)%initialise(field%get_function_space())
    end do
    do ls_stage = 1, ls_nstage
      do ls_substep = 1, ls_number_substeps
        call stored_ls_field(ls_substep, ls_stage)%initialise(field%get_function_space())
      end do
    end do
    call rhs_field%initialise( field%get_function_space() )

    call rhs%initialise(field%get_function_space())
    call field_n%initialise(field%get_function_space())

    ! May need this line outside of adjoint, since it resets field_np1 values
    ! in adjoint test.
    ! call field%copy_field_properties(field_np1)
    call ls_field%copy_field_properties(ls_field_np1)

    call invoke( setval_c( field_n, 0.0_r_def ), &
                 setval_X(ls_field_np1, ls_field) )

    ! To ensure the setting of dummy in the LS calculation does not affect the adjoint,
    ! we initialise it more formally here.
    call advecting_wind%copy_field_properties( dummy )

    !--------------------------------------------------------------------------!
    !                    Linearisation state
    !
    !       This calculates the values of ls_field. These are stored as an
    !       array for each substep and each RK stage to use in the perturbation
    !--------------------------------------------------------------------------!

    if (transport_efficiency) then
      call invoke( setval_X(stored_ls_field(1,1), ls_field_np1 ))
    else

    ! Perform the number of rk-stages and substeps required
    do substep = 1, ls_number_substeps

      ! Reset field_n ready for the this substep
      call ls_field_np1%copy_field_properties(ls_field_n)
      call invoke( setval_X(ls_field_n, ls_field_np1) )

      do stage = 1, ls_nstage
        ! Store values for use in the perturbation code. This is done before
        ! advecting so as to pick up the correct linearisation state
        call invoke( setval_X(stored_ls_field(substep, stage), ls_field_np1) )

        final_rk_stage = ( stage == ls_nstage )

        ! Compute the field for this stage:
        ! rhs_field = sum(s=1,stage): a(stage,s)*field^(s)
        call invoke( setval_X( rk_field(stage), ls_field_np1 ), &
                     setval_c( rhs_field, 0.0_r_def ) )
        do s = 1, stage
          call invoke( inc_X_plus_bY( rhs_field, rk_weights(stage,s), rk_field(s) ) )
        end do

        ! Compute update: rhs = u.grad(rhs_field)
        call advective_and_flux_alg(dummy, rhs, rhs_field, ls_field_n,     &
                                    ls_advecting_wind, direction,          &
                                    ls_transport_metadata, final_rk_stage, &
                                    dt_mol_substep, .false., .true. )

        ! Update field: f = f^n - dt*rhs
        call invoke( X_minus_bY(ls_field_np1, ls_field_n, dt_mol_substep, rhs) )
      end do  ! end rk-stages

    end do

    ! End of step: if necessary enforce min val and overwrite in blending zone
    call end_of_advective_step_alg(                                               &
            ls_field_np1, ls_field_n, ls_transport_counter, ls_transport_metadata &
    )

    end if

    ! --------------------------------------------------------------------------
    !                    Perturbation
    !
    !   Repeat the calculation, but now for the adjoint - adding in
    !   the values of ls_field_np1(substep,stage) obtained in the
    !   linearisation stage stage
    !---------------------------------------------------------------------------

    ! Init values of intermediate adjoint fields. Some of these have values used
    ! in the LS calculation and therefore have to be reset here.
    call invoke( setval_c( rhs_field, 0.0_r_def ), &
                 setval_c( rhs, 0.0_r_def ),       &
                 setval_c( dummy, 0.0_r_def ) )
    do stage = 1, nstage
      call invoke( setval_c( rk_field(stage), 0.0_r_def ) )
    end do

    ! End of step: if necessary enforce min val and overwrite in blending zone
    call atl_end_advective_step_alg(                                           &
            field_np1, field_n, transport_counter, transport_metadata          &
    )

    ! Perform the number of rk-stages and substeps required
    do substep = number_substeps, 1, -1

      if (transport_efficiency) then
        ls_substep = 1
      else
        ls_substep = substep
      end if

      do stage = nstage, 1, -1

        if (transport_efficiency) then
           ls_stage = 1
        else
           ls_stage = stage
        end if

        final_rk_stage = ( stage == nstage )

        ! Update field: f = f^n - dt_substep*rhs
        call invoke( inc_X_minus_bY( rhs, dt_mol_substep, field_np1 ), &
                     inc_X_plus_Y( field_n, field_np1 ) )

        ! Compute update: rhs = u.grad(rhs_field)
        call atl_advective_and_flux_alg(                                       &
                dummy, dummy, rhs, rhs_field, advecting_wind,                  &
                stored_ls_field(ls_substep, ls_stage), ls_advecting_wind,      &
                direction, transport_metadata, final_rk_stage, dt_mol_substep, &
                .false., .true., adj_lookup_table_cache                        &
        )

        do s = stage, 1, -1
          call invoke( inc_X_plus_bY( rk_field(s), rk_weights(stage,s), rhs_field ) )
        end do

        ! Compute the field for this stage:
        ! rhs_field = sum(s=1,stage): a(stage,s)*field^(s)
        call invoke( setval_c( rhs_field, 0.0_r_def ),       &
                     setval_x( field_np1, rk_field(stage) ), &
                     setval_c( rk_field(stage), 0.0_r_def ) )

      end do  ! stage

      call invoke( inc_X_plus_Y( field_np1, field_n ), &
                   setval_c( field_n, 0.0_r_def ) )

    end do ! substep

    call invoke( inc_X_plus_Y( field, field_np1 ), &
                 setval_c( field_np1, 0.0_r_def ) )

    if ( allocated(rk_field) ) deallocate(rk_field)
    if ( allocated(rk_weights) ) deallocate(rk_weights)
    if ( allocated(stored_ls_field) ) deallocate(stored_ls_field)

  end subroutine atl_mol_advective_alg

end module atl_mol_advective_alg_mod
