!-----------------------------------------------------------------------------
! (C) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Contains routine for tangent linear transport of the wind field.

module atl_wind_transport_alg_mod

  use constants_mod,                  only: i_def, r_def
  use sci_enforce_bc_kernel_mod,      only: enforce_bc_kernel_type
  use sci_fem_constants_mod,          only: get_mass_matrix_fe,         &
                                            get_inverse_mass_matrix_fe, &
                                            get_rmultiplicity_fe
  use field_mod,                      only: field_type
  use finite_element_config_mod,      only: element_order_h, &
                                            element_order_v
  use formulation_config_mod,         only: si_momentum_equation
  use fs_continuity_mod,              only: W2, W3, W2broken
  use function_space_mod,             only: function_space_type
  use function_space_collection_mod,  only: function_space_collection
  use sci_geometric_constants_mod,    only: get_coordinates, get_panel_id
  use log_mod,                        only: log_event, &
                                            LOG_LEVEL_ERROR, &
                                            LOG_LEVEL_INFO
  use sci_mapping_constants_mod,      only: get_project_xdot_to_w2,  &
                                            get_project_ydot_to_w2,  &
                                            get_project_zdot_to_w2
  use mesh_mod,                       only: mesh_type
  use operator_mod,                   only: operator_type
  use timing_mod,                     only: start_timing, stop_timing, &
                                            tik, LPROF
  use transport_enumerated_types_mod, only: equation_form_advective
  use transport_config_mod,           only: broken_w2_projection
  use tl_transport_controller_mod,    only: tl_transport_controller_type
  use atl_transport_field_mod,        only: atl_transport_field
  use transport_metadata_mod,         only: transport_metadata_type
  use sci_field_minmax_alg_mod,       only: log_field_minmax

  implicit none

  private

  public :: atl_wind_transport_alg

contains

  !=============================================================================
  !> @brief Central routine for adjoint transport of the wind field.
  !> @param[in,out] rhs_u      ACTIVE  Right-hand-side for weak wind transport
  !!                                   equation. In other words, the advective
  !!                                   increment to the wind multiplied by the
  !!                                   W2 mass matrix.
  !> @param[in,out] wind_n     ACTIVE  Wind field at start of transport step
  !> @param[in]     ls_wind_n  PASSIVE Wind field at start of transport step
  !> @param[in,out] tl_transport_controller
  !!                           Object controlling transport
  !> @param[in,out] transport_metadata Contains the configuration options for
  !!                                   transporting these fields
  subroutine atl_wind_transport_alg( rhs_u, wind_n, ls_wind_n, &
                                     tl_transport_controller, transport_metadata )

    use sci_dg_convert_hdiv_field_kernel_mod, only: dg_convert_hdiv_field_kernel_type
    use invoke_adj_cvt_hdiv_field_kernel_mod, only: invoke_adj_convert_hdiv_field_kernel
    use adj_dg_matrix_vector_kernel_mod,      only: adj_dg_matrix_vector_kernel_type
    use adj_dg_inc_matrix_vector_kernel_mod,  only: adj_dg_inc_matrix_vector_kernel_type
    use adj_matrix_vector_kernel_mod,         only: adj_matrix_vector_kernel_type
    use adj_sci_average_w2b_to_w2_kernel_mod, only: adj_average_w2b_to_w2_kernel_type

    implicit none

    ! Arguments
    type(field_type),                   intent(inout) :: rhs_u
    type(field_type),                   intent(inout) :: wind_n
    type(field_type),                      intent(in) :: ls_wind_n
    type(tl_transport_controller_type), intent(inout) :: tl_transport_controller
    type(transport_metadata_type),      intent(inout) :: transport_metadata

    ! Internal variables
    integer(kind=i_def)                :: dir
    type(mesh_type),           pointer :: mesh
    type(field_type)                   :: u_w3_n(3), u_w3_inc(3)
    type(field_type)                   :: u_w3_np1(3), ls_u_w3_n(3)
    type(field_type)                   :: u_w2_inc, u_w2b_inc, rhs_u_broken
    type(field_type),          pointer :: chi(:)
    type(field_type),          pointer :: panel_id
    type(field_type),          pointer :: rmultiplicity_w2
    type(operator_type),       pointer :: mm_w2
    type(operator_type),       pointer :: mm_w2b_inv
    type(operator_type),       pointer :: project_xdot_to_w2
    type(operator_type),       pointer :: project_ydot_to_w2
    type(operator_type),       pointer :: project_zdot_to_w2
    type(function_space_type), pointer :: w3_fs
    type(function_space_type), pointer :: w2_fs
    type(function_space_type), pointer :: w2b_fs
    integer(tik)                       :: id

    if ( LPROF ) call start_timing( id, 'atl_wind_transport' )

    ! ------------------------------------------------------------------------ !
    ! Semi-implicit formulation
    ! ------------------------------------------------------------------------ !
    if ( si_momentum_equation ) then
      ! Transport terms are handled by the semi-implicit scheme
      ! so the increment is zero
      call invoke( setval_c(rhs_u, 0.0_r_def) )

    else
      ! Transport the wind. First choose form of transport equation
      select case ( transport_metadata%get_equation_form() )

      ! ---------------------------------------------------------------------- !
      ! Advective form of transport equation
      ! ---------------------------------------------------------------------- !
      case ( equation_form_advective )

        ! Compute u in physical space and advect components in geocentric
        ! Cartesian coordinates and then map back to computational form

        mesh => wind_n%get_mesh()
        w3_fs => function_space_collection%get_fs( mesh, element_order_h, element_order_v, W3 )
        w2_fs => function_space_collection%get_fs( mesh, element_order_h, element_order_v, W2 )
        w2b_fs => function_space_collection%get_fs( mesh, element_order_h, element_order_v, W2broken )
        chi => get_coordinates(mesh%get_id())
        panel_id => get_panel_id(mesh%get_id())
        mm_w2 => get_mass_matrix_fe(W2, mesh%get_id())
        mm_w2b_inv => get_inverse_mass_matrix_fe(W2broken, mesh%get_id())
        rmultiplicity_w2 => get_rmultiplicity_fe(W2, mesh%get_id())
        project_xdot_to_w2 => get_project_xdot_to_w2(mesh%get_id())
        project_ydot_to_w2 => get_project_ydot_to_w2(mesh%get_id())
        project_zdot_to_w2 => get_project_zdot_to_w2(mesh%get_id())

        ! -------------------------------------------------------------------- !
        ! Split wind into components in W3
        ! -------------------------------------------------------------------- !

        do dir = 1,3
          call u_w3_n(dir)%initialise( w3_fs )
          call u_w3_inc(dir)%initialise( w3_fs )
          call u_w3_np1(dir)%initialise( w3_fs )
          call ls_u_w3_n(dir)%initialise( w3_fs )
          call invoke( setval_c( u_w3_inc(dir), 0.0_r_def ), &
                       setval_c( u_w3_n(dir), 0.0_r_def ),   &
                       setval_c( u_w3_np1(dir), 0.0_r_def ), &
                       setval_c( ls_u_w3_n(dir), 0.0_r_def ) )
        end do

        call invoke( dg_convert_hdiv_field_kernel_type(ls_u_w3_n, ls_wind_n, &
                                                    chi, panel_id) )

        ! -------------------------------------------------------------------- !
        ! Return from components to full wind field in W2
        ! -------------------------------------------------------------------- !

        ! Either Galerkin project in W2broken
        if (broken_w2_projection) then
          ! Galerkin projection into W2broken, then restore continuity
          call rhs_u_broken%initialise( w2b_fs )
          call u_w2b_inc%initialise( w2b_fs )
          call u_w2_inc%initialise( w2_fs )
          call invoke( name="perform_broken_projection_for_wind_inc",                                       &
                       setval_c(rhs_u_broken, 0.0_r_def),                                                   &
                       setval_c(u_w2_inc, 0.0_r_def),                                                       &
                       setval_c(u_w2b_inc, 0.0_r_def),                                                      &
                       enforce_bc_kernel_type(rhs_u),                                                       &
                       adj_matrix_vector_kernel_type(rhs_u, u_w2_inc, mm_w2),                               &
                       adj_average_w2b_to_w2_kernel_type(u_w2_inc, u_w2b_inc, rmultiplicity_w2),            &
                       adj_dg_matrix_vector_kernel_type(u_w2b_inc, rhs_u_broken, mm_w2b_inv),               &
                       adj_dg_inc_matrix_vector_kernel_type(rhs_u_broken, u_w3_inc(3), project_zdot_to_w2), &
                       adj_dg_inc_matrix_vector_kernel_type(rhs_u_broken, u_w3_inc(2), project_ydot_to_w2), &
                       adj_dg_inc_matrix_vector_kernel_type(rhs_u_broken, u_w3_inc(1), project_xdot_to_w2), &
                       setval_c(rhs_u, 0.0_r_def),                                                          &
                       inc_X_minus_Y( u_w3_n(3), u_w3_inc(3) ),                                             &
                       inc_X_plus_Y( u_w3_np1(3), u_w3_inc(3) ),                                            &
                       inc_X_minus_Y( u_w3_n(2), u_w3_inc(2) ),                                             &
                       inc_X_plus_Y( u_w3_np1(2), u_w3_inc(2) ),                                            &
                       inc_X_minus_Y( u_w3_n(1), u_w3_inc(1) ),                                             &
                       inc_X_plus_Y( u_w3_np1(1), u_w3_inc(1) ) )

        else
          ! Assemble right-hand side for Galerkin projection into W2
          call invoke( name="perform_galerkin_projection_for_wind_inc",                       &
                       enforce_bc_kernel_type(rhs_u),                                         &
                       adj_matrix_vector_kernel_type(rhs_u, u_w3_inc(3), project_zdot_to_w2), &
                       adj_matrix_vector_kernel_type(rhs_u, u_w3_inc(2), project_ydot_to_w2), &
                       adj_matrix_vector_kernel_type(rhs_u, u_w3_inc(1), project_xdot_to_w2), &
                       setval_c(rhs_u, 0.0_r_def),                                            &
                       inc_X_minus_Y( u_w3_n(3), u_w3_inc(3) ),                               &
                       inc_X_plus_Y( u_w3_np1(3), u_w3_inc(3) ),                              &
                       inc_X_minus_Y( u_w3_n(2), u_w3_inc(2) ),                               &
                       inc_X_plus_Y( u_w3_np1(2), u_w3_inc(2) ),                              &
                       inc_X_minus_Y( u_w3_n(1), u_w3_inc(1) ),                               &
                       inc_X_plus_Y( u_w3_np1(1), u_w3_inc(1) ) )
        end if

        ! -------------------------------------------------------------------- !
        ! Transport wind components in W3
        ! -------------------------------------------------------------------- !
        do dir = 3, 1, -1
          call atl_transport_field( u_w3_np1(dir), u_w3_n(dir), ls_u_w3_n(dir), &
                                    tl_transport_controller, transport_metadata )
        end do

        ! Perturbation part
        call invoke_adj_convert_hdiv_field_kernel(u_w3_n, wind_n, chi, panel_id)

      ! ---------------------------------------------------------------------- !
      ! Default form of transport equation
      ! ---------------------------------------------------------------------- !
      case default
        call log_event('Form of wind transport equation either not compatible ' // &
                       'with wind transport or not implemented', LOG_LEVEL_ERROR)

      end select

    end if ! si_momentum_equation

    if ( LPROF ) call stop_timing( id, 'atl_wind_transport' )

  end subroutine atl_wind_transport_alg

end module atl_wind_transport_alg_mod
