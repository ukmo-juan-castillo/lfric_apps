!-----------------------------------------------------------------------------
! (c) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Contains MOL routine for consistent conservative transport equation.

module mol_consistent_alg_mod

  ! Infrastructure
  use constants_mod,                  only: r_tran, i_def, l_def
  use extrusion_mod,                  only: SHIFTED
  use fs_continuity_mod,              only: W3, Wtheta
  use function_space_mod,             only: function_space_type
  use function_space_collection_mod,  only: function_space_collection
  use log_mod,                        only: log_event, LOG_LEVEL_ERROR, &
                                            LOG_LEVEL_INFO
  use mesh_mod,                       only: mesh_type
  use mesh_collection_mod,            only: mesh_collection
  use r_tran_field_mod,               only: r_tran_field_type
  use timing_mod,                     only: start_timing, stop_timing, &
                                            tik, LPROF

  ! Algorithms and transport code
  use advective_and_flux_alg_mod,     only: advective_and_flux_alg
  use end_of_transport_step_alg_mod,  only: end_of_consistent_step_alg
  use flux_precomputations_alg_mod,   only: flux_precomputations_type
  use limited_area_lbc_alg_mod,       only: overwrite_blending_zone_rtran
  use runge_kutta_init_mod,           only: get_rk_transport_weights
  use split_transport_utils_mod,      only: get_num_split_steps, &
                                            get_splitting_direction
  use transport_controller_mod,       only: transport_controller_type
  use transport_counter_mod,          only: transport_counter_type
  use transport_metadata_mod,         only: transport_metadata_type
  use wind_precomputations_alg_mod,   only: wind_precomputations_type

  ! Kernels
  use sci_inject_wt_to_sh_w3_kernel_mod, &
                                      only: inject_wt_to_sh_w3_kernel_type

  ! Configuration
  use base_mesh_config_mod,           only: topology, topology_non_periodic
  use boundaries_config_mod,          only: limited_area, &
                                            transport_boundary_depth
  use transport_config_mod,           only: runge_kutta_method

  implicit none

  public  :: mol_consistent_alg

  contains

  !> @brief Transporting (consistent-form) of a field with the MOL scheme.
  !> @details Performs a whole time step transport, solving the consistent,
  !!          conservative transport equation for a mixing ratio field. This
  !!          involves computing the density corresponding to the mixing ratio
  !!          on a shifted mesh, but using the pre-computed dry mass flux and
  !!          the mixing ratio to build the flux for the new density field.
  !> @param[in,out] mr_np1     Mixing ratio on prime mesh at end of time step
  !> @param[in]     mr_in      Mixing ratio on prime mesh at start of this step
  !> @param[in,out] transport_controller
  !!                           Object containing metadata and precomputations
  !!                           for controlling the transport of the field
  subroutine mol_consistent_alg( mr_np1, mr_in, transport_controller )

    implicit none

    ! Arguments
    type(r_tran_field_type),         intent(inout) :: mr_np1
    type(r_tran_field_type),         intent(in)    :: mr_in
    type(transport_controller_type), intent(inout) :: transport_controller

    ! Internal variables
    integer(kind=i_def)                       :: prime_extrusion_mesh_id
    integer(kind=i_def)                       :: shifted_mesh_id
    integer(kind=i_def)                       :: mr_function_space
    integer(kind=i_def)                       :: stage, s, direction
    integer(kind=i_def)                       :: substep, transport_step
    integer(kind=i_def)                       :: step, splitting
    integer(kind=i_def)                       :: nstage_this_substep
    integer(kind=i_def)                       :: nstage, number_substeps
    logical(kind=l_def)                       :: enforce_min_value
    logical(kind=l_def)                       :: final_rk_stage
    logical(kind=l_def)                       :: final_substep
    logical(kind=l_def)                       :: final_split_step
    real(kind=r_tran)                         :: dt_mol_substep, scaling
    real(kind=r_tran),            allocatable :: rk_weights(:,:)
    type(mesh_type),                  pointer :: prime_extrusion_mesh
    type(mesh_type),                  pointer :: shifted_mesh
    type(function_space_type),        pointer :: w3_sh_fs
    type(function_space_type),        pointer :: w2_sh_fs
    type(function_space_type),        pointer :: wt_fs
    type(function_space_type),        pointer :: w3_fs
    type(function_space_type),        pointer :: w2_fs
    type(r_tran_field_type),          pointer :: prime_advecting_wind
    type(r_tran_field_type),          pointer :: dry_flux
    type(r_tran_field_type)                   :: flux_X
    type(r_tran_field_type)                   :: mr_sh_w3_for_flux, mr_for_flux
    type(r_tran_field_type)                   :: mr_n
    type(r_tran_field_type)                   :: rhs_adv, rhs_flux, rhs_field
    type(r_tran_field_type)                   :: dummy
    type(r_tran_field_type),      allocatable :: rk_field(:)
    type(transport_counter_type),     pointer :: transport_counter
    type(transport_metadata_type),    pointer :: transport_metadata
    type(wind_precomputations_type),  pointer :: wind_precomputations
    type(flux_precomputations_type),  pointer :: flux_precomputations
    integer(tik)                              :: id

    if ( LPROF ) call start_timing( id, 'transport.mol_consistent' )

    ! ------------------------------------------------------------------------ !
    ! Extract pre-existing objects and initialise temporary fields
    ! ------------------------------------------------------------------------ !

    prime_extrusion_mesh => mr_in%get_mesh()
    prime_extrusion_mesh_id = prime_extrusion_mesh%get_id()
    mr_function_space = mr_in%which_function_space()

    wind_precomputations => transport_controller%get_wind_precomputations()
    flux_precomputations => transport_controller%get_flux_precomputations()
    transport_counter => transport_controller%get_transport_counter()
    transport_metadata => transport_controller%get_transport_metadata()

    step = transport_counter%get_split_step_of_substep_counter()
    splitting = transport_metadata%get_splitting()
    transport_step = transport_counter%get_split_step_of_whole_step_counter()
    direction = get_splitting_direction(splitting, step)
    prime_advecting_wind => wind_precomputations%get_wind(                     &
        prime_extrusion_mesh_id, direction                                     &
    )

    call get_rk_transport_weights( nstage, rk_weights, runge_kutta_method )
    allocate( rk_field(nstage) )

    ! Set up variables depending on mixing ratio space
    select case ( mr_function_space )
    case ( W3 )
      ! No need for shifted mesh
      dry_flux => flux_precomputations%get_ref_flux(                           &
          prime_extrusion_mesh_id, transport_step                              &
      )
      w2_fs => dry_flux%get_function_space()
      w3_fs => mr_in%get_function_space()

      call flux_X%initialise( vector_space = w2_fs )
      call mr_n%initialise( vector_space = w3_fs )
      call mr_for_flux%initialise( vector_space = w3_fs )
      call rhs_flux%initialise( vector_space = w3_fs )
      call rhs_adv%initialise( vector_space = w3_fs )
      call rhs_field%initialise( vector_space = w3_fs )
      do stage = 1, nstage
        call rk_field(stage)%initialise( vector_space = w3_fs )
      end do

    case ( Wtheta )
      ! We need the shifted mesh
      shifted_mesh => mesh_collection%get_mesh(prime_extrusion_mesh, SHIFTED)
      shifted_mesh_id = shifted_mesh%get_id()
      wt_fs => mr_in%get_function_space()
      dry_flux => flux_precomputations%get_ref_flux(                           &
          shifted_mesh_id, transport_step                                      &
      )
      w2_sh_fs => dry_flux%get_function_space()
      w3_sh_fs => function_space_collection%get_fs(shifted_mesh, 0, 0, W3)

      call flux_X%initialise( vector_space = w2_sh_fs )
      call mr_n%initialise( vector_space = wt_fs )
      call mr_sh_w3_for_flux%initialise( vector_space = w3_sh_fs )
      call mr_for_flux%initialise( vector_space = wt_fs )
      call rhs_flux%initialise( vector_space = w3_sh_fs )
      call rhs_adv%initialise( vector_space = wt_fs )
      call rhs_field%initialise( vector_space = wt_fs )
      do stage = 1, nstage
        call rk_field(stage)%initialise( vector_space = wt_fs )
      end do

    case default
      call log_event(                                                          &
              'MoL consistent: transported variable not in appropriate space', &
              LOG_LEVEL_ERROR                                                  &
      )
    end select

    ! Set initial values of Wtheta mixing ratios
    call mr_in%copy_field_properties(mr_n)
    call mr_in%copy_field_properties(mr_np1)

    call invoke( setval_X(mr_n, mr_in),  &
                 setval_X(mr_np1, mr_in) )

    ! Get transport runtime settings
    number_substeps = wind_precomputations%get_number_mol_substeps(            &
            prime_extrusion_mesh_id, direction, splitting, step                &
    )

    dt_mol_substep = wind_precomputations%get_dt_mol_substep(                  &
            prime_extrusion_mesh_id, direction, splitting, step                &
    )
    enforce_min_value = transport_metadata%get_enforce_min_value()

    ! Initialise the mixing ratio used for the flux to zero
    call invoke( setval_c( mr_for_flux, 0.0_r_tran ) )

    final_split_step = (                                                       &
            transport_counter%get_split_step_of_substep_counter()              &
            == get_num_split_steps(transport_metadata%get_splitting())         &
    )

    ! ------------------------------------------------------------------------ !
    ! Do advective form until last stage of last substep
    ! ------------------------------------------------------------------------ !
    substep_loop: do substep = 1, number_substeps

      final_substep = ( substep == number_substeps )

      ! On the last substep of the last split step, we don't do advective form,
      ! so loop over fewer stages
      if ( final_substep .and. final_split_step ) then
        nstage_this_substep = nstage - 1
      else
        nstage_this_substep = nstage
      end if

      ! Set initial value for mr used in flux calculation
      call mr_np1%copy_field_properties(mr_n)
      call invoke( setval_X(mr_n, mr_np1), &
                   inc_X_plus_bY(mr_for_flux, rk_weights(nstage, 1), mr_n) )

      stage_loop: do stage = 1, nstage_this_substep

        final_rk_stage = ( stage == nstage )

        ! Compute the field for this stage:
        ! rhs_field = sum(s=1,stage): a(stage,s)*field^(s)
        call invoke( setval_X( rk_field(stage), mr_np1 ), &
                     setval_c( rhs_field, 0.0_r_tran ) )
        do s = 1, stage
          call invoke( inc_X_plus_bY( rhs_field, rk_weights(stage,s), rk_field(s) ) )
        end do

        ! Compute update: rhs_adv = u.grad(rhs_field)
        call advective_and_flux_alg(dummy, rhs_adv, rhs_field, mr_n,    &
                                    prime_advecting_wind, direction,    &
                                    transport_metadata, final_rk_stage, &
                                    dt_mol_substep, .false., .true.)

        ! Update field: f = f^n - dt*rhs
        call invoke( X_minus_bY(mr_np1, mr_n, dt_mol_substep, rhs_adv) )

        ! Increment mixing ratio used for flux in last step
        if ( .not. final_rk_stage ) then
          call invoke( inc_X_plus_bY(mr_for_flux, &
                                     rk_weights(nstage, stage+1), mr_np1) )
        end if

        if ( limited_area .and. topology == topology_non_periodic ) then
          ! This code is required while LAMs loop over cells right up to
          ! the edge of a limited area domain.  It can be removed if
          ! we only loop over columns in the interior domain.

          ! Don't update the field near the edge of the domain. A depth of 1 is chosen
          ! here to avoid problems right at the lateral boundary edge,
          ! but ticket #3112 will investigate further options.
          call overwrite_blending_zone_rtran(mr_np1, mr_n, depth=1)
        end if

      end do stage_loop

      ! ---------------------------------------------------------------------- !
      ! Blending zone update
      ! ---------------------------------------------------------------------- !
      if ( limited_area .and. topology == topology_non_periodic ) then
        ! This code is required while LAMs loop over cells right up to
        ! the edge of a limited area domain.  It can be removed if
        ! we only loop over columns in the interior domain.

        ! Don't update the field near the edge of the domain. A configurable depth of using
        ! the transport_boundary_depth is chosen here.  This will depend
        ! on the number of RK stages and spatial reconstruction order.
        ! Ticket #3112 will investigate further options.
        call overwrite_blending_zone_rtran(mr_np1, mr_n, depth=transport_boundary_depth)
      end if

    end do substep_loop

    ! ------------------------------------------------------------------------ !
    ! End of split step: transporting moisture density (possibly in shifted W3)
    ! ------------------------------------------------------------------------ !
    final_rk_stage = .true.

    select case (mr_function_space)

    case ( W3 )
      call invoke( setval_c(flux_X, 0.0_r_tran) )

      ! In all cases, compute flux to rho_X
      call advective_and_flux_alg(flux_X, dummy, mr_for_flux, dummy,         &
                                  dry_flux, direction, transport_metadata,   &
                                  final_rk_stage, dt_mol_substep, .true., .false.)
    case ( Wtheta )
      ! Obtain mixing ratio used for reconstruction in shifted W3
      if (enforce_min_value) then
        ! Don't interpolate to avoid generating new extrema
        call invoke( setval_X(mr_sh_w3_for_flux, mr_for_flux),         &
                     setval_c(flux_X, 0.0_r_tran) )
      else
        ! Interpolate in bottom/top layers
        call invoke( inject_wt_to_sh_w3_kernel_type(mr_sh_w3_for_flux, &
                                                    mr_for_flux),      &
                     setval_c(flux_X, 0.0_r_tran) )
      end if

      ! In all cases, compute flux to rho_X
      call advective_and_flux_alg(flux_X, dummy, mr_sh_w3_for_flux, dummy,   &
                                  dry_flux, direction, transport_metadata,   &
                                  final_rk_stage, dt_mol_substep, .true., .false.)
    end select

    ! Need to scale flux to get correct time step
    scaling = 1.0_r_tran / real(number_substeps, r_tran)
    call invoke( inc_a_times_X(scaling, flux_X) )

    ! ------------------------------------------------------------------------ !
    ! End of time step
    ! ------------------------------------------------------------------------ !

    ! If this is the final step, mr_np1 will be computed here from the fluxes
    ! over the whole transport step
    ! If this is not the final step, mr_np1 already includes the *advective*
    ! increment, and may be adjusted to enforce min value or in blending zone
    call end_of_consistent_step_alg(                                           &
            mr_np1, mr_in, flux_X, flux_precomputations,                       &
            transport_counter, transport_metadata                              &
    )

    if ( allocated( rk_field ) ) deallocate( rk_field )
    if ( allocated( rk_weights ) ) deallocate( rk_weights )

    if ( LPROF ) call stop_timing( id, 'transport.mol_consistent' )

  end subroutine mol_consistent_alg

end module mol_consistent_alg_mod
