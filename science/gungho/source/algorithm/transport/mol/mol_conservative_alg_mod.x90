!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Contains MOL routine for conservative transport of fields.

module mol_conservative_alg_mod

  ! Infrastructure
  use constants_mod,                  only: r_def, i_def, l_def, str_def, r_tran
  use log_mod,                        only: log_scratch_space, log_event, &
                                            LOG_LEVEL_INFO
  use mesh_mod,                       only: mesh_type
  use operator_mod,                   only: operator_type
  use r_tran_field_mod,               only: r_tran_field_type
  use r_tran_operator_mod,            only: r_tran_operator_type
  use timing_mod,                     only: start_timing, stop_timing, &
                                            tik, LPROF

  ! Algorithms and transport code
  use advective_and_flux_alg_mod,     only: advective_and_flux_alg
  use end_of_transport_step_alg_mod,  only: end_of_conservative_step_alg
  use flux_precomputations_alg_mod,   only: flux_precomputations_type
  use limited_area_lbc_alg_mod,       only: overwrite_blending_zone_rtran
  use runge_kutta_init_mod,           only: get_rk_transport_weights
  use split_transport_utils_mod,      only: get_num_split_steps, &
                                            get_splitting_direction
  use transport_constants_mod,        only: get_directional_im3_div_r_tran
  use transport_controller_mod,       only: transport_controller_type
  use transport_counter_mod,          only: transport_counter_type
  use transport_metadata_mod,         only: transport_metadata_type
  use transport_enumerated_types_mod, only: direction_3d, direction_h, &
                                            direction_v
  use wind_precomputations_alg_mod,   only: wind_precomputations_type

  ! Kernels
  use dg_matrix_vector_kernel_mod,    only: dg_matrix_vector_kernel_type

  ! Configuration
  use base_mesh_config_mod,           only: topology, topology_non_periodic
  use boundaries_config_mod,          only: limited_area, transport_boundary_depth
  use transport_config_mod,           only: runge_kutta_method, &
                                            dry_field_name,     &
                                            operators,          &
                                            operators_fem

  implicit none

  public  :: mol_conservative_alg

  contains

  !> @brief Transporting (conservative-form) of a field with the MOL scheme.
  !> @details Performs a whole time step transport, i.e., solving the
  !!          conservative transport equation with the Method-of-Line schemes
  !> @param[in,out] field_np1  Field at the end of the time step
  !> @param[in]     field      Field at the start of the transport step
  !> @param[in,out] transport_controller
  !!                           Object containing metadata and precomputations
  !!                           for controlling the transport of the field
  subroutine mol_conservative_alg( field_np1, field, transport_controller )

    implicit none

    ! Arguments
    type(r_tran_field_type),         intent(inout) :: field_np1
    type(r_tran_field_type),         intent(in)    :: field
    type(transport_controller_type), intent(inout) :: transport_controller

    ! Internal variables
    integer(kind=i_def)                      :: mesh_id
    integer(kind=i_def)                      :: stage, s, direction
    integer(kind=i_def)                      :: nstage, substep
    integer(kind=i_def)                      :: number_substeps
    integer(kind=i_def)                      :: step
    integer(kind=i_def)                      :: splitting
    real(kind=r_tran)                        :: dt_mol_substep
    logical(kind=l_def)                      :: final_rk_stage
    logical(kind=l_def)                      :: final_substep
    logical(kind=l_def)                      :: final_split_step
    logical(kind=l_def)                      :: do_flux
    logical(kind=l_def)                      :: do_advective
    logical(kind=l_def)                      :: enforce_min_value
    character(len=str_def)                   :: direction_code
    type(mesh_type),                 pointer :: mesh
    type(r_tran_operator_type),      pointer :: div
    type(r_tran_field_type),         pointer :: advecting_wind
    type(r_tran_field_type)                  :: rhs, field_n
    type(r_tran_field_type)                  :: flux_step, sum_flux
    type(r_tran_field_type)                  :: adv_inc
    type(r_tran_field_type)                  :: rhs_field
    type(r_tran_field_type),     allocatable :: rk_field(:)
    real(kind=r_tran),           allocatable :: rk_weights(:,:)
    type(transport_counter_type),    pointer :: transport_counter
    type(transport_metadata_type),   pointer :: transport_metadata
    type(wind_precomputations_type), pointer :: wind_precomputations
    type(flux_precomputations_type), pointer :: flux_precomputations
    integer(tik)                             :: id

    if ( LPROF ) call start_timing( id, 'transport.mol_conservective' )

    ! ------------------------------------------------------------------------ !
    ! Extract pre-existing objects and initialise temporary fields
    ! ------------------------------------------------------------------------ !

    mesh => field%get_mesh()
    mesh_id = field%get_mesh_id()

    wind_precomputations => transport_controller%get_wind_precomputations()
    flux_precomputations => transport_controller%get_flux_precomputations()
    transport_counter => transport_controller%get_transport_counter()
    transport_metadata => transport_controller%get_transport_metadata()

    step = transport_counter%get_split_step_of_substep_counter()
    splitting = transport_metadata%get_splitting()
    direction = get_splitting_direction(splitting, step)
    number_substeps = wind_precomputations%get_number_mol_substeps(            &
        mesh_id, direction, splitting, step                                    &
    )
    dt_mol_substep = wind_precomputations%get_dt_mol_substep(                  &
        mesh_id, direction, splitting, step                                    &
    )
    advecting_wind => wind_precomputations%get_wind(mesh_id, direction)

    enforce_min_value = transport_metadata%get_enforce_min_value()
    div => get_directional_im3_div_r_tran(mesh_id, direction)

    call get_rk_transport_weights(nstage, rk_weights, runge_kutta_method)
    allocate( rk_field(nstage) )

    do stage = 1,nstage
      call rk_field(stage)%initialise(field%get_function_space())
    end do

    call rhs_field%initialise( field%get_function_space() )
    call flux_step%initialise(advecting_wind%get_function_space())
    call rhs%initialise(field%get_function_space())
    call field_n%initialise(field%get_function_space())
    call adv_inc%initialise(field%get_function_space())
    call sum_flux%initialise(advecting_wind%get_function_space())

    call field%copy_field_properties(field_np1)
    call invoke( setval_X(field_np1, field), &
                 setval_c(sum_flux, 0.0_r_tran) )

    ! Get the div-term if required
    ! In this case we are solving: d(rho)/dt + div(div_factor*rho u) = 0
    ! Otherwise we are dealing with solving:  d(rho)/dt + div(rho u) = 0

    final_split_step = ( transport_counter%get_split_step_of_substep_counter() &
                         == get_num_split_steps(splitting) )
    ! ------------------------------------------------------------------------ !
    ! Start of substepping loop
    ! ------------------------------------------------------------------------ !
    substep_loop: do substep = 1, number_substeps

      final_substep = ( substep == number_substeps )

      ! Reset field_n ready for the this substep
      call field_np1%copy_field_properties(field_n)
      call invoke( setval_X(field_n, field_np1) )

      stage_loop: do stage = 1, nstage

        final_rk_stage = ( stage == nstage )

        ! Compute the field for this stage:
        ! rhs_field = sum(s=1,stage): a(stage,s)*field^(s)
        call invoke( setval_X( rk_field(stage), field_np1 ), &
                     setval_c( rhs_field, 0.0_r_tran ) )
        do s = 1, stage
          call invoke( inc_X_plus_bY( rhs_field, rk_weights(stage,s), rk_field(s) ) )
        end do

        ! -------------------------------------------------------------------- !
        ! Apply advection / flux operator depending on formulation
        ! -------------------------------------------------------------------- !

        if (.not. final_rk_stage) then
          ! Advective-then-flux form but not last stage: just advective
          do_flux = .false.
          do_advective = .true.

        else if ( (.not. final_split_step) .or. (.not. final_substep) ) then
          ! Advective-then-flux form and last stage: both advective and flux
          do_flux = .true.
          do_advective = .true.

        else
          ! Last stage of last substep for either 3D MoL or last step of split scheme
          ! Just use flux form
          do_flux = .true.
          do_advective = .false.

        end if

        call advective_and_flux_alg(flux_step, adv_inc, rhs_field, field_n, &
                                    advecting_wind, direction,              &
                                    transport_metadata, final_rk_stage,     &
                                    dt_mol_substep, do_flux, do_advective)
        if ( do_flux ) then
          ! Compute flux increment
          call invoke( dg_matrix_vector_kernel_type(rhs, flux_step, div) )
        end if
        if ( do_advective ) then
          call invoke( X_minus_bY(field_np1, field_n, dt_mol_substep, adv_inc) )
        end if

        ! -------------------------------------------------------------------- !
        ! Blending zone update
        ! -------------------------------------------------------------------- !
        if ( limited_area .and. topology == topology_non_periodic ) then
          ! This code is required while LAMs loop over cells right up to
          ! the edge of a limited area domain.  It can be removed if
          ! we only loop over columns in the interior domain.

          ! Don't update the field near the edge of the domain. A depth of 1 is chosen
          ! here to avoid problems right at the lateral boundary edge,
          ! but ticket #3112 will investigate further options.
          call overwrite_blending_zone_rtran(field_np1, field_n, depth=1)
        end if

      end do stage_loop

      ! Increment the total flux by the substep flux
      call invoke( inc_X_plus_bY(sum_flux, dt_mol_substep, flux_step))

      ! ---------------------------------------------------------------------- !
      ! Blending zone update
      ! ---------------------------------------------------------------------- !
      if ( limited_area .and. topology == topology_non_periodic ) then
        ! This code is required while LAMs loop over cells right up to
        ! the edge of a limited area domain.  It can be removed if
        ! we only loop over columns in the interior domain.

        ! Don't update the field near the edge of the domain. A configurable depth of using
        ! the transport_boundary_depth is chosen here.  This will depend
        ! on the number of RK stages and spatial reconstruction order.
        ! Ticket #3112 will investigate further options.
        call overwrite_blending_zone_rtran(field_np1, field_n, depth=transport_boundary_depth)
      end if
    end do substep_loop

    ! ------------------------------------------------------------------------ !
    ! End of step
    ! ------------------------------------------------------------------------ !

    ! If this is the final step, field_np1 will be computed here from the fluxes
    ! over the whole transport step
    ! If this is not the final step, field_np1 already includes the *advective*
    ! increment, and may be adjusted to enforce min value or in blending zone
    call end_of_conservative_step_alg(                                         &
            field_np1, field, sum_flux,                                        &
            flux_precomputations, transport_counter, transport_metadata        &
    )

    if (trim(transport_metadata%get_name()) == trim(dry_field_name)) then
      ! Print number of substeps to log here
      select case (direction)
        case (direction_3d)
          direction_code = '3D'
        case (direction_h)
          direction_code = 'horizontal'
        case (direction_v)
          direction_code = 'vertical'
      end select
      write( log_scratch_space, '(A,I4)' )                &
      'Transport: number of MoL substeps in ' //          &
      trim(adjustl(direction_code)) // ' direction = ', number_substeps
      call log_event(log_scratch_space, LOG_LEVEL_INFO)
    end if

    if ( allocated(rk_field) ) deallocate(rk_field)
    if ( allocated(rk_weights) ) deallocate(rk_weights)

    if ( LPROF ) call stop_timing( id, 'transport.mol_conservective' )

  end subroutine mol_conservative_alg

end module mol_conservative_alg_mod
