!-----------------------------------------------------------------------------
! (C) Crown copyright 2023 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Routine for controlling transport of the potential temperature field.

module theta_transport_alg_mod

  use constants_mod,                  only: i_def, r_def
  use field_mod,                      only: field_type
  use fs_continuity_mod,              only: Wtheta
  use function_space_mod,             only: function_space_type
  use sci_geometric_constants_mod,    only: get_height_fe, &
                                            get_height_fv
  use log_mod,                        only: log_event, LOG_LEVEL_ERROR
  use mr_indices_mod,                 only: nummr, imr_v
  use planet_config_mod,              only: recip_epsilon
  use sci_sort_column_above_kernel_mod, &
                                      only: sort_column_above_kernel_type
  use transport_config_mod,           only: theta_variable,                    &
                                            theta_variable_dry,                &
                                            theta_variable_virtual_dry,        &
                                            adjust_theta,                      &
                                            adjust_theta_above
  use transport_controller_mod,       only: transport_controller_type
  use transport_enumerated_types_mod, only: equation_form_advective,           &
                                            equation_form_conservative,        &
                                            equation_form_consistent
  use transport_field_mod,            only: transport_field
  use transport_metadata_mod,         only: transport_metadata_type
  use transport_rho_times_field_alg_mod,    &
                                      only: transport_rho_times_field_alg

  implicit none

  private

  public :: theta_transport_alg

contains

  !> @brief Central routine for transporting potential temperature field.
  !> @details Performs a whole transport time step for potential temperature,
  !!          with different routines called depending on the specified options
  !!          for transporting the potential temperature. The potential
  !!          temperature variable to be transported will be obtained, and if
  !!          the transport equation is conservative then this is the product
  !!          of a potential temperature with dry density on the shifted mesh.
  !!          Static adjustment may also be applied to the resulting profile.
  !!          The potential temperature increment is returned.
  !> @param[in,out] theta_out_rdef    Dry potential temperature after transport
  !> @param[in,out] theta_inc_rdef    Dry potential temperature increment
  !> @param[in]     theta_in_rdef     Dry potential temperature before transport
  !> @param[in]     mr_out            Moisture mixing ratios after transport
  !> @param[in]     mr_in             Moisture mixing ratios before transport
  !> @param[in,out] transport_controller
  !!                                  Encapsulating object containing the
  !!                                  transport counter and precomputations
  !> @param[in,out] transport_metadata
  !!                                  Contains the configuration options for
  !!                                  transporting these fields
  subroutine theta_transport_alg(theta_out_rdef, theta_inc_rdef,               &
                                 theta_in_rdef, mr_out, mr_in,                 &
                                 transport_controller, transport_metadata)

    implicit none

    ! Arguments
    type(field_type),        target, intent(inout) :: theta_out_rdef
    type(field_type),                intent(inout) :: theta_inc_rdef
    type(field_type),        target, intent(in)    :: theta_in_rdef
    type(field_type),                intent(in)    :: mr_out(nummr)
    type(field_type),                intent(in)    :: mr_in(nummr)
    type(transport_controller_type), intent(inout) :: transport_controller
    type(transport_metadata_type),   intent(inout) :: transport_metadata

    ! Internal variables
    real(kind=r_def)                   :: one
    type(field_type),          pointer :: theta_in_ptr
    type(field_type),          pointer :: theta_out_ptr
    type(field_type),           target :: theta_vd_in, theta_vd_out
    type(field_type)                   :: moist_factor_in, moist_factor_out
    type(field_type),          pointer :: height_wt
    type(function_space_type), pointer :: wt_fs
    integer(kind=i_def)                :: equation_form

    ! ------------------------------------------------------------------------ !
    ! Convert to the particular potential temperature to be transported
    ! ------------------------------------------------------------------------ !
    ! Here we set the pointers theta_in_ptr and theta_out_ptr, which will point
    ! to the appropriate field objects to be transported (which may be theta or
    ! theta_vd, etc.) This avoids additional computations and code duplication,
    ! as whichever theta variable and eqn form that we use, we will transport
    ! theta_in_ptr to get theta_out_ptr
    select case ( theta_variable )

      case ( theta_variable_dry )
        ! Already have the correct variable, so just point to it
        ! This means that when theta_out_ptr is updated, so will theta_out_rdef
        theta_in_ptr => theta_in_rdef
        theta_out_ptr => theta_out_rdef

      case ( theta_variable_virtual_dry )
        ! Compute theta_vd
        one = 1.0_r_def
        wt_fs => theta_in_rdef%get_function_space()
        call moist_factor_in%initialise( wt_fs )
        call moist_factor_out%initialise( wt_fs )
        call theta_vd_out%initialise( wt_fs )
        call theta_vd_in%initialise( wt_fs )

        call invoke( a_times_X(moist_factor_in, recip_epsilon, mr_in(imr_v)),  &
                     a_times_X(moist_factor_out, recip_epsilon,                &
                               mr_out(imr_v)),                                 &
                     inc_a_plus_X(one, moist_factor_in),                       &
                     inc_a_plus_X(one, moist_factor_out),                      &
                     X_times_Y(theta_vd_in, theta_in_rdef, moist_factor_in) )

        ! When theta_out_ptr is updated, so will theta_vd_out
        theta_in_ptr => theta_vd_in
        theta_out_ptr => theta_vd_out

        nullify( wt_fs )

      case default
        call log_event('Theta variable not implemented', LOG_LEVEL_ERROR)

    end select

    ! If performing advective transport in the first outer loop, then the
    ! transport metadata needs setting here to make that choice
    ! The transport metadata will then be reset correctly within transport_field
    call transport_controller%before_transport_field(transport_metadata)
    equation_form = transport_metadata%get_equation_form()

    ! ------------------------------------------------------------------------ !
    ! Transport depending on equation
    ! If the equation form is advective:
    !           Simply transport field in native space
    ! If the equation form is consistent:
    !           Requires transformation to densities and evaluation of fluxes.
    !           This is done in the lowest level algorithms, so can just call
    !           transport_field.
    ! If the equation form is conservative:
    !           This also requires transformation to densities and evaluation
    !           of fluxes, but is achieved using the transport_rho_times_field
    !           algorithm (this also divides the result by density at the end
    !           of the transport step and so returns an updated field.)
    ! ------------------------------------------------------------------------ !
    select case ( equation_form )

      ! ---------------------------------------------------------------------- !
      ! Advective and consistent forms of transport equation
      ! ---------------------------------------------------------------------- !
      case ( equation_form_advective, equation_form_consistent )

        call transport_field(                                                  &
                theta_out_ptr, theta_in_ptr, transport_controller,             &
                transport_metadata                                             &
        )

      ! ---------------------------------------------------------------------- !
      ! Conservative form of transport equation
      ! ---------------------------------------------------------------------- !
      case ( equation_form_conservative )

        call transport_rho_times_field_alg(                                    &
                theta_out_ptr, theta_in_ptr, transport_controller,             &
                transport_metadata                                             &
        )

    ! ------------------------------------------------------------------------ !
    ! Default form of transport equation
    ! ------------------------------------------------------------------------ !
    case default
      call log_event(                                                          &
              'Form of theta transport equation either not ' //                &
              'compatible or not implemented',                                 &
              LOG_LEVEL_ERROR                                                  &
      )

    end select

    ! ------------------------------------------------------------------------ !
    ! Return to dry theta
    ! ------------------------------------------------------------------------ !

    select case ( theta_variable )

      case ( theta_variable_dry )
        ! theta_out_rdef already contains the correct field values as it was
        ! pointed to by theta_out_ptr
        ! Nothing to do -- can't "pass" in Fortran so just set a dummy variable
        one = 1.0_r_def

      case ( theta_variable_virtual_dry )
        ! Compute theta from theta_vd
        call invoke( X_divideby_Y(theta_out_rdef, theta_vd_out,                &
                                  moist_factor_out) )

      case default
        call log_event('Theta variable not implemented', LOG_LEVEL_ERROR)

    end select

    ! ------------------------------------------------------------------------ !
    ! Apply static adjustment if desired
    ! ------------------------------------------------------------------------ !

    if ( adjust_theta ) then
      if (theta_in_rdef%get_element_order_h() == 0 .and. &
          theta_in_rdef%get_element_order_v() == 0) then
        ! Use the finite volume height function
        height_wt => get_height_fv(Wtheta, theta_in_rdef%get_mesh_id())
      else
        ! Use the finite element height function
        height_wt => get_height_fe(Wtheta, theta_in_rdef%get_mesh_id())
      end if
      call invoke( sort_column_above_kernel_type(theta_out_rdef, height_wt,    &
                                                 adjust_theta_above) )
    end if

    ! ------------------------------------------------------------------------ !
    ! Compute increment
    ! ------------------------------------------------------------------------ !

    call invoke( X_minus_Y(theta_inc_rdef, theta_out_rdef, theta_in_rdef) )

  end subroutine theta_transport_alg

end module theta_transport_alg_mod
