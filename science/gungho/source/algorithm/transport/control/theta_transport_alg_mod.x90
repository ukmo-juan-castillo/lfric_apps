!-----------------------------------------------------------------------------
! (C) Crown copyright 2023 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Routine for controlling transport of the potential temperature field.

module theta_transport_alg_mod

  use constants_mod,                  only: i_def, r_def, l_def
  use copy_field_alg_mod,             only: copy_field
  use dg_inc_matrix_vector_kernel_mod, &
                                      only: dg_inc_matrix_vector_kernel_type
  use dry_to_moist_theta_kernel_mod,  only: dry_to_moist_theta_kernel_type
  use sci_enforce_lower_bound_kernel_mod,                                      &
                                      only: enforce_lower_bound_kernel_type
  use extrusion_mod,                  only: SHIFTED
  use field_mod,                      only: field_type
  use finite_element_config_mod,      only: element_order_h, element_order_v
  use flux_precomputations_alg_mod,   only: flux_precomputations_type
  use formulation_config_mod,         only: theta_moist_source
  use fs_continuity_mod,              only: Wtheta, W2
  use function_space_mod,             only: function_space_type
  use function_space_collection_mod,  only: function_space_collection
  use fv_divergence_3d_kernel_mod,    only: fv_divergence_3d_kernel_type
  use sci_geometric_constants_mod,    only: get_height_fv, get_height_fe
  use log_mod,                        only: log_event, LOG_LEVEL_ERROR
  use map_w2_to_sh_w2_alg_mod,        only: map_w2_to_sh_w2_alg
  use mesh_mod,                       only: mesh_type
  use mesh_collection_mod,            only: mesh_collection
  use moist_to_dry_theta_kernel_mod,  only: moist_to_dry_theta_kernel_type
  use mr_indices_mod,                 only: nummr, imr_v, imr_cl, imr_r,       &
                                            imr_ci, imr_s, imr_g
  use operator_mod,                   only: operator_type
  use physics_mappings_alg_mod,       only: map_physics_scalars
  use planet_config_mod,              only: recip_epsilon, cp, Rd, p_zero
  use r_tran_field_mod,               only: r_tran_field_type
  use sci_sort_column_above_kernel_mod, &
                                      only: sort_column_above_kernel_type
  use split_transport_utils_mod,      only: use_shifted_mesh,                  &
                                            get_num_split_steps,               &
                                            get_dry_config
  use theta_moist_source_kernel_mod,  only: theta_moist_source_kernel_type
  use timestepping_config_mod,        only: time_method => method,             &
                                            method_semi_implicit
  use transport_config_mod,           only: theta_variable,                    &
                                            theta_variable_dry,                &
                                            theta_variable_virtual_dry,        &
                                            theta_variable_moist,              &
                                            adjust_theta,                      &
                                            adjust_theta_above,                &
                                            splitting
  use transport_constants_mod,        only: get_detj_at_w3_r_tran
  use transport_controller_mod,       only: transport_controller_type
  use transport_counter_mod,          only: transport_counter_type
  use transport_enumerated_types_mod, only: equation_form_advective,           &
                                            equation_form_conservative,        &
                                            equation_form_consistent
  use transport_field_mod,            only: transport_field
  use transport_metadata_mod,         only: transport_metadata_type
  use transport_rho_times_field_alg_mod,                                       &
                                      only: transport_rho_times_field_alg
  use transport_enumerated_types_mod, only: direction_3d

  implicit none

  private

  public :: theta_transport_alg

contains

  !> @brief Central routine for transporting potential temperature field.
  !> @details Performs a whole transport time step for potential temperature,
  !!          with different routines called depending on the specified options
  !!          for transporting the potential temperature. The potential
  !!          temperature variable to be transported will be obtained, and if
  !!          the transport equation is conservative then this is the product
  !!          of a potential temperature with dry density on the shifted mesh.
  !!          Static adjustment may also be applied to the resulting profile.
  !!          The potential temperature increment is returned.
  !> @param[in,out] theta_out_rdef    Dry potential temperature after transport
  !> @param[in,out] theta_inc_rdef    Dry potential temperature increment
  !> @param[in]     theta_in_rdef     Dry potential temperature before transport
  !> @param[in]     mr_out            Moisture mixing ratios after transport
  !> @param[in]     mr_in             Moisture mixing ratios before transport
  !> @param[in,out] transport_controller
  !!                                  Encapsulating object containing the
  !!                                  transport counter and precomputations
  !> @param[in,out] transport_metadata
  !!                                  Contains the configuration options for
  !!                                  transporting these fields
  subroutine theta_transport_alg(theta_out_rdef, theta_inc_rdef,               &
                                 theta_in_rdef, mr_out, mr_in,                 &
                                 transport_controller, transport_metadata)

    implicit none

    ! Arguments
    type(field_type),        target, intent(inout) :: theta_out_rdef
    type(field_type),                intent(inout) :: theta_inc_rdef
    type(field_type),        target, intent(in)    :: theta_in_rdef
    type(field_type),                intent(in)    :: mr_out(nummr)
    type(field_type),                intent(in)    :: mr_in(nummr)
    type(transport_controller_type), intent(inout) :: transport_controller
    type(transport_metadata_type),   intent(inout) :: transport_metadata

    ! Internal variables
    real(kind=r_def)                         :: one, dt
    integer(kind=i_def)                      :: num_dry_steps
    type(field_type),                pointer :: theta_in_ptr
    type(field_type),                pointer :: theta_out_ptr
    type(field_type),                 target :: theta_vd_in, theta_vd_out
    type(field_type),                 target :: theta_m_in, theta_m_out
    type(field_type)                         :: moist_factor_in, moist_factor_out
    type(r_tran_field_type),         pointer :: rho_in_rtran, rho_out_rtran
    type(field_type)                         :: rho_in_w3, rho_out_w3
    type(field_type)                         :: rho_in_wt, rho_out_wt
    type(field_type),                pointer :: height_wt
    type(function_space_type),       pointer :: wt_fs, w3_fs, w2_sh_fs
    integer(kind=i_def)                      :: equation_form
    type(r_tran_field_type),         pointer :: wind
    type(r_tran_field_type)                  :: wind_shifted
    type(flux_precomputations_type), pointer :: flux_precomputations
    type(mesh_type),                 pointer :: mesh, shifted_mesh
    type(r_tran_field_type),         pointer :: detj_at_w3
    type(transport_counter_type),    pointer :: counter
    type(r_tran_field_type)                  :: div_u_rtran
    type(field_type)                         :: div_u

    ! ------------------------------------------------------------------------ !
    ! Convert to the particular potential temperature to be transported
    ! ------------------------------------------------------------------------ !
    ! Here we set the pointers theta_in_ptr and theta_out_ptr, which will point
    ! to the appropriate field objects to be transported (which may be theta or
    ! theta_vd, etc.) This avoids additional computations and code duplication,
    ! as whichever theta variable and eqn form that we use, we will transport
    ! theta_in_ptr to get theta_out_ptr
    select case ( theta_variable )

      case ( theta_variable_dry )
        ! Already have the correct variable, so just point to it
        ! This means that when theta_out_ptr is updated, so will theta_out_rdef
        theta_in_ptr => theta_in_rdef
        theta_out_ptr => theta_out_rdef

      case ( theta_variable_virtual_dry )
        ! Compute theta_vd
        one = 1.0_r_def
        wt_fs => theta_in_rdef%get_function_space()
        call moist_factor_in%initialise( wt_fs )
        call moist_factor_out%initialise( wt_fs )
        call theta_vd_out%initialise( wt_fs )
        call theta_vd_in%initialise( wt_fs )

        call invoke( a_times_X(moist_factor_in, recip_epsilon, mr_in(imr_v)),  &
                     a_times_X(moist_factor_out, recip_epsilon,                &
                               mr_out(imr_v)),                                 &
                     inc_a_plus_X(one, moist_factor_in),                       &
                     inc_a_plus_X(one, moist_factor_out),                      &
                     X_times_Y(theta_vd_in, theta_in_rdef, moist_factor_in) )

        ! When theta_out_ptr is updated, so will theta_vd_out
        theta_in_ptr => theta_vd_in
        theta_out_ptr => theta_vd_out

        nullify( wt_fs )

      case ( theta_variable_moist )
        ! Moist potential temperature, with different kappa
        mesh => theta_in_rdef%get_mesh()
        wt_fs => theta_in_rdef%get_function_space()
        flux_precomputations => transport_controller%get_flux_precomputations()
        counter => transport_controller%get_transport_counter()
        num_dry_steps = (                                                      &
            get_num_split_steps(splitting(get_dry_config()))                   &
            * counter%get_num_substeps()                                       &
        )
        ! Obtain densities in Wtheta
        rho_in_rtran => flux_precomputations%get_ref_field(mesh%get_id(), 1)
        rho_out_rtran => flux_precomputations%get_ref_field(                   &
            mesh%get_id(), num_dry_steps + 1                                   &
        )
        w3_fs => rho_in_rtran%get_function_space()
        call rho_in_w3%initialise( w3_fs )
        call rho_out_w3%initialise( w3_fs )
        call rho_in_wt%initialise( wt_fs )
        call rho_out_wt%initialise( wt_fs )
        call copy_field(rho_in_rtran, rho_in_w3)
        call copy_field(rho_out_rtran, rho_out_w3)
        call map_physics_scalars(rho_in_wt, rho_in_w3)
        call map_physics_scalars(rho_out_wt, rho_out_w3)

        call theta_m_in%initialise( wt_fs )
        call theta_m_out%initialise( wt_fs )

        call invoke( dry_to_moist_theta_kernel_type(theta_m_in,                &
                                                    theta_in_rdef,             &
                                                    rho_in_wt,                 &
                                                    mr_in(imr_v),              &
                                                    mr_in(imr_cl),             &
                                                    mr_in(imr_r),              &
                                                    mr_in(imr_ci),             &
                                                    mr_in(imr_s),              &
                                                    mr_in(imr_g),              &
                                                    cp, Rd, p_zero) )
        theta_in_ptr => theta_m_in
        theta_out_ptr => theta_m_out

      case default
        call log_event('Theta variable not implemented', LOG_LEVEL_ERROR)

    end select

    ! If performing advective transport in the first outer loop, then the
    ! transport metadata needs setting here to make that choice
    ! The transport metadata will then be reset correctly within transport_field
    call transport_controller%before_transport_field(transport_metadata)
    equation_form = transport_metadata%get_equation_form()

    ! ------------------------------------------------------------------------ !
    ! Transport depending on equation
    ! If the equation form is advective:
    !           Simply transport field in native space
    ! If the equation form is consistent:
    !           Requires transformation to densities and evaluation of fluxes.
    !           This is done in the lowest level algorithms, so can just call
    !           transport_field.
    ! If the equation form is conservative:
    !           This also requires transformation to densities and evaluation
    !           of fluxes, but is achieved using the transport_rho_times_field
    !           algorithm (this also divides the result by density at the end
    !           of the transport step and so returns an updated field.)
    ! ------------------------------------------------------------------------ !
    select case ( equation_form )

      ! ---------------------------------------------------------------------- !
      ! Advective and consistent forms of transport equation
      ! ---------------------------------------------------------------------- !
      case ( equation_form_advective, equation_form_consistent )

        call transport_field(                                                  &
                theta_out_ptr, theta_in_ptr, transport_controller,             &
                transport_metadata                                             &
        )

      ! ---------------------------------------------------------------------- !
      ! Conservative form of transport equation
      ! ---------------------------------------------------------------------- !
      case ( equation_form_conservative )

        call transport_rho_times_field_alg(                                    &
                theta_out_ptr, theta_in_ptr, transport_controller,             &
                transport_metadata                                             &
        )

    ! ------------------------------------------------------------------------ !
    ! Default form of transport equation
    ! ------------------------------------------------------------------------ !
    case default
      call log_event(                                                          &
              'Form of theta transport equation either not ' //                &
              'compatible or not implemented',                                 &
              LOG_LEVEL_ERROR                                                  &
      )

    end select

    ! ------------------------------------------------------------------------ !
    ! Return to dry theta
    ! ------------------------------------------------------------------------ !

    select case ( theta_variable )

      case ( theta_variable_dry )
        ! theta_out_rdef already contains the correct field values as it was
        ! pointed to by theta_out_ptr
        ! Nothing to do -- can't "pass" in Fortran so just set a dummy variable
        one = 1.0_r_def

      case ( theta_variable_virtual_dry )
        ! Compute theta from theta_vd
        call invoke( X_divideby_Y(theta_out_rdef, theta_vd_out,                &
                                  moist_factor_out) )

      case ( theta_variable_moist )
        call invoke( moist_to_dry_theta_kernel_type(theta_out_rdef,            &
                                                    theta_m_out,               &
                                                    rho_out_wt,                &
                                                    mr_out(imr_v),             &
                                                    mr_out(imr_cl),            &
                                                    mr_out(imr_r),             &
                                                    mr_out(imr_ci),            &
                                                    mr_out(imr_s),             &
                                                    mr_out(imr_g),             &
                                                    cp, Rd, p_zero) )

      case default
        call log_event('Theta variable not implemented', LOG_LEVEL_ERROR)

    end select

    ! ------------------------------------------------------------------------ !
    ! Apply moisture source term if desired
    ! ------------------------------------------------------------------------ !

    if (use_shifted_mesh() .and. theta_moist_source                            &
        .and. .not. theta_variable == theta_variable_moist ) then
      mesh => theta_out_rdef%get_mesh()
      shifted_mesh => mesh_collection%get_mesh(mesh, SHIFTED)

      if (element_order_h > 0 .or. element_order_v > 0) then
        call log_event(                                                        &
                'Moist source term for theta not implemented for ' //          &
                'higher-order elements', LOG_LEVEL_ERROR                       &
        )
      end if

      ! Get wind on shifted mesh
      w2_sh_fs => function_space_collection%get_fs(shifted_mesh, 0, 0, W2)
      wind => transport_controller%get_transporting_wind()
      call wind_shifted%initialise( w2_sh_fs )
      call map_w2_to_sh_w2_alg(wind_shifted, wind)

      ! Get divergence on shifted mesh
      detj_at_w3 => get_detj_at_w3_r_tran(shifted_mesh%get_id())
      call div_u_rtran%initialise( detj_at_w3%get_function_space() )
      call invoke( fv_divergence_3d_kernel_type(div_u_rtran,                   &
                                                wind_shifted, detj_at_w3) )

      ! Convert divergence to rdef precision
      call div_u%initialise( detj_at_w3%get_function_space() )
      call copy_field(div_u_rtran, div_u)

      counter => transport_controller%get_transport_counter()
      dt = real(counter%get_dt_substep() * counter%get_num_substeps(), r_def)

      call invoke( theta_moist_source_kernel_type(theta_out_rdef, div_u,       &
                                                  mr_out(imr_v),               &
                                                  mr_out(imr_cl),              &
                                                  mr_out(imr_r),               &
                                                  mr_out(imr_ci),              &
                                                  mr_out(imr_s),               &
                                                  mr_out(imr_g),               &
                                                  dt, cp, Rd) )
    end if

    ! ------------------------------------------------------------------------ !
    ! Apply static adjustment if desired
    ! ------------------------------------------------------------------------ !

    if ( adjust_theta ) then
      if (theta_in_rdef%get_element_order_h() == 0 .and. &
          theta_in_rdef%get_element_order_v() == 0) then
        ! Use the finite volume height function
        height_wt => get_height_fv(Wtheta, theta_in_rdef%get_mesh_id())
      else
        ! Use the finite element height function
        height_wt => get_height_fe(Wtheta, theta_in_rdef%get_mesh_id())
      end if
      call invoke( sort_column_above_kernel_type(theta_out_rdef, height_wt,    &
                                                 adjust_theta_above) )
    end if

    ! ------------------------------------------------------------------------ !
    ! Compute increment
    ! ------------------------------------------------------------------------ !

    call invoke( X_minus_Y(theta_inc_rdef, theta_out_rdef, theta_in_rdef) )

  end subroutine theta_transport_alg

end module theta_transport_alg_mod
