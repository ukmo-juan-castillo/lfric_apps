!-----------------------------------------------------------------------------
! (C) Crown copyright 2023 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Common routines for computing transport increments at the end of
!!        the transport step.

module end_of_transport_step_alg_mod

  use base_mesh_config_mod,           only: topology, topology_non_periodic
  use boundaries_config_mod,          only: limited_area, transport_boundary_depth
  use check_configuration_mod,        only: check_any_eqn_consistent
  use conservative_neg_fix_kernel_mod, &
                                      only: conservative_neg_fix_kernel_type
  use constants_mod,                  only: i_def, r_tran, l_def, r_def
  use sci_enforce_lower_bound_kernel_mod, &
                                      only: enforce_lower_bound_kernel_type
  use extrusion_mod,                  only: SHIFTED
  use fem_constants_mod,              only: get_directional_im3_div_r_tran, &
                                            get_directional_im3_div,        &
                                            get_rmultiplicity,              &
                                            get_detj_at_w3_r_tran
  use field_mod,                      only: field_type
  use sci_field_minmax_alg_mod,       only: log_field_minmax
  use finite_element_config_mod,      only: element_order
  use fs_continuity_mod,              only: W3, Wtheta, W2, W2H, W2V
  use function_space_mod,             only: function_space_type
  use function_space_collection_mod,  only: function_space_collection
  use fv_divergence_2d_kernel_mod,    only: fv_divergence_2d_kernel_type
  use fv_divergence_3d_kernel_mod,    only: fv_divergence_3d_kernel_type
  use fv_divergence_x_kernel_mod,     only: fv_divergence_x_kernel_type
  use fv_divergence_y_kernel_mod,     only: fv_divergence_y_kernel_type
  use fv_divergence_z_kernel_mod,     only: fv_divergence_z_kernel_type
  use geometric_constants_mod,        only: get_height,           &
                                            get_face_selector_ew, &
                                            get_face_selector_ns
  use integer_field_mod,              only: integer_field_type
  use iterate_min_flux_kernel_mod,    only: iterate_min_flux_kernel_type
  use io_config_mod,                  only: subroutine_timers
  use limited_area_lbc_alg_mod,       only: overwrite_blending_zone_rtran
  use log_mod,                        only: log_event,          &
                                            log_scratch_space,  &
                                            LOG_LEVEL_DEBUG,    &
                                            LOG_LEVEL_INFO,     &
                                            LOG_LEVEL_ERROR

  use mesh_mod,                       only: mesh_type
  use mesh_collection_mod,            only: mesh_collection
  use operator_mod,                   only: operator_type
  use r_tran_field_mod,               only: r_tran_field_type
  use r_tran_operator_mod,            only: r_tran_operator_type
  use timer_mod,                      only: timer
  use transport_config_mod,           only: dry_field_name,              &
                                            min_val_abs_tol,             &
                                            min_val_max_iterations,      &
                                            min_val_method,              &
                                            min_val_method_iterative,    &
                                            min_val_method_clipping,     &
                                            theta_dispersion_correction, &
                                            operators,                   &
                                            operators_fem
  use transport_enumerated_types_mod, only: direction_3d,   &
                                            direction_h,    &
                                            direction_v,    &
                                            splitting_none, &
                                            splitting_strang_vhv
  use transport_metadata_mod,         only: transport_metadata_type
  use transport_runtime_alg_mod,      only: transport_runtime_type
  use transport_runtime_collection_mod, &
                                      only: get_transport_runtime
  use sci_field_minmax_alg_mod,       only: get_field_minmax
  use dg_matrix_vector_kernel_mod,    only: dg_matrix_vector_kernel_type

  implicit none

  private

  public  :: end_of_advective_step_alg
  public  :: end_of_conservative_step_alg
  public  :: end_of_consistent_step_alg
  public  :: build_up_flux

contains

  !> @brief Common end-of-step code for advective transport schemes
  !> @details Performs common routines at the end of transport steps (which may
  !!          be the end of various split steps in a split horizontal-vertical
  !!          scheme). These routines are:
  !!          - overwriting field data in the blending zone, if necessary
  !!          - enforcing a minimum value for the field, if necessary
  !> @param[in,out] field_np1          Field at the end of the transport step
  !!                                   to be computed.
  !> @param[in]     field_in           Field at the beginning of this transport
  !!                                   step.
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting the field
  subroutine end_of_advective_step_alg(field_np1, field_in, transport_metadata)

    implicit none

    ! Arguments
    type(r_tran_field_type),       intent(inout) :: field_np1
    type(r_tran_field_type),       intent(in)    :: field_in
    type(transport_metadata_type), intent(in)    :: transport_metadata

    ! Internal variables
    real(kind=r_tran)                     :: min_value
    logical(kind=l_def)                   :: final_split_step
    type(transport_runtime_type), pointer :: transport_runtime => null()
    type(mesh_type),              pointer :: mesh => null()

    if ( subroutine_timers ) call timer('transport.end_of_transport')

    mesh => field_np1%get_mesh()
    transport_runtime => get_transport_runtime(mesh)

    ! Determine whether this is the final split step
    final_split_step = ( transport_runtime%get_tracer_step_ctr() &
                         == transport_runtime%get_num_dry_steps() )

    ! Enforce a min value if required
    if ( final_split_step .and. transport_metadata%get_enforce_min_value() ) then
       min_value = transport_metadata%get_min_value()
       call invoke( inc_max_aX(min_value, field_np1) )
    end if

    ! At the end do the overwrite step for the blending zone
    if ( limited_area .and. topology == topology_non_periodic ) then
      ! This code is required while LAMs loop over cells right up to
      ! the edge of a limited area domain.  It can be removed if
      ! we only loop over columns in the interior domain.

      ! Don't update the field near the edge of the domain. A configurable depth of using
      ! the transport_boundary_depth is chosen here.  This will depend
      ! on the number of RK stages and spatial reconstruction order.
      ! Ticket #3112 will investigate further options.
      call overwrite_blending_zone_rtran(field_np1, field_in, &
                                         depth=transport_boundary_depth)
    end if

    call log_field_minmax( LOG_LEVEL_DEBUG, 'field_np1: end_of_advective_step', field_np1)

    if ( subroutine_timers ) call timer('transport.end_of_transport')

  end subroutine end_of_advective_step_alg

  !> @brief Common end-of-step code for conservative transport schemes
  !> @details Performs common routines at the end of transport steps (which may
  !!          be the end of various split steps in a split horizontal-vertical
  !!          scheme). These routines are:
  !!          - overwriting field data in the blending zone, if necessary
  !!          - enforcing a minimum value for the field, if necessary
  !!          - saving any fields (such as mass fluxes) that may be used later
  !> @param[in,out] field_np1          Field at the end of the transport step
  !!                                   to be computed.
  !> @param[in]     field_in           Field at the beginning of this transport
  !!                                   step, which may be saved in the transport
  !!                                   runtime object if this field is the "dry
  !!                                   field".
  !> @param[in]     flux               The mass flux for this transport step.
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting the field
  subroutine end_of_conservative_step_alg(field_np1, field_in, flux, &
                                          transport_metadata)

    implicit none

    ! Arguments
    type(r_tran_field_type),       intent(inout) :: field_np1
    type(r_tran_field_type),       intent(in)    :: field_in
    type(r_tran_field_type),       intent(in)    :: flux
    type(transport_metadata_type), intent(in)    :: transport_metadata

    ! Internal variables
    integer(kind=i_def)                   :: mesh_id, step, fs_idx
    integer(kind=i_def)                   :: limit_iteration
    integer(kind=i_def)                   :: num_limiting_steps
    type(mesh_type),              pointer :: mesh
    type(r_tran_field_type)               :: increment
    type(r_tran_field_type)               :: increment_x
    type(r_tran_field_type)               :: increment_y
    type(r_tran_field_type)               :: sum_flux
    type(r_tran_field_type)               :: conservative_field_np1
    type(r_tran_field_type)               :: conservative_field_x
    type(r_tran_field_type)               :: conservative_field_y
    type(r_tran_field_type),      pointer :: conservative_field_n
    type(r_tran_field_type),      pointer :: detj_at_w3
    type(r_tran_field_type),      pointer :: field_start
    type(r_tran_operator_type),   pointer :: div
    type(operator_type),          pointer :: div_r_def
    type(transport_runtime_type), pointer :: transport_runtime
    type(function_space_type),    pointer :: w2_fs
    type(function_space_type),    pointer :: field_fs
    logical(kind=l_def)                   :: enforce_min_value
    logical(kind=l_def)                   :: final_split_step
    logical(kind=l_def)                   :: is_dry_field
    real(kind=r_tran)                     :: min_value
    real(kind=r_tran)                     :: adv_dt
    real(kind=r_tran)                     :: acceptable_min
    real(kind=r_tran)                     :: field_min, field_max
    integer(kind=i_def)                   :: direction

    if ( subroutine_timers ) call timer('transport.end_of_transport')

    ! Extract transport runtime
    mesh => field_np1%get_mesh()
    transport_runtime => get_transport_runtime(mesh)
    mesh_id = mesh%get_id()
    enforce_min_value = transport_metadata%get_enforce_min_value()
    is_dry_field = (trim(transport_metadata%get_name()) == trim(dry_field_name))
    detj_at_w3 => get_detj_at_w3_r_tran(mesh_id)

    ! Determine whether this is the final split step
    final_split_step = ( transport_runtime%get_tracer_step_ctr() &
                         == transport_runtime%get_num_dry_steps() )

    if (.not. final_split_step) call transport_runtime%set_flux(flux)

    ! ------------------------------------------------------------------------ !
    ! Compute increment from all split steps
    ! ------------------------------------------------------------------------ !

    if ( final_split_step ) then

      field_start => transport_runtime%get_field_n()
      w2_fs => function_space_collection%get_fs(mesh, element_order, W2)
      field_fs => field_np1%get_function_space()
      call increment%initialise(field_fs)
      call sum_flux%initialise(w2_fs)

      ! Get final field at end of transport
      ! First sum the fluxes from all previous steps
      call build_up_flux(sum_flux, flux, transport_runtime, transport_metadata)

      ! ---------------------------------------------------------------------- !
      ! Conservative clipping by limiting flux, if specified
      ! ---------------------------------------------------------------------- !

      if (enforce_min_value .and. min_val_method == min_val_method_iterative) then

        if ( subroutine_timers ) call timer('transport.iterative_min_val')

        div => get_directional_im3_div_r_tran(mesh_id, direction_3d)
        ! TODO #3706: the flux limiter should use r_tran precision
        div_r_def => get_directional_im3_div(mesh_id, direction_3d)

        min_value = transport_metadata%get_min_value()
        acceptable_min = real(min_val_abs_tol, r_tran)
        adv_dt = 1.0_r_tran  ! dt hidden inside of flux already
        num_limiting_steps = min_val_max_iterations

        ! Dynamic limiting -- limit until we are close to removing negative values
        do limit_iteration = 1, num_limiting_steps
          call invoke( iterate_min_flux_kernel_type(field_start, sum_flux,         &
                                                    div_r_def, min_value, adv_dt), &
          ! Apply flux, and determine new minima
                       dg_matrix_vector_kernel_type(increment, sum_flux, div),     &
                       X_minus_Y(field_np1, field_start, increment) )

          call get_field_minmax( field_np1, field_min, field_max )

          if (field_min > acceptable_min) then
            write(log_scratch_space,'(A,I8,A)') 'Reduced negative values ' // &
              'to satisfactory level within ', limit_iteration, ' iterations'
            call log_event(log_scratch_space, LOG_LEVEL_INFO)
            exit
          else if (limit_iteration == num_limiting_steps) then
            write(log_scratch_space,'(A,I8,A)') 'Did not reduce negative ' // &
              'values enough within ', num_limiting_steps, ' iterations'
            call log_event(log_scratch_space, LOG_LEVEL_INFO)
          end if
        end do

        if ( subroutine_timers ) call timer('transport.iterative_min_val')

      else if (operators == operators_fem) then
        ! Finite element transport, so need full divergence operator
        div => get_directional_im3_div_r_tran(mesh_id, direction_3d)
        call invoke( dg_matrix_vector_kernel_type(increment, sum_flux, div), &
                     X_minus_Y(field_np1, field_start, increment) )

      else
        ! Compute updated field using flux for whole transport step
        ! dt is hidden inside flux
        call invoke( fv_divergence_3d_kernel_type(increment, sum_flux,         &
                                                  detj_at_w3),                 &
                     X_minus_Y(field_np1, field_start, increment) )

      end if

      ! Limiter doesn't guarantee positivity, so mop up here
      if (enforce_min_value) then
        if (min_val_method == min_val_method_clipping) then
          min_value = transport_metadata%get_min_value()
          call invoke( inc_max_aX(min_value, field_np1) )
        else
          call invoke( conservative_neg_fix_kernel_type(field_np1, detj_at_w3) )
        end if
      end if

    end if

    ! ------------------------------------------------------------------------ !
    ! Blending zone update
    ! ------------------------------------------------------------------------ !
    if ( limited_area .and. topology == topology_non_periodic ) then
      ! This code is required while LAMs loop over cells right up to
      ! the edge of a limited area domain.  It can be removed if
      ! we only loop over columns in the interior domain.

      ! Don't update the field near the edge of the domain. A configurable depth of using
      ! the transport_boundary_depth is chosen here.  This will depend
      ! on the number of RK stages and spatial reconstruction order.
      ! Ticket #3112 will investigate further options.
      call overwrite_blending_zone_rtran(field_np1, field_in, depth=transport_boundary_depth)
    end if

    ! ------------------------------------------------------------------------ !
    ! Store dry field details
    ! ------------------------------------------------------------------------ !
    ! Store field in transport_runtime for conservative transport
    ! if this is the underlying dry field
    if ( is_dry_field ) then
      ! Determine direction of transport
      fs_idx = flux%which_function_space()
      select case (fs_idx)
      case (W2H)
        direction = direction_h
      case (W2V)
        direction = direction_v
      case (W2)
        direction = direction_3d
      end select

      field_fs => field_np1%get_function_space()
      step = transport_runtime%get_tracer_step_ctr()

      ! Need to compute the corresponding density transported by this flux
      if ( subroutine_timers ) call timer('transport.end_cons_update')

      conservative_field_n => transport_runtime%get_rho_d(mesh_id, step)
      call conservative_field_np1%initialise(field_fs)
      call increment%initialise(field_fs)

      if (operators == operators_fem) then
        ! Finite element transport, so need full divergence operator
        div => get_directional_im3_div_r_tran(mesh_id, direction)
        call invoke( dg_matrix_vector_kernel_type(increment, flux, div),       &
                     X_minus_Y(conservative_field_np1, conservative_field_n,   &
                               increment) )

      else
        ! Can use quicker lowest-order kernels to take the divergence
        select case (direction)
        case (direction_3d)
          call invoke( fv_divergence_3d_kernel_type(increment, flux,           &
                                                    detj_at_w3),               &
                       X_minus_Y(conservative_field_np1,                       &
                                 conservative_field_n, increment) )
        case (direction_h)
          call invoke( fv_divergence_2d_kernel_type(increment, flux,           &
                                                    detj_at_w3),               &
                       X_minus_Y(conservative_field_np1,                       &
                                 conservative_field_n, increment) )
        case (direction_v)
          call invoke( fv_divergence_z_kernel_type(increment, flux,            &
                                                   detj_at_w3),                &
                       X_minus_Y(conservative_field_np1,                       &
                                 conservative_field_n, increment) )
        end select

        ! We may also need to compute rho_d_ffsl for consistent transport
        if ( direction == direction_h .and. check_any_eqn_consistent() ) then
          ! Compute stored FFSL density fields by adding increments to the
          ! previously stored rho fields, and not the advective rho predictor
          call conservative_field_x%initialise( vector_space = field_fs )
          call conservative_field_y%initialise( vector_space = field_fs )
          call increment_x%initialise( vector_space = field_fs )
          call increment_y%initialise( vector_space = field_fs )

          call invoke( fv_divergence_x_kernel_type(increment_x, flux,          &
                                                   detj_at_w3),                &
                       fv_divergence_y_kernel_type(increment_y, flux,          &
                                                   detj_at_w3),                &
                       X_minus_Y(conservative_field_x, conservative_field_n,   &
                                                                increment_x),  &
                       X_minus_Y(conservative_field_y, conservative_field_n,   &
                                                                increment_y) )

          if ( limited_area .and. topology == topology_non_periodic ) then
            call overwrite_blending_zone_rtran(conservative_field_x, conservative_field_n, &
                                               depth=transport_boundary_depth)
            call overwrite_blending_zone_rtran(conservative_field_y, conservative_field_n, &
                                               depth=transport_boundary_depth)
          end if

          call transport_runtime%set_rho_d_ffsl_x(conservative_field_x, step)
          call transport_runtime%set_rho_d_ffsl_y(conservative_field_y, step)
        end if

      end if

      if ( limited_area .and. topology == topology_non_periodic ) then
        call overwrite_blending_zone_rtran(conservative_field_np1, conservative_field_n, depth=transport_boundary_depth)
      end if

      call transport_runtime%set_rho_d(conservative_field_np1, step + 1)

      if ( subroutine_timers ) call timer('transport.end_cons_update')

      ! Store the dry flux
      call transport_runtime%set_dry_flux(flux, step)
    end if

    ! Increment the step counter in the transport runtime
    call transport_runtime%inc_tracer_step_ctr()

    call log_field_minmax( LOG_LEVEL_DEBUG, 'field_np1: end_of_conservative_step', field_np1)

    if ( subroutine_timers ) call timer('transport.end_of_transport')

  end subroutine end_of_conservative_step_alg

  !> @brief Common end-of-step code for consistent transport schemes
  !> @details Performs common routines at the end of transport steps (which may
  !!          be the end of various split steps in a split horizontal-vertical
  !!          scheme). This is for the consistent, conservative transport of
  !!          mixing ratio fields. The steps are to:
  !!          - obtain the species' density from the mixing ratio (possibly on
  !!            the shifted mesh)
  !!          - conservatively enforce a minimum value for the field
  !!          - if this is not the final step, save the flux for future use
  !!          - obtain the transported mixing ratio field
  !!          - overwrite field data in the blending zone, if necessary
  !> @param[in,out] field_np1          Field at the end of the transport step
  !!                                   to be computed.
  !> @param[in]     flux               The mass flux for this transport step.
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting the field
  !> @param[in]     compute_field_np1  Optional flag, indicating whether
  !!                                   field_np1 needs computing from the
  !!                                   divergence of fluxes. If this argument
  !!                                   is not provided, field_np1 will be
  !!                                   computed but only on the final split step
  subroutine end_of_consistent_step_alg(field_np1, flux, transport_metadata, &
                                        compute_field_np1)

    use consistent_dispersion_kernel_mod, &
                                      only: consistent_dispersion_kernel_type
    use sci_inject_sh_w3_to_wt_kernel_mod, &
                                      only: inject_sh_w3_to_wt_kernel_type
    use sci_inject_wt_to_sh_w3_kernel_mod, &
                                      only: inject_wt_to_sh_w3_kernel_type
    use theta_dispersion_factor_kernel_mod, &
                                      only: theta_dispersion_factor_kernel_type
    use sci_w3_to_w2_average_kernel_mod, &
                                      only: w3_to_w2_average_kernel_type

    implicit none

    ! Arguments
    type(r_tran_field_type),       intent(inout) :: field_np1
    type(r_tran_field_type),       intent(in)    :: flux
    type(transport_metadata_type), intent(in)    :: transport_metadata
    logical(kind=l_def), optional, intent(in)    :: compute_field_np1

    ! Internal variables
    integer(kind=i_def)                   :: prime_extrusion_mesh_id
    integer(kind=i_def)                   :: step, last_step
    integer(kind=i_def)                   :: limit_iteration
    integer(kind=i_def)                   :: num_limiting_steps
    integer(kind=i_def)                   :: mr_function_space
    integer(kind=i_def)                   :: flux_function_space
    type(mesh_type),              pointer :: prime_extrusion_mesh => null()
    type(mesh_type),              pointer :: shifted_mesh => null()
    type(r_tran_field_type)               :: increment
    type(r_tran_field_type)               :: rho_X_start, rho_X_np1
    type(r_tran_field_type)               :: mr_sh_w3_start, mr_sh_w3_np1
    type(r_tran_field_type),      pointer :: mr_start => null()
    type(r_tran_field_type),      pointer :: dry_flux => null()
    type(r_tran_field_type),      pointer :: rho_d_start => null()
    type(r_tran_field_type),      pointer :: rho_d_np1 => null()
    type(r_tran_field_type),      pointer :: detj_at_w3 => null()
    type(field_type),             pointer :: height_wt => null()
    type(field_type),             pointer :: rmultiplicity_shifted => null()
    type(integer_field_type),     pointer :: face_selector_ew => null()
    type(integer_field_type),     pointer :: face_selector_ns => null()
    type(r_tran_field_type)               :: sum_flux
    type(r_tran_field_type)               :: theta_factor_wt
    type(r_tran_field_type)               :: theta_factor_w2_shifted
    type(r_tran_field_type)               :: theta_factor_w3_shifted
    type(r_tran_field_type)               :: flux_correction
    type(function_space_type),    pointer :: w3_fs => null()
    type(function_space_type),    pointer :: w2_fs => null()
    type(function_space_type),    pointer :: sh_w3_fs => null()
    type(function_space_type),    pointer :: sh_w2_fs => null()
    type(r_tran_operator_type),   pointer :: div => null()
    type(operator_type),          pointer :: div_r_def => null()
    type(transport_runtime_type), pointer :: transport_runtime => null()
    logical(kind=l_def)                   :: enforce_min_value
    logical(kind=l_def)                   :: final_split_step
    logical(kind=l_def)                   :: logspace
    real(kind=r_tran)                     :: min_value
    real(kind=r_tran)                     :: adv_dt
    real(kind=r_tran)                     :: acceptable_min
    real(kind=r_tran)                     :: field_min, field_max
    logical(kind=l_def)                   :: to_compute_field_np1

    if ( subroutine_timers ) call timer('transport.end_of_transport')

    ! Extract transport runtime
    prime_extrusion_mesh => field_np1%get_mesh()
    transport_runtime => get_transport_runtime(prime_extrusion_mesh)
    prime_extrusion_mesh_id = prime_extrusion_mesh%get_id()
    enforce_min_value = transport_metadata%get_enforce_min_value()
    mr_function_space = field_np1%which_function_space()
    flux_function_space = flux%which_function_space()
    mr_start => transport_runtime%get_field_n()

    ! Determine whether this is the final split step
    final_split_step = ( transport_runtime%get_tracer_step_ctr() &
                         == transport_runtime%get_num_dry_steps() )

    ! Set variable for determining whether to recompute field_np1 through
    ! taking the divergence of fluxes over the whole time step
    to_compute_field_np1 = final_split_step
    if (present(compute_field_np1)) then
      to_compute_field_np1 = compute_field_np1
      if (enforce_min_value .and. min_val_method == min_val_method_iterative) then
        to_compute_field_np1 = .true.
      end if
    end if

    ! ------------------------------------------------------------------------ !
    ! Compute consistent dispersion relation correction, if required
    ! ------------------------------------------------------------------------ !

    if (theta_dispersion_correction .and. mr_function_space == Wtheta .and.    &
        (trim(transport_metadata%get_name()) == 'potential_temperature' .or.   &
         trim(transport_metadata%get_name()) == 'theta') .and. final_split_step) then
      ! Theta dispersion correction was calculated in some step.
      ! field_np1 will need recomputing, so set that flag here
      to_compute_field_np1 = .true.
    end if

    if (theta_dispersion_correction .and. mr_function_space == Wtheta .and.    &
        (flux_function_space == W2 .or. flux_function_space == W2H) .and.      &
        (trim(transport_metadata%get_name()) == 'potential_temperature' .or.   &
         trim(transport_metadata%get_name()) == 'theta')) then

      if ( subroutine_timers ) call timer('transport.theta_dispersion')

      shifted_mesh => mesh_collection%get_mesh(prime_extrusion_mesh, SHIFTED)
      sh_w3_fs => function_space_collection%get_fs(shifted_mesh, 0, W3)
      step = transport_runtime%get_tracer_step_ctr()
      rmultiplicity_shifted => get_rmultiplicity(flux_function_space, shifted_mesh%get_id())
      dry_flux => transport_runtime%get_dry_flux(prime_extrusion_mesh_id, step)
      height_wt => get_height(Wtheta, prime_extrusion_mesh_id)
      logspace = transport_metadata%get_log_space()
      face_selector_ew => get_face_selector_ew(prime_extrusion_mesh_id)
      face_selector_ns => get_face_selector_ns(prime_extrusion_mesh_id)

      call theta_factor_wt%initialise( mr_start%get_function_space() )
      call theta_factor_w2_shifted%initialise( flux%get_function_space() )
      call theta_factor_w3_shifted%initialise( sh_w3_fs )
      call flux_correction%initialise( flux%get_function_space() )

      ! Compute theta factor
      call invoke( name="theta_factor",                                        &
                   theta_dispersion_factor_kernel_type(theta_factor_wt,        &
                                                       mr_start,               &
                                                       height_wt,              &
                                                       logspace) )
      ! Separate invokes as on different meshes
      call invoke( inject_wt_to_sh_w3_kernel_type(theta_factor_w3_shifted,     &
                                                  theta_factor_wt),            &
                   setval_c(theta_factor_w2_shifted, 0.0_r_tran),              &
                   w3_to_w2_average_kernel_type(theta_factor_w2_shifted,       &
                                                theta_factor_w3_shifted,       &
                                                rmultiplicity_shifted) )
      ! Can't combine these invokes as the W2 fields are on different meshes
      call invoke( setval_c(flux_correction, 0.0_r_tran),                      &
                   consistent_dispersion_kernel_type(flux_correction,          &
                                                     dry_flux,                 &
                                                     theta_factor_w2_shifted,  &
                                                     face_selector_ew,         &
                                                     face_selector_ns),        &
                   inc_X_plus_Y(flux, flux_correction) )

      if ( subroutine_timers ) call timer('transport.theta_dispersion')
    end if

    ! ------------------------------------------------------------------------ !
    ! Store flux
    ! ------------------------------------------------------------------------ !

    if (.not. final_split_step) call transport_runtime%set_flux(flux)

    ! ------------------------------------------------------------------------ !
    ! Compute increment from all split steps
    ! ------------------------------------------------------------------------ !

    if ( final_split_step .and. to_compute_field_np1 ) then

      ! ---------------------------------------------------------------------- !
      ! Calculate density at start of transport step
      ! ---------------------------------------------------------------------- !

      last_step = transport_runtime%get_num_dry_steps()

      select case ( mr_function_space )
      case ( W3 )
        w3_fs => function_space_collection%get_fs(prime_extrusion_mesh, 0, W3)
        w2_fs => function_space_collection%get_fs(prime_extrusion_mesh, 0, W2)
        rho_d_start => transport_runtime%get_rho_d(prime_extrusion_mesh_id, 1)
        rho_d_np1 => transport_runtime%get_rho_d(prime_extrusion_mesh_id, last_step+1)
        div => get_directional_im3_div_r_tran(prime_extrusion_mesh_id, direction_3d)
        ! TODO #3706: the flux limiter should use r_tran precision
        div_r_def => get_directional_im3_div(prime_extrusion_mesh_id, direction_3d)
        detj_at_w3 => get_detj_at_w3_r_tran(prime_extrusion_mesh_id)

        call rho_X_start%initialise( w3_fs )
        call rho_X_np1%initialise( w3_fs )
        call increment%initialise( w3_fs )
        call sum_flux%initialise( w2_fs )

        call invoke( X_times_Y(rho_X_start, mr_start, rho_d_start) )

      case ( Wtheta )
        shifted_mesh => mesh_collection%get_mesh(prime_extrusion_mesh, SHIFTED)
        sh_w3_fs => function_space_collection%get_fs(shifted_mesh, 0, W3)
        sh_w2_fs => function_space_collection%get_fs(shifted_mesh, 0, W2)
        rho_d_start => transport_runtime%get_rho_d(shifted_mesh%get_id(), 1)
        rho_d_np1 => transport_runtime%get_rho_d(shifted_mesh%get_id(), last_step+1)
        div => get_directional_im3_div_r_tran(shifted_mesh%get_id(), direction_3d)
        ! TODO #3706: the flux limiter should use r_tran precision
        div_r_def => get_directional_im3_div(shifted_mesh%get_id(), direction_3d)
        detj_at_w3 => get_detj_at_w3_r_tran(shifted_mesh%get_id())

        call mr_sh_w3_start%initialise( sh_w3_fs )
        call mr_sh_w3_np1%initialise( sh_w3_fs )
        call rho_X_start%initialise( sh_w3_fs )
        call rho_X_np1%initialise( sh_w3_fs )
        call increment%initialise( sh_w3_fs )
        call sum_flux%initialise( sh_w2_fs )

        if (enforce_min_value) then
          ! Assign values in all layers from original mixing ratio
          ! (the inverse of this operation can generate new extrema)
          call invoke( X_times_Y(rho_X_start, mr_start, rho_d_start) )
        else
          ! Interpolate in top/bottom layers
          call invoke( inject_wt_to_sh_w3_kernel_type(mr_sh_w3_start, mr_start), &
                       X_times_Y(rho_X_start, mr_sh_w3_start, rho_d_start) )
        end if
      end select

      ! ---------------------------------------------------------------------- !
      ! Conservative clipping by limiting flux, if specified
      ! ---------------------------------------------------------------------- !

      call build_up_flux(sum_flux, flux, transport_runtime, transport_metadata)

      if (enforce_min_value .and. min_val_method == min_val_method_iterative) then
        if ( subroutine_timers ) call timer('transport.iterative_min_val')

        min_value = transport_metadata%get_min_value()
        adv_dt = 1.0_r_tran  ! dt hidden inside of flux already
        acceptable_min = real(min_val_abs_tol, r_tran)
        num_limiting_steps = min_val_max_iterations

        ! Dynamic limiting -- limit until we are close to removing negative values
        do limit_iteration = 1, num_limiting_steps
          call invoke( iterate_min_flux_kernel_type(rho_X_start, sum_flux,         &
                                                    div_r_def, min_value, adv_dt), &
          ! Apply flux, and determine new minima
                       dg_matrix_vector_kernel_type(increment, sum_flux, div),     &
                       X_minus_Y(rho_X_np1, rho_X_start, increment) )

          call get_field_minmax( rho_X_np1, field_min, field_max )

          if (field_min > acceptable_min) then
            write(log_scratch_space,'(A,I8,A)') 'Reduced negative values ' // &
              'to satisfactory level within ', limit_iteration, ' iterations'
            call log_event(log_scratch_space, LOG_LEVEL_INFO)
            exit
          else if (limit_iteration == num_limiting_steps) then
            write(log_scratch_space,'(A,I8,A)') 'Did not reduce negative ' // &
              'values enough within ', num_limiting_steps, ' iterations'
            call log_event(log_scratch_space, LOG_LEVEL_INFO)
          end if
        end do

        if ( subroutine_timers ) call timer('transport.iterative_min_val')

      else
        ! Compute updated field using flux for whole transport step
        ! dt is hidden inside flux
        call invoke( fv_divergence_3d_kernel_type(increment, sum_flux,         &
                                                  detj_at_w3),                 &
                     X_minus_Y(rho_X_np1, rho_X_start, increment) )
      end if

      ! Limiter doesn't guarantee positivity, so mop up here
      if (enforce_min_value .and. &
          min_val_method /= min_val_method_clipping) then
        call invoke( conservative_neg_fix_kernel_type(rho_X_np1, detj_at_w3) )
      end if

      ! ---------------------------------------------------------------------- !
      ! Calculate mixing ratio at end of transport step
      ! ---------------------------------------------------------------------- !

      select case ( mr_function_space )
      case ( W3 )
        call invoke( X_divideby_Y(field_np1, rho_X_np1, rho_d_np1) )

      case ( Wtheta )
        if (enforce_min_value) then
          ! Cannot generate negative values, so just pointwise injection
          call invoke( X_divideby_Y(field_np1, rho_X_np1, rho_d_np1) )
        else
          call invoke( X_divideby_Y(mr_sh_w3_np1, rho_X_np1, rho_d_np1) )
          ! Extrapolation at top/bottom is allowed
          ! Turn back to Wtheta -- separate invoke as on different mesh
          call invoke( inject_sh_w3_to_wt_kernel_type(field_np1, mr_sh_w3_np1) )
        end if

      case default
        call log_event('Function space for consistent transport not implemented', LOG_LEVEL_ERROR)
      end select

    end if

    ! Clip at end, which will also catch negative values from extrapolation at
    ! model top/bottom when converting back to Wtheta
    if (enforce_min_value .and. final_split_step) then
      min_value = transport_metadata%get_min_value()
      call invoke( inc_max_aX(min_value, field_np1) )
    end if

    ! ------------------------------------------------------------------------ !
    ! Blending zone update
    ! ------------------------------------------------------------------------ !
    if ( limited_area .and. topology == topology_non_periodic ) then
      ! This code is required while LAMs loop over cells right up to
      ! the edge of a limited area domain.  It can be removed if
      ! we only loop over columns in the interior domain.

      ! Don't update the field near the edge of the domain. A configurable depth of using
      ! the transport_boundary_depth is chosen here.  This will depend
      ! on the number of RK stages and spatial reconstruction order.
      ! Ticket #3112 will investigate further options.
      call overwrite_blending_zone_rtran(field_np1, mr_start, depth=transport_boundary_depth)
    end if

    ! Increment the step counter in the transport runtime
    call transport_runtime%inc_tracer_step_ctr()

    call log_field_minmax( LOG_LEVEL_DEBUG, 'field_np1: end_of_consistent_step', field_np1)

    nullify(prime_extrusion_mesh, shifted_mesh, mr_start, transport_runtime,   &
            rho_d_start, rho_d_np1, w3_fs, w2_fs, sh_w3_fs, sh_w2_fs, div,     &
            div_r_def, detj_at_w3, face_selector_ew, face_selector_ns)

    if ( subroutine_timers ) call timer('transport.end_of_transport')

  end subroutine end_of_consistent_step_alg

  !> @brief Build up the mass flux used over a full conservative transport step
  !> @details Takes the mass fluxes saved in the transport runtime, and builds
  !!          up the fluxes from those for each transport step.
  !> @param[in,out] sum_flux           The 3D total flux to be computed
  !> @param[in]     flux_last_step     The flux from the final transport step
  !> @param[in]     transport_runtime  The transport runtime object
  !> @param[in]     transport_metadata The transport meatadata object for the
  !!                                   transported field
  subroutine build_up_flux(sum_flux, flux_last_step, transport_runtime,        &
                           transport_metadata)

    use combine_w2_field_kernel_mod, only: combine_w2_field_kernel_type

    implicit none

    ! Arguments
    type(r_tran_field_type),         intent(inout) :: sum_flux
    type(r_tran_field_type), target, intent(in)    :: flux_last_step
    type(transport_runtime_type),    intent(in)    :: transport_runtime
    type(transport_metadata_type),   intent(in)    :: transport_metadata

    ! Internal variables
    integer(kind=i_def)                :: mesh_id, step
    type(mesh_type),           pointer :: mesh => null()
    type(function_space_type), pointer :: w2_fs => null()
    type(function_space_type), pointer :: w2h_fs => null()
    type(function_space_type), pointer :: w2v_fs => null()
    type(r_tran_field_type),   pointer :: old_flux => null()
    type(r_tran_field_type),   pointer :: hori_flux => null()
    type(integer_field_type),  pointer :: face_selector_ew => null()
    type(integer_field_type),  pointer :: face_selector_ns => null()
    type(r_tran_field_type)            :: sum_hori_flux
    type(r_tran_field_type)            :: sum_vert_flux
    type(r_tran_field_type)            :: combined_flux
    logical(kind=l_def)                :: is_flux_3d
    logical(kind=l_def)                :: is_flux_split

    if ( subroutine_timers ) call timer('transport.build_up_flux')

    ! Don't know which function space the fluxes are in -- add up each
    mesh => sum_flux%get_mesh()
    mesh_id = mesh%get_id()
    w2_fs => function_space_collection%get_fs(mesh, 0, W2)
    w2h_fs => function_space_collection%get_fs(mesh, 0, W2H)
    w2v_fs => function_space_collection%get_fs(mesh, 0, W2V)
    face_selector_ew => get_face_selector_ew(mesh_id)
    face_selector_ns => get_face_selector_ns(mesh_id)

    ! Make specific routine for our most common splitting to slightly optimise
    ! for it
    if ( transport_metadata%get_splitting() ==  splitting_strang_vhv ) then

      ! Get fluxes from first two stages of splitting
      old_flux => transport_runtime%get_flux(mesh_id, 1)
      hori_flux => transport_runtime%get_flux(mesh_id, 2)

      call sum_vert_flux%initialise(w2v_fs)
      call invoke( X_plus_Y(sum_vert_flux, old_flux, flux_last_step),          &
                   combine_w2_field_kernel_type(sum_flux, hori_flux,           &
                                                sum_vert_flux,                 &
                                                face_selector_ew,              &
                                                face_selector_ns) )

    ! General case for any splitting
    else
      call sum_hori_flux%initialise(w2h_fs)
      call sum_vert_flux%initialise(w2v_fs)

      call invoke( setval_c(sum_flux, 0.0_r_tran),      &
                   setval_c(sum_hori_flux, 0.0_r_tran), &
                   setval_c(sum_vert_flux, 0.0_r_tran) )

      is_flux_3d = .false.
      is_flux_split = .false.

      do step = 1, transport_runtime%get_num_dry_steps()
        if (step == transport_runtime%get_num_dry_steps()) then
          old_flux => flux_last_step
        else
          old_flux => transport_runtime%get_flux(mesh_id, step)
        end if

        select case ( old_flux%which_function_space() )
        case ( W2 )
          is_flux_3d = .true.
          call invoke( inc_X_plus_Y(sum_flux, old_flux) )
        case ( W2H )
          is_flux_split = .true.
          call invoke( inc_X_plus_Y(sum_hori_flux, old_flux) )
        case ( W2V )
          is_flux_split = .true.
          call invoke( inc_X_plus_Y(sum_vert_flux, old_flux) )
        case default
          call log_event('Function space of flux not recognised', LOG_LEVEL_ERROR)
        end select
      end do

      if (is_flux_split) then
        if (is_flux_3d) then
          call combined_flux%initialise(w2_fs)
          call invoke( combine_w2_field_kernel_type(combined_flux,     &
                                                    sum_hori_flux,     &
                                                    sum_vert_flux,     &
                                                    face_selector_ew,  &
                                                    face_selector_ns), &
                      inc_X_plus_Y(sum_flux, combined_flux) )
        else
          ! There is no 3D step, so straightaway combine horizontal and vertical fluxes
          call invoke( combine_w2_field_kernel_type(sum_flux, sum_hori_flux,   &
                                                    sum_vert_flux,             &
                                                    face_selector_ew,          &
                                                    face_selector_ns) )
        end if
      end if
    end if

    nullify(mesh, w2_fs, w2h_fs, w2v_fs, old_flux, hori_flux, &
            face_selector_ew, face_selector_ns)

    if ( subroutine_timers ) call timer('transport.build_up_flux')

  end subroutine build_up_flux

end module end_of_transport_step_alg_mod
