!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief A module that controls set-up of various transport objects.
!> @details This module controls the set-up of various objects that are
!!          created at the start of (or during) the transport process, and
!!          are needed throughout the transport routines.

module transport_runtime_alg_mod

  use check_configuration_mod,        only: check_any_scheme_mol,            &
                                            check_any_scheme_ffsl,           &
                                            check_any_scheme_split,          &
                                            check_any_scheme_slice,          &
                                            check_any_horizontal_method_mol, &
                                            check_any_hori_scheme_sl,        &
                                            check_any_vert_scheme_sl,        &
                                            check_any_reversible_sl,         &
                                            check_wind_shifted,              &
                                            check_horz_dep_pts,              &
                                            check_vert_dep_pts,              &
                                            check_any_splitting_vhv,         &
                                            check_any_splitting_hvh,         &
                                            check_any_eqn_consistent,        &
                                            check_any_advective_swift,       &
                                            check_any_consistent_swift,      &
                                            check_any_consistent_cosmic,     &
                                            get_required_stencil_depth
  use constants_mod,                  only: r_def, r_second, i_def, l_def,   &
                                            str_def, tiny_eps, imdi, r_tran, &
                                            EPS_R_TRAN
  use extrusion_mod,                  only: SHIFTED, TWOD
  use fem_constants_mod,              only: get_detj_at_w3_r_tran
  use field_mod,                      only: field_type
  use sci_field_minmax_alg_mod,       only: get_field_minmax, &
                                            log_field_minmax
  use finite_element_config_mod,      only: element_order
  use fs_continuity_mod,              only: W2, W2h, W2v, W3, Wtheta
  use function_space_mod,             only: function_space_type
  use function_space_collection_mod,  only: function_space_collection
  use geometric_constants_mod,        only: get_panel_id,         &
                                            get_face_selector_ew, &
                                            get_face_selector_ns
  use integer_field_mod,              only: integer_field_type
  use io_config_mod,                  only: subroutine_timers
  use lipschitz_horizontal_kernel_mod, &
                                      only: lipschitz_horizontal_kernel_type
  use lipschitz_vertical_kernel_mod, &
                                      only: lipschitz_vertical_kernel_type
  use local_mesh_mod,                 only: local_mesh_type
  use log_mod,                        only: log_event,            &
                                            log_scratch_space,    &
                                            LOG_LEVEL_ERROR,      &
                                            LOG_LEVEL_DEBUG,      &
                                            LOG_LEVEL_INFO,       &
                                            log_level
  use mesh_mod,                       only: mesh_type
  use mesh_collection_mod,            only: mesh_collection
  use model_clock_mod,                only: model_clock_type
  use r_tran_field_mod,               only: r_tran_field_type
  use remap_on_extended_mesh_alg_mod, only: initialise_remap_on_extended_mesh, &
                                            remap_field_on_extended_mesh,      &
                                            linear_remap
  use runtime_tools_mod,              only: check_initialised_field
  use subgrid_config_mod,             only: dep_pt_stencil_extent, &
                                            outer_order,           &
                                            inner_order
  use timer_mod,                      only: timer
  use transport_config_mod,           only: extended_mesh,        &
                                            special_edges_treatment
  use transport_enumerated_types_mod, only: scheme_split,         &
                                            direction_h,          &
                                            direction_v,          &
                                            direction_3d,         &
                                            splitting_strang_hvh, &
                                            splitting_strang_vhv, &
                                            splitting_hv,         &
                                            splitting_vh,         &
                                            splitting_none

  use psykal_lite_mod,                only: invoke_copy_to_rtran
  use psykal_lite_transport_mod,      only: invoke_deep_X_times_Y

  implicit none

  private

  ! Public types
  ! TODO #3008: this should be based on a linked_list_item type
  type, public :: transport_runtime_type

    private

    integer(kind=i_def)                                       :: n_meshes
    integer(kind=i_def)                                       :: local_mesh_id
    integer(kind=i_def)                                       :: num_dry_steps
    integer(kind=i_def)                                       :: tracer_step_ctr
    integer(kind=i_def),        allocatable, dimension(:)     :: mesh_ids
    integer(kind=i_def),        allocatable, dimension(:)     :: dep_stencil_extent_xy
    integer(kind=i_def),        allocatable, dimension(:)     :: dep_stencil_extent_oxy
    integer(kind=i_def),        allocatable, dimension(:,:)   :: tracer_stencil_extent_ixy
    integer(kind=i_def),        allocatable, dimension(:,:)   :: tracer_stencil_extent_oxy
    type(r_tran_field_type),    allocatable, dimension(:)     :: advecting_wind
    type(r_tran_field_type),    allocatable, dimension(:)     :: horizontal_advecting_wind
    type(r_tran_field_type),    allocatable, dimension(:)     :: vertical_advecting_wind
    type(r_tran_field_type),    allocatable, dimension(:)     :: dep_dist_xy_w2
    type(r_tran_field_type),    allocatable, dimension(:)     :: dep_dist_xy_half_w2
    type(r_tran_field_type),    allocatable, dimension(:)     :: dep_dist_oxy_w2
    type(r_tran_field_type),    allocatable, dimension(:)     :: dep_dist_oxy_half_w2
    type(r_tran_field_type),    allocatable, dimension(:)     :: dep_dist_z_w2
    type(r_tran_field_type),    allocatable, dimension(:)     :: dep_dist_z_half_w2
    type(r_tran_field_type),    allocatable, dimension(:)     :: frac_wind_z
    type(r_tran_field_type),    allocatable, dimension(:)     :: frac_wind_z_half
    type(r_tran_field_type),    allocatable, dimension(:)     :: frac_wind_xy
    type(r_tran_field_type),    allocatable, dimension(:)     :: frac_wind_xy_half
    type(r_tran_field_type),    allocatable, dimension(:)     :: frac_wind_oxy
    type(r_tran_field_type),    allocatable, dimension(:)     :: frac_wind_oxy_half
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: tracer_dep_dist_z
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: tracer_dep_dist_ixy
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: tracer_dep_dist_oxy
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: dry_frac_flux_z
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: dry_frac_flux_ixy
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: dry_frac_flux_oxy
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_unity_x
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_unity_y
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_unity_z
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_unity_half_x
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_unity_half_y
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_unity_half_z
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_detj_x
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_detj_y
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_detj_xy
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_detj_x_half
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_detj_y_half
    type(r_tran_field_type),    allocatable, dimension(:)     :: adv_detj_xy_half
    type(r_tran_field_type)                                   :: field_n
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: rho_d
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: dry_mass
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: dry_mass_ffsl_x
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: dry_mass_ffsl_y
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: flux
    type(r_tran_field_type),    allocatable, dimension(:,:)   :: dry_flux
    type(r_tran_field_type),    allocatable, dimension(:,:,:) :: vert_cubic_coef
    type(integer_field_type),   allocatable, dimension(:,:,:) :: vert_cubic_index
    type(r_tran_field_type),    allocatable, dimension(:,:,:) :: vert_quintic_coef
    type(integer_field_type),   allocatable, dimension(:,:,:) :: vert_quintic_index
    type(r_tran_field_type),    allocatable, dimension(:,:,:) :: vert_linear_coef
    real(kind=r_tran),          allocatable, dimension(:)     :: horizontal_cfl_max
    real(kind=r_tran),          allocatable, dimension(:)     :: vertical_cfl_max
    real(kind=r_tran),          allocatable, dimension(:)     :: total_cfl_max
    class(model_clock_type),    pointer                       :: model_clock
    logical(kind=l_def)                                       :: rho_monotone_remap
    logical(kind=l_def)                                       :: rho_enforce_minvalue
    real(kind=r_tran)                                         :: rho_minvalue
    type(r_tran_field_type)                                   :: remap_weights
    type(integer_field_type)                                  :: remap_indices
    logical(kind=l_def)                                       :: computed_remapping
    logical(kind=l_def)                                       :: computed_dep_pt_idxs

    contains

    procedure, private :: idx_from_mesh_id
    procedure, private :: compute_num_dry_steps
    procedure, private :: check_negative_field
    procedure, public  :: direction_w2_fs
    procedure, public  :: get_local_mesh_id
    procedure, public  :: get_prime_extrusion_mesh_id
    procedure, public  :: restrict_dry_fields
    procedure, public  :: shift_dry_fields
    procedure, public  :: compute_consistent_quantities
    procedure, public  :: get_number_substeps
    procedure, public  :: get_dt_substep
    procedure, public  :: get_advecting_wind
    procedure, public  :: get_directional_advecting_wind
    procedure, public  :: get_horizontal_advecting_wind
    procedure, public  :: get_vertical_advecting_wind
    procedure, public  :: get_dep_dist_z_w2
    procedure, public  :: get_dep_dist_xy_w2
    procedure, public  :: get_frac_wind_z
    procedure, public  :: get_frac_wind_xy
    procedure, public  :: get_tracer_dep_dist_z
    procedure, public  :: get_tracer_dep_dist_xy
    procedure, public  :: get_dry_frac_flux_z
    procedure, public  :: get_dry_frac_flux_xy
    procedure, public  :: get_dep_stencil_extent_xy
    procedure, public  :: get_tracer_stencil_extent_xy
    procedure, public  :: get_adv_unity_x
    procedure, public  :: get_adv_unity_y
    procedure, public  :: get_adv_unity_z
    procedure, public  :: get_adv_detj_x
    procedure, public  :: get_adv_detj_y
    procedure, public  :: get_adv_detj_xy
    procedure, public  :: get_vert_sl_coef
    procedure, public  :: get_vert_sl_index
    procedure, public  :: get_field_n
    procedure, public  :: set_field_n
    procedure, public  :: get_rho_d
    procedure, public  :: set_rho_d
    procedure, public  :: get_dry_mass
    procedure, public  :: get_dry_mass_ffsl_x
    procedure, public  :: set_rho_d_ffsl_x
    procedure, public  :: get_dry_mass_ffsl_y
    procedure, public  :: set_rho_d_ffsl_y
    procedure, public  :: get_flux
    procedure, public  :: set_flux
    procedure, public  :: get_dry_flux
    procedure, public  :: set_dry_flux
    procedure, public  :: get_num_dry_steps
    procedure, public  :: get_tracer_step_ctr
    procedure, public  :: inc_tracer_step_ctr
    procedure, public  :: reset_tracer_step_ctr
    procedure, public  :: remap_on_extended_mesh
    procedure, public  :: initialise => transport_runtime_initialiser
    final              :: destroy_transport_runtime

  end type transport_runtime_type

  !-----------------------------------------------------------------------------
  ! Constructors
  !-----------------------------------------------------------------------------

contains

  !> @brief Constructs the transport_runtime object
  !> @param[in,out] self                  Transport runtime object to set
  !> @param[in]     primal_wind_n_rdef    Wind field at start of current time step on the
  !!                                      prime extrusion
  !> @param[in]     primal_wind_np1_rdef  Predictor of wind field at next time step on
  !!                                      the prime extrusion
  !> @param[in]     model_clock           Time within the model
  !> @param[in]     outer                 Outer (advection) iteration number
  !> @param[in]     cheap_update          Logical flag for cheap transport update
  !> @param[in]     rho_d_n_rdef          Start of transport dry density
  !> @param[in]     shifted_mesh          (Optional) Shifted mesh
  !>
  subroutine transport_runtime_initialiser( self,                 &
                                            primal_wind_n_rdef,   &
                                            primal_wind_np1_rdef, &
                                            model_clock,          &
                                            outer,                &
                                            cheap_update,         &
                                            rho_d_n_rdef,         &
                                            shifted_mesh )

    use calc_dep_pts_alg_mod,          only: calc_vert_dep_pts, &
                                             calc_hori_dep_pts, &
                                             select_detj_at_w2
    use compute_sl_coefficients_alg_mod, &
                                       only: compute_vert_quintic_coefficients_alg, &
                                             compute_vert_cubic_coefficients_alg
    use ffsl_unity_transport_alg_mod,  only: ffsl_unity_transport_alg,    &
                                             ffsl_unity_swift_alg
    use split_w2_field_kernel_mod,     only: split_w2_field_kernel_type
    use transport_config_mod,          only: max_vert_cfl_calc,           &
                                             max_vert_cfl_calc_dep_point, &
                                             max_vert_cfl_calc_uniform,   &
                                             vertical_sl_order,           &
                                             vertical_sl_order_cubic,     &
                                             vertical_sl_order_quintic,   &
                                             vertical_sl_order_cubic_hermite
    use map_w2_to_sh_w2_alg_mod,       only: sample_w2_to_sh_w2_alg
    use calc_max_cfl_kernel_mod,       only: calc_max_cfl_kernel_type
    use dg_matrix_vector_kernel_mod,   only: dg_matrix_vector_kernel_type
    use fem_constants_mod,             only: get_inverse_W3_mass_matrix_r_tran
    use r_tran_operator_mod,           only: r_tran_operator_type

    implicit none

    class(transport_runtime_type), intent(inout) :: self

    type(field_type),        target, intent(in) :: primal_wind_n_rdef
    type(field_type),        target, intent(in) :: primal_wind_np1_rdef
    class(model_clock_type), target, intent(in) :: model_clock
    integer(kind=i_def),             intent(in) :: outer
    logical(kind=l_def),             intent(in) :: cheap_update
    type(field_type),      optional, intent(in) :: rho_d_n_rdef

    type(mesh_type),  pointer, intent(in), optional :: shifted_mesh

    type(r_tran_field_type)          :: cfl, vertical_cfl, horizontal_cfl
    type(r_tran_field_type)          :: cfl_dep, cfl_dep_half
    type(r_tran_field_type)          :: sum_cfl, sum_horizontal_cfl, hori_cfl_dep
    type(r_tran_field_type)          :: dep_pt_wind_n, dep_pt_wind_np1
    integer(kind=i_def)              :: mesh_idx, num_compute_meshes
    integer(kind=i_def)              :: n_steps, n_meshes, i_coef
    type(mesh_type),         pointer :: mesh => null()
    type(local_mesh_type),   pointer :: local_mesh => null()
    type(r_tran_field_type), pointer :: wind_n   => null()
    type(r_tran_field_type), pointer :: wind_np1 => null()
    type(r_tran_field_type), target  :: shifted_wind_n
    type(r_tran_field_type), target  :: shifted_wind_np1
    type(field_type),        target  :: shifted_wind_n_rdef
    type(field_type),        target  :: shifted_wind_np1_rdef
    type(r_tran_field_type)          :: detj_at_w2_transport
    type(r_tran_field_type)          :: lipschitz_horizontal
    type(r_tran_field_type)          :: lipschitz_vertical
    type(r_tran_field_type)          :: remapped_unity, adv_unity_xy
    real(kind=r_tran)                :: cfl_min, cfl_max
    real(kind=r_tran)                :: dep_min, dep_max
    real(kind=r_tran)                :: h_cfl_min, h_cfl_max
    real(kind=r_tran)                :: v_cfl_min, v_cfl_max
    real(r_tran)                     :: cast_dt, half_dt
    logical(kind=l_def)              :: any_scheme_mol, any_scheme_split
    logical(kind=l_def)              :: any_scheme_ffsl
    logical(kind=l_def)              :: any_wind_shifted
    logical(kind=l_def)              :: any_splitting_vhv, any_splitting_hvh
    logical(kind=l_def)              :: any_scheme_slice
    logical(kind=l_def)              :: any_hori_scheme_sl, any_vert_scheme_sl
    logical(kind=l_def)              :: any_reversible_sl
    logical(kind=l_def)              :: any_advective_swift
    logical(kind=l_def)              :: any_consistent_swift
    logical(kind=l_def)              :: any_horz_dep_dist, any_vert_dep_dist
    logical(kind=l_def)              :: hermite_sl, vhv_split_sl
    logical(kind=l_def)              :: compute_cfl_dep
    integer(kind=i_def)              :: remap_depth

    type(mesh_type),           pointer :: tmp_mesh => null()
    type(mesh_type),           pointer :: twod_mesh => null()
    type(function_space_type), pointer :: wt_fs => null()
    type(function_space_type), pointer :: w3_fs => null()
    type(function_space_type), pointer :: w2_fs => null()
    type(function_space_type), pointer :: w2h_fs => null()
    type(function_space_type), pointer :: w2v_fs => null()
    type(function_space_type), pointer :: w3_2d_fs => null()
    type(integer_field_type),  pointer :: face_selector_ew => null()
    type(integer_field_type),  pointer :: face_selector_ns => null()
    type(r_tran_field_type),   pointer :: detj_at_w3 => null()

    ! r_tran type fields
    type(r_tran_field_type), target :: primal_wind_n
    type(r_tran_field_type), target :: primal_wind_np1
    type(r_tran_field_type)         :: rho_d_n

    if ( subroutine_timers ) call timer('transport.runtime_init')

    write(log_scratch_space, '(A,I4)') 'Setting up transport_runtime on mesh: ', &
                                       primal_wind_n_rdef%get_mesh_id()
    call log_event(log_scratch_space, LOG_LEVEL_DEBUG)

    ! Proxy for the first time the object is initialised
    if ( .not. allocated(self%mesh_ids) ) self%computed_remapping = .false.
    if ( .not. allocated(self%mesh_ids) ) self%computed_dep_pt_idxs = .false.

    ! TODO: options for remapping density are hard-wired
    ! They could be options in the future
    self%rho_monotone_remap = .true.
    self%rho_enforce_minvalue = .true.
    self%rho_minvalue = 0.0_r_tran

    ! Transfer r_def input to r_tran fields
    call primal_wind_n%initialise(vector_space = primal_wind_n_rdef%get_function_space() )
    call primal_wind_np1%initialise(vector_space = primal_wind_np1_rdef%get_function_space() )
    call invoke_copy_to_rtran(primal_wind_n,primal_wind_n_rdef)
    call invoke_copy_to_rtran(primal_wind_np1,primal_wind_np1_rdef)

    ! ======================================================================== !
    ! Checks for what schemes we have

    any_scheme_mol = check_any_scheme_mol()
    any_scheme_ffsl = check_any_scheme_ffsl()
    any_scheme_split = check_any_scheme_split()
    any_scheme_slice = check_any_scheme_slice()
    any_horz_dep_dist = check_horz_dep_pts()
    any_vert_dep_dist = check_vert_dep_pts()
    any_splitting_vhv = check_any_splitting_vhv()
    any_splitting_hvh = check_any_splitting_hvh()
    any_reversible_sl = check_any_reversible_sl()
    any_hori_scheme_sl = check_any_hori_scheme_sl()
    any_vert_scheme_sl = check_any_vert_scheme_sl()
    any_wind_shifted = check_wind_shifted()
    any_advective_swift = check_any_advective_swift()
    any_consistent_swift = check_any_consistent_swift()
    compute_cfl_dep = ((any_scheme_mol .or. log_level() <= LOG_LEVEL_INFO) &
                       .and. max_vert_cfl_calc == max_vert_cfl_calc_dep_point)

    ! ======================================================================== !
    ! Determine number of meshes

    ! By default only compute auxiliary fields on prime extrusion mesh
    num_compute_meshes = 1

    if ( present(shifted_mesh) ) then
      self%n_meshes = 2
      ! Only compute things on the shifted mesh if we need to
      if (any_wind_shifted) then
        num_compute_meshes = 2
      end if
    else
      self%n_meshes = 1
    end if

    !> @todo This is almost certainly the wrong thing to do but I want to get
    !>       something done.
    !>
    self%model_clock => model_clock
    cast_dt = real( model_clock%get_seconds_per_step(), r_tran )

    mesh => primal_wind_n_rdef%get_mesh()
    local_mesh => mesh%get_local_mesh()
    self%local_mesh_id = local_mesh%get_id()

    if (.not. allocated( self%mesh_ids ) ) then
      if ( subroutine_timers ) call timer('transport.runtime_allocate')

      allocate( self%mesh_ids(self%n_meshes),                   &
                self%advecting_wind(self%n_meshes),             &
                self%horizontal_advecting_wind(self%n_meshes),  &
                self%vertical_advecting_wind(self%n_meshes),    &
                self%dep_dist_z_w2(self%n_meshes),              &
                self%dep_dist_z_half_w2(self%n_meshes),         &
                self%dep_dist_xy_w2(self%n_meshes),             &
                self%dep_dist_xy_half_w2(self%n_meshes),        &
                self%dep_dist_oxy_w2(self%n_meshes),            &
                self%dep_dist_oxy_half_w2(self%n_meshes),       &
                self%frac_wind_z(self%n_meshes),                &
                self%frac_wind_z_half(self%n_meshes),           &
                self%frac_wind_xy(self%n_meshes),               &
                self%frac_wind_xy_half(self%n_meshes),          &
                self%frac_wind_oxy(self%n_meshes),              &
                self%frac_wind_oxy_half(self%n_meshes),         &
                self%dep_stencil_extent_xy(self%n_meshes),      &
                self%dep_stencil_extent_oxy(self%n_meshes),     &
                self%adv_unity_x(self%n_meshes),                &
                self%adv_unity_y(self%n_meshes),                &
                self%adv_unity_z(self%n_meshes),                &
                self%adv_unity_half_x(self%n_meshes),           &
                self%adv_unity_half_y(self%n_meshes),           &
                self%adv_unity_half_z(self%n_meshes),           &
                self%adv_detj_x(self%n_meshes),                 &
                self%adv_detj_y(self%n_meshes),                 &
                self%adv_detj_xy(self%n_meshes),                &
                self%adv_detj_x_half(self%n_meshes),            &
                self%adv_detj_y_half(self%n_meshes),            &
                self%adv_detj_xy_half(self%n_meshes),           &
                self%vert_cubic_coef(self%n_meshes,4,4),        &
                self%vert_cubic_index(self%n_meshes,4,4),       &
                self%vert_quintic_coef(self%n_meshes,2,6),      &
                self%vert_quintic_index(self%n_meshes,2,6),     &
                self%vert_linear_coef(self%n_meshes,2,2),       &
                self%horizontal_cfl_max(self%n_meshes),         &
                self%vertical_cfl_max(self%n_meshes),           &
                self%total_cfl_max(self%n_meshes) )
      if ( subroutine_timers ) call timer('transport.runtime_allocate')
    end if

    ! Get mesh ID and element order
    self%mesh_ids(1) = primal_wind_n_rdef%get_mesh_id()

    ! If asked for compute objects on the shifted mesh
    if ( present(shifted_mesh ) ) then
      self%mesh_ids(2) = shifted_mesh%get_id()
      write(log_scratch_space, '(A,I4)') '... and shifted mesh: ', &
                                         shifted_mesh%get_id()
      call log_event(log_scratch_space, LOG_LEVEL_DEBUG)
    end if

    ! ======================================================================== !
    ! Create winds on shifted mesh
    if ( present(shifted_mesh) ) then
      if ( subroutine_timers ) call timer('transport.shift_wind')
      ! TODO #3008: only initialise these if they will be used
      ! For now we need to initialise them for copying the transport runtime
      call shifted_wind_n_rdef%initialise( vector_space = &
              function_space_collection%get_fs(shifted_mesh, element_order, W2) )
      call shifted_wind_np1_rdef%initialise( vector_space = &
              function_space_collection%get_fs(shifted_mesh, element_order, W2) )
      call shifted_wind_n%initialise( vector_space = &
              function_space_collection%get_fs(shifted_mesh, element_order, W2) )
      call shifted_wind_np1%initialise( vector_space = &
              function_space_collection%get_fs(shifted_mesh, element_order, W2) )

      if (num_compute_meshes == 2) then
        ! Rather than duplicating a lot of mapping code for different field types,
        ! we go by intermediate r_def fields before copying to r_tran fields
        call sample_w2_to_sh_w2_alg(shifted_wind_n_rdef,   primal_wind_n_rdef)
        call sample_w2_to_sh_w2_alg(shifted_wind_np1_rdef, primal_wind_np1_rdef)
        call invoke_copy_to_rtran(shifted_wind_n,shifted_wind_n_rdef)
        call invoke_copy_to_rtran(shifted_wind_np1,shifted_wind_np1_rdef)
      end if
      if ( subroutine_timers ) call timer('transport.shift_wind')
    end if

    ! ======================================================================== !
    ! Initialise fields
    ! TODO #3008: we should only initialise fields that we actually use
    if ( subroutine_timers ) call timer('transport.field_initialise')

    do mesh_idx = 1, num_compute_meshes
      tmp_mesh => mesh_collection%get_mesh(self%mesh_ids(mesh_idx))
      twod_mesh => mesh_collection%get_mesh(tmp_mesh, TWOD)
      w2_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2)
      w2h_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2h)
      w2v_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2v)
      w3_fs => function_space_collection%get_fs(tmp_mesh, element_order, W3)
      w3_2d_fs => function_space_collection%get_fs(twod_mesh, element_order, W3)

      if (.not. self%advecting_wind(mesh_idx)%is_initialised()) then
        call self%advecting_wind(mesh_idx)%initialise( w2_fs )
        call self%horizontal_advecting_wind(mesh_idx)%initialise( w2h_fs )
        call self%vertical_advecting_wind(mesh_idx)%initialise( w2v_fs )

        ! TODO #4160: this assumes that if any_splitting_vhv=.true. then all transport uses VHV splitting
        if (any_splitting_vhv) then
          call self%adv_unity_half_z(mesh_idx)%initialise( w3_fs )
          call self%frac_wind_z_half(mesh_idx)%initialise( w2v_fs )
          call self%dep_dist_z_half_w2(mesh_idx)%initialise( w2v_fs )
        else
          call self%dep_dist_z_w2(mesh_idx)%initialise( w2v_fs )
          call self%frac_wind_z(mesh_idx)%initialise( w2v_fs )
          call self%adv_unity_z(mesh_idx)%initialise( w3_fs )
        end if

        if (any_splitting_hvh) then
          call self%adv_unity_half_x(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%adv_unity_half_y(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%adv_detj_x_half(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%adv_detj_y_half(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%adv_detj_xy_half(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%dep_dist_xy_half_w2(mesh_idx)%initialise( w2h_fs )
          call self%frac_wind_xy_half(mesh_idx)%initialise( w2h_fs )
          call self%dep_dist_oxy_half_w2(mesh_idx)%initialise( w2h_fs )
          call self%frac_wind_oxy_half(mesh_idx)%initialise( w2h_fs )
        else
          call self%adv_unity_x(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%adv_unity_y(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%adv_detj_x(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%adv_detj_y(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%adv_detj_xy(mesh_idx)%initialise( w3_fs, halo_depth = tmp_mesh%get_halo_depth() )
          call self%dep_dist_xy_w2(mesh_idx)%initialise( w2h_fs )
          call self%frac_wind_xy(mesh_idx)%initialise( w2h_fs )
          call self%dep_dist_oxy_w2(mesh_idx)%initialise( w2h_fs )
          call self%frac_wind_oxy(mesh_idx)%initialise( w2h_fs )
        end if

      end if
    end do

    if ( subroutine_timers ) call timer('transport.field_initialise')

    ! ======================================================================== !
    ! Compute auxiliary transport fields

    do mesh_idx = 1, num_compute_meshes

      tmp_mesh => mesh_collection%get_mesh(self%mesh_ids(mesh_idx))

      !=======================================================================!
      ! Create advecting winds

      if ( mesh_idx == 1 ) then
        ! First pass, make wind_n & wind_np1 point to the primal mesh fields
        wind_n   => primal_wind_n
        wind_np1 => primal_wind_np1
      else
        ! For second pass (if needed) set wind_n & wind_np1 to point to
        ! shifted mesh versions
        wind_n   => shifted_wind_n
        wind_np1 => shifted_wind_np1
      end if

      if ( cheap_update .AND. outer > 1 ) then
        ! Set advecting wind = (wind^{n+1}-wind^{n})/2
        ! For outer>2 this becomes (wind^{n+1}-wind^prev)/2
        call invoke( aX_minus_bY(self%advecting_wind(mesh_idx), 0.5_r_tran, wind_np1, &
                                                                0.5_r_tran, wind_n) )
      else
        ! Set advecting wind = (wind^{n}+wind^{n+1})/2
        call invoke( aX_plus_bY(self%advecting_wind(mesh_idx), 0.5_r_tran, wind_n, &
                                                               0.5_r_tran, wind_np1) )
      end if

      ! Split into horizontal and vertical advecting winds
      face_selector_ew => get_face_selector_ew(self%mesh_ids(mesh_idx))
      face_selector_ns => get_face_selector_ns(self%mesh_ids(mesh_idx))
      call invoke( setval_c(self%horizontal_advecting_wind(mesh_idx), 0.0_r_tran),      &
                   setval_c(self%vertical_advecting_wind(mesh_idx), 0.0_r_tran),        &
                   split_w2_field_kernel_type(self%horizontal_advecting_wind(mesh_idx), &
                                              self%vertical_advecting_wind(mesh_idx),   &
                                              self%advecting_wind(mesh_idx),            &
                                              face_selector_ew,                         &
                                              face_selector_ns) )

      !=======================================================================!
      ! Compute departure points

      ! Set winds for computing departure points based on cheap update flag
      if (any_vert_dep_dist .OR. any_horz_dep_dist) then
        call dep_pt_wind_n%initialise( wind_n%get_function_space() )
        call dep_pt_wind_np1%initialise( wind_np1%get_function_space() )
        if ( cheap_update .AND. outer > 1 ) then
          ! Set up winds for cheap update with FFSL/SL
          call invoke( aX_minus_bY(dep_pt_wind_n, 0.5_r_tran, wind_np1,        &
                                                  0.5_r_tran, wind_n),         &
                       aX_minus_bY(dep_pt_wind_np1, 0.5_r_tran, wind_np1,      &
                                                    0.5_r_tran, wind_n) )
        else
          ! Use wind_n and wind_np1
          call invoke( setval_X(dep_pt_wind_n, wind_n), &
                       setval_X(dep_pt_wind_np1, wind_np1) )
        end if
      end if

      ! If any vertical scheme is ffsl/sl compute vertical departure points
      if (any_vert_dep_dist) then
        w2v_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2v)
        w2_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2)

        call cfl_dep%initialise( w2_fs )

        ! TODO #4160: this assumes that if any_splitting_vhv=.true.
        ! then all transport uses VHV splitting
        if (any_splitting_vhv) then
          ! If any splitting is VHV then compute departure points with half time step
          half_dt = 0.5_r_tran * cast_dt
          call cfl_dep_half%initialise( w2_fs )
          call calc_vert_dep_pts( self%dep_dist_z_half_w2(mesh_idx),           &
                                  self%frac_wind_z_half(mesh_idx),             &
                                  cfl_dep_half,                                &
                                  dep_pt_wind_n,                               &
                                  dep_pt_wind_np1,                             &
                                  half_dt,                                     &
                                  compute_cfl_dep )
          if (compute_cfl_dep) then
            ! Multiply CFL by 2 to get full CFL
            call invoke( a_times_X(cfl_dep, 2.0_r_tran, cfl_dep_half) )
          end if

          if (log_level() <= LOG_LEVEL_INFO) then
            call lipschitz_vertical%initialise( w2v_fs )
            call invoke( lipschitz_vertical_kernel_type(                       &
                                            lipschitz_vertical,                &
                                            self%dep_dist_z_half_w2(mesh_idx)) )
            call log_field_minmax(LOG_LEVEL_INFO, 'lipschitz_vertical', lipschitz_vertical)
          end if
        else
          ! If splitting is not VHV then compute full departure points
          call calc_vert_dep_pts( self%dep_dist_z_w2(mesh_idx),                &
                                  self%frac_wind_z(mesh_idx),                  &
                                  cfl_dep,                                     &
                                  dep_pt_wind_n,                               &
                                  dep_pt_wind_np1,                             &
                                  cast_dt,                                     &
                                  compute_cfl_dep )

          if (log_level() <= LOG_LEVEL_INFO) then
            call lipschitz_vertical%initialise( w2v_fs )
            call invoke( lipschitz_vertical_kernel_type(                       &
                                            lipschitz_vertical,                &
                                            self%dep_dist_z_w2(mesh_idx)) )
            call log_field_minmax(LOG_LEVEL_INFO, 'lipschitz_vertical', lipschitz_vertical)
          end if
        end if

      end if

      ! If any horizontal scheme is ffsl compute horizontal departure points
      if (any_horz_dep_dist) then
        ! TODO #4160: this assumes that if any_splitting_hvh =.true.
        ! then all transport uses HVH splitting
        w2h_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2h)

        if (any_splitting_hvh) then
          ! If any splitting is VHV then compute departure points with half time step
          half_dt = 0.5_r_tran * cast_dt
          call calc_hori_dep_pts( self%dep_dist_xy_half_w2(mesh_idx),          &
                                  self%frac_wind_xy_half(mesh_idx),            &
                                  dep_pt_wind_n,                               &
                                  dep_pt_wind_np1,                             &
                                  half_dt )

          ! Get the required stencil size from the departure points
          call get_field_minmax(self%dep_dist_xy_half_w2(mesh_idx), dep_min, dep_max)
          self%dep_stencil_extent_xy(mesh_idx) = int( max( abs(dep_max), abs(dep_min) ) )

          if (log_level() <= LOG_LEVEL_INFO) then
            call lipschitz_horizontal%initialise( w2h_fs )
            call invoke( setval_c(lipschitz_horizontal, 0.0_r_tran),           &
                         lipschitz_horizontal_kernel_type(                     &
                                            lipschitz_horizontal,              &
                                            self%dep_dist_xy_half_w2(mesh_idx)) )
            call log_field_minmax(LOG_LEVEL_INFO, 'lipschitz_horizontal', lipschitz_horizontal)
          end if

        else
          call calc_hori_dep_pts( self%dep_dist_xy_w2(mesh_idx),               &
                                  self%frac_wind_xy(mesh_idx),                 &
                                  dep_pt_wind_n,                               &
                                  dep_pt_wind_np1,                             &
                                  cast_dt )

          ! Get the required stencil size from the departure points
          call get_field_minmax(self%dep_dist_xy_w2(mesh_idx), dep_min, dep_max)
          self%dep_stencil_extent_xy(mesh_idx) = int( max( abs(dep_max), abs(dep_min) ) )

          if (log_level() <= LOG_LEVEL_INFO) then
            call lipschitz_horizontal%initialise( w2h_fs )
            call invoke( setval_c(lipschitz_horizontal, 0.0_r_tran),           &
                         lipschitz_horizontal_kernel_type(                     &
                                            lipschitz_horizontal,              &
                                            self%dep_dist_xy_w2(mesh_idx)) )
            call log_field_minmax(LOG_LEVEL_INFO, 'lipschitz_horizontal', lipschitz_horizontal)
          end if
        end if
      end if

      !=======================================================================!
      ! Compute cfls for use in substepping
      if (any_scheme_mol .or. log_level() <= LOG_LEVEL_INFO) then
        if ( subroutine_timers ) call timer('transport.cfl_calculation')

        call cfl%initialise( wind_n%get_function_space() )
        call horizontal_cfl%initialise( self%horizontal_advecting_wind(mesh_idx)%get_function_space() )
        call vertical_cfl%initialise( self%vertical_advecting_wind(mesh_idx)%get_function_space() )
        call sum_horizontal_cfl%initialise( vector_space = &
                  function_space_collection%get_fs(tmp_mesh, element_order, W3) )
        call sum_cfl%initialise( vector_space = &
                  function_space_collection%get_fs(tmp_mesh, element_order, W3) )

        ! Get detj_at_w2 using wind_n
        w2_fs => function_space_collection%get_fs(tmp_mesh, element_order, W2)
        call detj_at_w2_transport%initialise( w2_fs )
        call select_detj_at_w2( wind_n, detj_at_w2_transport )

        call invoke( setval_X(cfl, self%advecting_wind(mesh_idx)),             &
                     inc_X_divideby_Y(cfl, detj_at_w2_transport),              &
                     inc_a_times_X(cast_dt, cfl),                              &
                     split_w2_field_kernel_type(horizontal_cfl,                &
                                                vertical_cfl,                  &
                                                cfl,                           &
                                                face_selector_ew,              &
                                                face_selector_ns) )

        select case(max_vert_cfl_calc)
        ! Calculate the maximum vertical cfl for substepping
        case(max_vert_cfl_calc_uniform)
          call get_field_minmax( vertical_cfl, v_cfl_min, v_cfl_max )
        case(max_vert_cfl_calc_dep_point)
          call hori_cfl_dep%initialise( self%horizontal_advecting_wind(mesh_idx)%get_function_space() )
          call invoke( split_w2_field_kernel_type(hori_cfl_dep,     &
                                                  vertical_cfl,     &
                                                  cfl_dep,          &
                                                  face_selector_ew, &
                                                  face_selector_ns) )
          call get_field_minmax( cfl_dep, v_cfl_min, v_cfl_max )
        case default
          write(log_scratch_space, '(A)') &
            'transport_runtime: maximum vertical CFL method not defined '
          call log_event(log_scratch_space, LOG_LEVEL_ERROR)
        end select

        ! Get the total CFL at each cell - this only works for element_order = 0
        if (element_order == 0_i_def) then
          call invoke( calc_max_cfl_kernel_type(sum_cfl, sum_horizontal_cfl, &
                                                horizontal_cfl, vertical_cfl) )
          call get_field_minmax( sum_horizontal_cfl, h_cfl_min, h_cfl_max )

          call get_field_minmax( sum_cfl, cfl_min, cfl_max )

          self%horizontal_cfl_max(mesh_idx) = max(abs(h_cfl_max), abs(h_cfl_min))
          self%vertical_cfl_max(mesh_idx) = max(abs(v_cfl_max), abs(v_cfl_min))
          self%total_cfl_max(mesh_idx) = max(abs(cfl_max), abs(cfl_min))
        else
          call get_field_minmax( horizontal_cfl, h_cfl_min, h_cfl_max )

          self%horizontal_cfl_max(mesh_idx) = max(abs(h_cfl_max), abs(h_cfl_min))
          self%vertical_cfl_max(mesh_idx) = max(abs(v_cfl_max), abs(v_cfl_min))
          self%total_cfl_max(mesh_idx) = max( self%horizontal_cfl_max(mesh_idx), &
                                              self%vertical_cfl_max(mesh_idx) )
        end if

        write( log_scratch_space, '(A, E16.8)') &
            'Transport: maximum horizontal CFL ', self%horizontal_cfl_max(mesh_idx)
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
        write( log_scratch_space, '(A, E16.8)') &
            'Transport: maximum vertical CFL ', self%vertical_cfl_max(mesh_idx)
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
        write( log_scratch_space, '(A, E16.8)') &
            'Transport: maximum total CFL ', self%total_cfl_max(mesh_idx)
        call log_event( log_scratch_space, LOG_LEVEL_INFO )

        if ( subroutine_timers ) call timer('transport.cfl_calculation')
      end if

      !==========================================================================!
      ! For FFSL schemes we require the transport of a unity field to get
      ! the advective FFSL transport
      if (any_scheme_ffsl) then
        call ffsl_unity_transport_alg(                                         &
                                    self%horizontal_advecting_wind(mesh_idx),  &
                                    self%vertical_advecting_wind(mesh_idx),    &
                                    cast_dt,                                   &
                                    tmp_mesh,                                  &
                                    self%adv_unity_x(mesh_idx),                &
                                    self%adv_unity_y(mesh_idx),                &
                                    self%adv_unity_z(mesh_idx),                &
                                    self%adv_unity_half_x(mesh_idx),           &
                                    self%adv_unity_half_y(mesh_idx),           &
                                    self%adv_unity_half_z(mesh_idx) )

        ! Compute volume fields ("detj") transported in each direction ---------
        ! Can't calculate the following quantities in FFSL unity alg, as they
        ! require the extended mesh remapping, which currently requires this
        ! algorithm, so creating a circular dependency
        if (any_horz_dep_dist .and. any_advective_swift) then
          detj_at_w3 => get_detj_at_w3_r_tran(tmp_mesh%get_id())
          if (any_splitting_hvh) then
            if (extended_mesh) then
              remap_depth = get_required_stencil_depth()
              call remapped_unity%initialise( self%adv_unity_half_x(mesh_idx)%get_function_space() )
              call invoke( setval_X(remapped_unity, self%adv_unity_half_x(mesh_idx)) )
              call self%remap_on_extended_mesh(self%adv_unity_half_x(mesh_idx), &
                                               remapped_unity,                  &
                                               self%rho_monotone_remap,         &
                                               self%rho_enforce_minvalue,       &
                                               self%rho_minvalue, remap_depth)
              call invoke_deep_X_times_Y(self%adv_detj_x_half(mesh_idx),     &
                                        self%adv_unity_half_x(mesh_idx), detj_at_w3)

              call invoke( setval_X(remapped_unity, self%adv_unity_half_y(mesh_idx)) )
              call self%remap_on_extended_mesh(self%adv_unity_half_y(mesh_idx), &
                                               remapped_unity,                  &
                                               self%rho_monotone_remap,         &
                                               self%rho_enforce_minvalue,       &
                                               self%rho_minvalue, remap_depth)
              call invoke_deep_X_times_Y(self%adv_detj_y_half(mesh_idx),     &
                                         self%adv_unity_half_y(mesh_idx), detj_at_w3)
            else
              call invoke( X_times_Y(self%adv_detj_x_half(mesh_idx),         &
                                     self%adv_unity_half_x(mesh_idx),          &
                                     detj_at_w3),                              &
                           X_times_Y(self%adv_detj_y_half(mesh_idx),         &
                                     self%adv_unity_half_y(mesh_idx),          &
                                     detj_at_w3) )
            end if
          else
            if (extended_mesh) then
              remap_depth = get_required_stencil_depth()
              call remapped_unity%initialise( self%adv_unity_x(mesh_idx)%get_function_space() )
              call invoke( setval_X(remapped_unity, self%adv_unity_x(mesh_idx)) )
              call self%remap_on_extended_mesh(self%adv_unity_x(mesh_idx),     &
                                               remapped_unity,                 &
                                               self%rho_monotone_remap,        &
                                               self%rho_enforce_minvalue,      &
                                               self%rho_minvalue, remap_depth)
              call invoke_deep_X_times_Y(self%adv_detj_x(mesh_idx),            &
                                         self%adv_unity_x(mesh_idx), detj_at_w3)

              call invoke( setval_X(remapped_unity, self%adv_unity_y(mesh_idx)) )
              call self%remap_on_extended_mesh(self%adv_unity_y(mesh_idx),     &
                                               remapped_unity,                 &
                                               self%rho_monotone_remap,        &
                                               self%rho_enforce_minvalue,      &
                                               self%rho_minvalue, remap_depth)
              call invoke_deep_X_times_Y(self%adv_detj_y(mesh_idx),            &
                                         self%adv_unity_y(mesh_idx), detj_at_w3)
            else
              call invoke( X_times_Y(self%adv_detj_x(mesh_idx),                &
                                     self%adv_unity_x(mesh_idx),               &
                                     detj_at_w3),                              &
                           X_times_Y(self%adv_detj_y(mesh_idx),                &
                                     self%adv_unity_y(mesh_idx),               &
                                     detj_at_w3) )
            end if
          end if
          ! Compute quantities for outer SWIFT step
          call adv_unity_xy%initialise( detj_at_w3%get_function_space() )
          if (any_splitting_hvh) then
            call ffsl_unity_swift_alg(                                         &
                                    adv_unity_xy,                              &
                                    self%dep_dist_oxy_half_w2(mesh_idx),       &
                                    self%frac_wind_oxy_half(mesh_idx),         &
                                    self%dep_stencil_extent_oxy(mesh_idx),     &
                                    self%horizontal_advecting_wind(mesh_idx),  &
                                    self%adv_detj_x_half(mesh_idx),            &
                                    self%adv_detj_y_half(mesh_idx),            &
                                    dep_pt_stencil_extent,                     &
                                    half_dt)
          else
            call ffsl_unity_swift_alg(                                         &
                                    adv_unity_xy,                              &
                                    self%dep_dist_oxy_w2(mesh_idx),            &
                                    self%frac_wind_oxy(mesh_idx),              &
                                    self%dep_stencil_extent_oxy(mesh_idx),     &
                                    self%horizontal_advecting_wind(mesh_idx),  &
                                    self%adv_detj_x(mesh_idx),                 &
                                    self%adv_detj_y(mesh_idx),                 &
                                    dep_pt_stencil_extent,                     &
                                    cast_dt)
          end if
          ! Compute updated volumes (adv_detj_xy)
          if (any_splitting_hvh) then
            if (extended_mesh) then
              remap_depth = self%dep_stencil_extent_oxy(mesh_idx) &
                          + 2_i_def + max(inner_order, outer_order)
              call self%remap_on_extended_mesh(remapped_unity, adv_unity_xy,   &
                                               self%rho_monotone_remap,        &
                                               self%rho_enforce_minvalue,      &
                                               self%rho_minvalue, remap_depth)
              call invoke_deep_X_times_Y(self%adv_detj_xy_half(mesh_idx),      &
                                         remapped_unity, detj_at_w3)
            else
              call invoke( X_times_Y(self%adv_detj_xy_half(mesh_idx),          &
                                     adv_unity_xy, detj_at_w3) )
            end if
          else
            if (extended_mesh) then
              remap_depth = self%dep_stencil_extent_oxy(mesh_idx) &
                          + 2_i_def + max(inner_order, outer_order)
              call self%remap_on_extended_mesh(remapped_unity, adv_unity_xy,   &
                                               self%rho_monotone_remap,        &
                                               self%rho_enforce_minvalue,      &
                                               self%rho_minvalue, remap_depth)
              call invoke_deep_X_times_Y(self%adv_detj_xy(mesh_idx),           &
                                         remapped_unity, detj_at_w3)
            else
              call invoke( X_times_Y(self%adv_detj_xy(mesh_idx),               &
                                     adv_unity_xy, detj_at_w3) )
            end if
          end if
        end if
      end if

      !==========================================================================!
      ! Compute vertical semi-Lagrangian interpolation coefficients
      if (any_vert_scheme_sl) then
        ! Initialise coefficient fields with array index
        ! (mesh,function_space,coefficient_number)
        ! for the primal mesh only unless SLICE is used
        if ( subroutine_timers ) call timer('transport.calc_sl_coeffs')

        if ( mesh_idx == 1 .OR. any_scheme_slice ) then

          ! Get W3 and Wtheta function space
          w3_fs => function_space_collection%get_fs(tmp_mesh, element_order, W3)
          wt_fs => function_space_collection%get_fs(tmp_mesh, element_order, Wtheta)

          ! Initialise linear coefficients
          if (.not. self%vert_linear_coef(mesh_idx,1,1)%is_initialised()) then
            do i_coef=1, 2
              call self%vert_linear_coef(mesh_idx,1,i_coef)%initialise( vector_space=w3_fs )
              call self%vert_linear_coef(mesh_idx,2,i_coef)%initialise( vector_space=wt_fs )
            end do
          end if

          ! TODO: this assumes that if any_splitting_vhv=.true. then all transport uses VHV splitting
          if (any_splitting_vhv) then
            vhv_split_sl = .true.
          else
            vhv_split_sl = .false.
          end if

          if ( any_reversible_sl .OR. vertical_sl_order == vertical_sl_order_cubic_hermite) then
            ! Compute cubic-Hermite coefficients (as part of vert_cubic_coef/index)
            hermite_sl = .true.

            if (.not. self%vert_cubic_coef(mesh_idx,3,1)%is_initialised()) then
              do i_coef=1, 4
                call self%vert_cubic_coef(mesh_idx,3,i_coef)%initialise(  vector_space=w3_fs )
                call self%vert_cubic_index(mesh_idx,3,i_coef)%initialise( vector_space=w3_fs )
                call self%vert_cubic_coef(mesh_idx,4,i_coef)%initialise(  vector_space=wt_fs )
                call self%vert_cubic_index(mesh_idx,4,i_coef)%initialise( vector_space=wt_fs )
              end do
            end if

            call compute_vert_cubic_coefficients_alg( self%vert_cubic_coef(mesh_idx,3,1:4),  &
                                                      self%vert_cubic_index(mesh_idx,3,1:4), &
                                                      self%vert_linear_coef(mesh_idx,1,1:2), &
                                                      self%vert_cubic_coef(mesh_idx,4,1:4),  &
                                                      self%vert_cubic_index(mesh_idx,4,1:4), &
                                                      self%vert_linear_coef(mesh_idx,2,1:2), &
                                                      self%dep_dist_z_w2(mesh_idx),      &
                                                      self%dep_dist_z_half_w2(mesh_idx), &
                                                      hermite_sl, vhv_split_sl )

          end if

          if ( vertical_sl_order == vertical_sl_order_quintic ) then
            ! Initialise and compute quintic coefficients
            if (.not. self%vert_quintic_coef(mesh_idx,1,1)%is_initialised()) then
              do i_coef=1, 6
                call self%vert_quintic_coef(mesh_idx,1,i_coef)%initialise(  vector_space=w3_fs )
                call self%vert_quintic_index(mesh_idx,1,i_coef)%initialise( vector_space=w3_fs )
                call self%vert_quintic_coef(mesh_idx,2,i_coef)%initialise(  vector_space=wt_fs )
                call self%vert_quintic_index(mesh_idx,2,i_coef)%initialise( vector_space=wt_fs )
              end do
            end if

            call compute_vert_quintic_coefficients_alg( self%vert_quintic_coef(mesh_idx,1,1:6),  &
                                                        self%vert_quintic_index(mesh_idx,1,1:6), &
                                                        self%vert_linear_coef(mesh_idx,1,1:2),   &
                                                        self%vert_quintic_coef(mesh_idx,1,1:6),  &
                                                        self%vert_quintic_index(mesh_idx,1,1:6), &
                                                        self%vert_linear_coef(mesh_idx,1,1:2),   &
                                                        self%dep_dist_z_w2(mesh_idx),            &
                                                        self%dep_dist_z_half_w2(mesh_idx),       &
                                                        vhv_split_sl )
          else
            ! Initialise and compute cubic coefficients
            if (.not. self%vert_cubic_coef(mesh_idx,1,1)%is_initialised()) then
              do i_coef=1, 4
                call self%vert_cubic_coef(mesh_idx,1,i_coef)%initialise(  vector_space=w3_fs )
                call self%vert_cubic_index(mesh_idx,1,i_coef)%initialise( vector_space=w3_fs )
                call self%vert_cubic_coef(mesh_idx,2,i_coef)%initialise(  vector_space=wt_fs )
                call self%vert_cubic_index(mesh_idx,2,i_coef)%initialise( vector_space=wt_fs )
              end do
            end if

            hermite_sl = .false.
            call compute_vert_cubic_coefficients_alg( self%vert_cubic_coef(mesh_idx,1,1:4),   &
                                                      self%vert_cubic_index(mesh_idx,1,1:4),  &
                                                      self%vert_linear_coef(mesh_idx,1,1:2),  &
                                                      self%vert_cubic_coef(mesh_idx,2,1:4),   &
                                                      self%vert_cubic_index(mesh_idx,2,1:4),  &
                                                      self%vert_linear_coef(mesh_idx,2,1:2),  &
                                                      self%dep_dist_z_w2(mesh_idx),           &
                                                      self%dep_dist_z_half_w2(mesh_idx),      &
                                                      hermite_sl, vhv_split_sl )
          end if

          nullify( w3_fs, wt_fs )

        end if

        if ( subroutine_timers ) call timer('transport.calc_sl_coeffs')

      end if ! vertical SL interpolation coefficients

    end do ! loop over meshes

    !==========================================================================!
    ! Dry fields stored for consistent transport of scalars
    self%num_dry_steps = self%compute_num_dry_steps()

    ! Allocate arrays for dry fields
    if ( .not. allocated( self%rho_d ) ) then
      if ( subroutine_timers ) call timer('transport.runtime_allocate')
      ! We allocate fields for the shifted mesh here
      n_meshes = self%n_meshes
      n_steps = self%num_dry_steps
      allocate( self%rho_d(n_meshes, n_steps+1),                               &
                self%dry_mass(n_meshes, n_steps+1),                            &
                self%dry_mass_ffsl_x(n_meshes, n_steps),                       &
                self%dry_mass_ffsl_y(n_meshes, n_steps),                       &
                self%flux(n_meshes, n_steps-1),                                &
                self%dry_flux(n_meshes, n_steps),                              &
                self%tracer_dep_dist_ixy(n_meshes, n_steps),                   &
                self%tracer_dep_dist_oxy(n_meshes, n_steps),                   &
                self%tracer_dep_dist_z(n_meshes, n_steps),                     &
                self%dry_frac_flux_z(n_meshes, n_steps),                       &
                self%dry_frac_flux_ixy(n_meshes, n_steps),                     &
                self%dry_frac_flux_oxy(n_meshes, n_steps),                     &
                self%tracer_stencil_extent_ixy(n_meshes, n_steps),             &
                self%tracer_stencil_extent_oxy(n_meshes, n_steps)              &
      )
      if ( subroutine_timers ) call timer('transport.runtime_allocate')
    end if

    ! Set dry density from start of transport step
    if (present(rho_d_n_rdef)) then
      call rho_d_n%initialise( rho_d_n_rdef%get_function_space() )
      call invoke_copy_to_rtran(rho_d_n, rho_d_n_rdef)
      call self%set_rho_d(rho_d_n, 1)
    end if

    ! Set step counter to be 1
    self%tracer_step_ctr = 1

    nullify(mesh, local_mesh, w2_fs, w3_fs, tmp_mesh, w2h_fs, w2v_fs, &
            w3_2d_fs, face_selector_ew, face_selector_ns)

    if ( subroutine_timers ) call timer('transport.runtime_init')

  end subroutine transport_runtime_initialiser

  !> Finalizer for the transport runtime
  !> @param [in,out] self The transport runtime object
  subroutine destroy_transport_runtime(self)
    implicit none
    type(transport_runtime_type), intent(inout) :: self

    if ( allocated( self%mesh_ids ) )                  deallocate( self%mesh_ids )
    if ( allocated( self%advecting_wind ) )            deallocate( self%advecting_wind )
    if ( allocated( self%horizontal_advecting_wind ) ) deallocate( self%horizontal_advecting_wind )
    if ( allocated( self%vertical_advecting_wind ) )   deallocate( self%vertical_advecting_wind )
    if ( allocated( self%dep_dist_xy_w2 ) )            deallocate( self%dep_dist_xy_w2 )
    if ( allocated( self%dep_dist_xy_half_w2 ) )       deallocate( self%dep_dist_xy_half_w2 )
    if ( allocated( self%dep_dist_oxy_w2 ) )           deallocate( self%dep_dist_oxy_w2 )
    if ( allocated( self%dep_dist_oxy_half_w2 ) )      deallocate( self%dep_dist_oxy_half_w2 )
    if ( allocated( self%dep_dist_z_w2 ) )             deallocate( self%dep_dist_z_w2 )
    if ( allocated( self%frac_wind_z ) )               deallocate( self%frac_wind_z )
    if ( allocated( self%frac_wind_z_half ) )          deallocate( self%frac_wind_z_half )
    if ( allocated( self%frac_wind_xy ) )              deallocate( self%frac_wind_xy )
    if ( allocated( self%frac_wind_xy_half ) )         deallocate( self%frac_wind_xy_half )
    if ( allocated( self%frac_wind_oxy ) )             deallocate( self%frac_wind_oxy )
    if ( allocated( self%frac_wind_oxy_half ) )        deallocate( self%frac_wind_oxy_half )
    if ( allocated( self%adv_unity_x ) )               deallocate( self%adv_unity_x )
    if ( allocated( self%adv_unity_y ) )               deallocate( self%adv_unity_y )
    if ( allocated( self%adv_unity_z ) )               deallocate( self%adv_unity_z )
    if ( allocated( self%adv_unity_half_x ) )          deallocate( self%adv_unity_half_x )
    if ( allocated( self%adv_unity_half_y ) )          deallocate( self%adv_unity_half_y )
    if ( allocated( self%adv_unity_half_z ) )          deallocate( self%adv_unity_half_z )
    if ( allocated( self%adv_detj_x ) )                deallocate( self%adv_detj_x )
    if ( allocated( self%adv_detj_y ) )                deallocate( self%adv_detj_y )
    if ( allocated( self%adv_detj_xy ) )               deallocate( self%adv_detj_xy )
    if ( allocated( self%adv_detj_x_half ) )           deallocate( self%adv_detj_x_half )
    if ( allocated( self%adv_detj_y_half ) )           deallocate( self%adv_detj_y_half )
    if ( allocated( self%adv_detj_xy_half ) )          deallocate( self%adv_detj_xy_half )
    if ( allocated( self%vert_cubic_coef ) )           deallocate( self%vert_cubic_coef )
    if ( allocated( self%vert_cubic_index ) )          deallocate( self%vert_cubic_index )
    if ( allocated( self%vert_quintic_coef ) )         deallocate( self%vert_quintic_coef )
    if ( allocated( self%vert_quintic_index ) )        deallocate( self%vert_quintic_index )
    if ( allocated( self%vert_linear_coef ) )          deallocate( self%vert_linear_coef )
    if ( allocated( self%rho_d ) )                     deallocate( self%rho_d )
    if ( allocated( self%dry_mass ) )                  deallocate( self%dry_mass )
    if ( allocated( self%dry_mass_ffsl_x ) )           deallocate( self%dry_mass_ffsl_x )
    if ( allocated( self%dry_mass_ffsl_y ) )           deallocate( self%dry_mass_ffsl_y )
    if ( allocated( self%flux ) )                      deallocate( self%flux )
    if ( allocated( self%dry_flux ) )                  deallocate( self%dry_flux )
    if ( allocated( self%horizontal_cfl_max ) )        deallocate( self%horizontal_cfl_max )
    if ( allocated( self%vertical_cfl_max ) )          deallocate( self%vertical_cfl_max )
    if ( allocated( self%total_cfl_max ) )             deallocate( self%total_cfl_max )
    if ( allocated( self%tracer_dep_dist_z ) )         deallocate( self%tracer_dep_dist_z )
    if ( allocated( self%tracer_dep_dist_ixy ) )       deallocate( self%tracer_dep_dist_ixy )
    if ( allocated( self%tracer_dep_dist_oxy ) )       deallocate( self%tracer_dep_dist_oxy )
    if ( allocated( self%dry_frac_flux_ixy ) )         deallocate( self%dry_frac_flux_ixy )
    if ( allocated( self%dry_frac_flux_oxy ) )         deallocate( self%dry_frac_flux_oxy )
    if ( allocated( self%dry_frac_flux_z ) )           deallocate( self%dry_frac_flux_z )
    if ( allocated( self%tracer_stencil_extent_ixy ) ) deallocate( self%tracer_stencil_extent_ixy )
    if ( allocated( self%tracer_stencil_extent_oxy ) ) deallocate( self%tracer_stencil_extent_oxy )
    if ( allocated( self%dep_stencil_extent_xy ) )     deallocate( self%dep_stencil_extent_xy )
    if ( allocated( self%dep_stencil_extent_oxy ) )    deallocate( self%dep_stencil_extent_oxy )

  end subroutine destroy_transport_runtime

! ============================================================================ !
! SETTERS
! ============================================================================ !

  !> @brief Sets the dry flux for use in consistent tracer transport
  !> @pre Fields passed to this routine must be on the prime extrusion mesh
  !> @param[in,out] self      The transport_runtime object
  !> @param[in]     dry_flux  Flux field used to transport dry density
  !> @param[in]     step      The step to store the flux for
  subroutine set_dry_flux(self, dry_flux, step)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: dry_flux
    integer(kind=i_def),                   intent(in)    :: step

    type(mesh_type),  pointer :: prime_extrusion_mesh => null()

    ! The dry flux is on the prime extrusion mesh
    prime_extrusion_mesh => dry_flux%get_mesh()

    if (prime_extrusion_mesh%get_id() /= self%mesh_ids(1)) then
      call log_event('Can only set dry fields using fields from the prime extrusion mesh', LOG_LEVEL_ERROR)
    end if

    call dry_flux%copy_field_properties(self%dry_flux(1,step))
    call invoke( setval_X(self%dry_flux(1,step), dry_flux) )

    nullify( prime_extrusion_mesh )

  end subroutine set_dry_flux

  !> @brief Sets a dry density field to use in tracer transport, and computes
  !!        the corresponding mass field
  !> @pre Fields passed to this routine must be on the prime extrusion mesh
  !> @param[in,out] self        The transport_runtime object
  !> @param[in]     rho_d       Dry density field
  !> @param[in]     step        The step to store the dry density for
  subroutine set_rho_d(self, rho_d, step)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: rho_d
    integer(kind=i_def),                   intent(in)    :: step

    logical(kind=l_def)              :: next_step_hori
    type(mesh_type),         pointer :: prime_extrusion_mesh => null()
    type(r_tran_field_type), pointer :: detj => null()
    integer(kind=i_def)              :: w2_fs_idx
    integer(kind=i_def)              :: remap_depth

    ! The dry flux is on the prime extrusion mesh
    prime_extrusion_mesh => rho_d%get_mesh()
    detj => get_detj_at_w3_r_tran(prime_extrusion_mesh%get_id())

    if (prime_extrusion_mesh%get_id() /= self%mesh_ids(1)) then
      call log_event('Can only set dry fields using fields from the prime extrusion mesh', LOG_LEVEL_ERROR)
    end if

    w2_fs_idx = self%direction_w2_fs(step)
    next_step_hori = (step < self%get_num_dry_steps() + 1 .and. &
                      w2_fs_idx == W2H .or. w2_fs_idx == W2)

    if (.not. self%dry_mass(1,step)%is_initialised()) then
      call self%dry_mass(1,step)%initialise( vector_space = rho_d%get_function_space(), &
                                             halo_depth = get_required_stencil_depth() )
      call self%rho_d(1,step)%initialise( vector_space = rho_d%get_function_space(), &
                                          halo_depth = get_required_stencil_depth() )
    end if

    if (extended_mesh .and. next_step_hori) then
      if ( check_any_horizontal_method_mol() ) then
        remap_depth = get_required_stencil_depth()
      else
        ! For consistent transport the cfl may be slightly higher than expected
        ! due to using the dry mass flux to compute departure points, therefore
        ! an extra + 1 is added to remap_depth for safety
        remap_depth = self%get_dep_stencil_extent_xy(self%mesh_ids(1), .false.) &
                    + 2_i_def + max(inner_order, outer_order)
      end if
      call self%remap_on_extended_mesh(self%rho_d(1,step), rho_d, &
                                       self%rho_monotone_remap,   &
                                       self%rho_enforce_minvalue, &
                                       self%rho_minvalue, remap_depth)
      ! Now compute mass field
      ! @todo #4302: replace this with redundant computation
      call invoke_deep_X_times_Y(self%dry_mass(1,step), &
                                 self%rho_d(1,step),    &
                                 detj)

    else
      call invoke( setval_X(self%rho_d(1,step), rho_d), &
                   X_times_Y(self%dry_mass(1,step), rho_d, detj) )
    end if

    nullify( prime_extrusion_mesh, detj )

  end subroutine set_rho_d

  !> @brief Sets a dry density field to use in FFSL tracer transport, and
  !!        computes the corresponding mass field. This should be the dry
  !!        density field from a horizontal x step
  !> @pre Fields passed to this routine must be on the prime extrusion mesh
  !> @param[in,out] self        The transport_runtime object
  !> @param[in]     rho_d       Dry density field
  !> @param[in]     step        The step to store the dry density for
  subroutine set_rho_d_ffsl_x(self, rho_d, step)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: rho_d
    integer(kind=i_def),                   intent(in)    :: step

    type(mesh_type),         pointer :: prime_extrusion_mesh => null()
    type(r_tran_field_type), pointer :: detj => null()
    type(r_tran_field_type)          :: rho_d_ffsl_x
    integer(kind=i_def)              :: remap_depth

    ! The dry flux is on the prime extrusion mesh
    prime_extrusion_mesh => rho_d%get_mesh()
    detj => get_detj_at_w3_r_tran(prime_extrusion_mesh%get_id())

    if (prime_extrusion_mesh%get_id() /= self%mesh_ids(1)) then
      call log_event('Can only set dry fields using fields from the prime extrusion mesh', LOG_LEVEL_ERROR)
    end if

    if (.not. self%dry_mass_ffsl_x(1,step)%is_initialised()) then
      call self%dry_mass_ffsl_x(1,step)%initialise( vector_space = rho_d%get_function_space(), &
                                                    halo_depth = get_required_stencil_depth() )
    end if

    if (extended_mesh) then
      ! First remap rho
      ! As this will be used for computing departure distances, compute to
      ! full stencil depth
      remap_depth = get_required_stencil_depth()
      call self%remap_on_extended_mesh(rho_d_ffsl_x, rho_d,              &
                                       self%rho_monotone_remap,          &
                                       self%rho_enforce_minvalue,        &
                                       self%rho_minvalue, remap_depth)

      ! Now compute mass field
      ! @todo #4302: replace this with redundant computation
      call invoke_deep_X_times_Y(self%dry_mass_ffsl_x(1,step), &
                                 rho_d_ffsl_x, detj)
    else
      call invoke( X_times_Y(self%dry_mass_ffsl_x(1,step), rho_d, detj) )
    end if

    nullify( prime_extrusion_mesh, detj )

  end subroutine set_rho_d_ffsl_x

  !> @brief Sets a dry density field to use in FFSL tracer transport, and
  !!        computes the corresponding mass field. This should be the dry
  !!        density field from a horizontal y step
  !> @pre Fields passed to this routine must be on the prime extrusion mesh
  !> @param[in,out] self        The transport_runtime object
  !> @param[in]     rho_d       Dry density field
  !> @param[in]     step        The step to store the dry density for
  subroutine set_rho_d_ffsl_y(self, rho_d, step)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: rho_d
    integer(kind=i_def),                   intent(in)    :: step

    type(mesh_type),         pointer :: prime_extrusion_mesh => null()
    type(r_tran_field_type), pointer :: detj => null()
    type(r_tran_field_type)          :: rho_d_ffsl_y
    integer(kind=i_def)              :: remap_depth

    ! The dry flux is on the prime extrusion mesh
    prime_extrusion_mesh => rho_d%get_mesh()
    detj => get_detj_at_w3_r_tran(prime_extrusion_mesh%get_id())

    if (prime_extrusion_mesh%get_id() /= self%mesh_ids(1)) then
      call log_event('Can only set dry fields using fields from the prime extrusion mesh', LOG_LEVEL_ERROR)
    end if

    if (.not. self%dry_mass_ffsl_y(1,step)%is_initialised()) then
      call self%dry_mass_ffsl_y(1,step)%initialise( vector_space = rho_d%get_function_space(), &
                                                    halo_depth = get_required_stencil_depth() )
    end if

    if (extended_mesh) then
      ! First remap rho
      ! As this will be used for computing departure distances, compute to
      ! full stencil depth
      remap_depth = get_required_stencil_depth()
      call self%remap_on_extended_mesh(rho_d_ffsl_y, rho_d,              &
                                       self%rho_monotone_remap,          &
                                       self%rho_enforce_minvalue,        &
                                       self%rho_minvalue, remap_depth)
      ! Now compute mass field
      ! @todo #4302: replace this with redundant computation
      call invoke_deep_X_times_Y(self%dry_mass_ffsl_y(1,step), &
                                 rho_d_ffsl_y, detj)
    else
      call invoke( X_times_Y(self%dry_mass_ffsl_y(1,step), rho_d, detj) )
    end if

    nullify( prime_extrusion_mesh, detj )

  end subroutine set_rho_d_ffsl_y

  !> @brief Stores a field at the start of the whole transport step
  !> @param[in,out] self      The transport_runtime object
  !> @param[in]     field_n   Field at start of whole transport step
  subroutine set_field_n(self, field_n)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: field_n

    call field_n%copy_field_properties(self%field_n)
    call invoke( setval_X(self%field_n, field_n) )

  end subroutine set_field_n

  !> @brief Sets fluxes for use in conservative transport
  !> @param[in,out] self      The transport_runtime object
  !> @param[in]     flux      Mass flux for a particular split step
  subroutine set_flux(self, flux)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(r_tran_field_type),               intent(in)    :: flux

    integer(kind=i_def) :: idx

    idx = self%idx_from_mesh_id(flux%get_mesh_id())
    call flux%copy_field_properties(self%flux(idx,self%tracer_step_ctr))
    call invoke( setval_X(self%flux(idx,self%tracer_step_ctr), flux) )

  end subroutine set_flux

! ============================================================================ !
! DRY FIELD ROUTINES
! ============================================================================ !

  !> @brief Restricts the prime mesh dry fields from one transport_runtime
  !!        object to set the dry fields for the prime mesh of another
  !!        transport_runtime object for a coarser mesh.
  !> @param[in,out] self                       Target transport_runtime object
  !> @param[in]     source_transport_runtime   Source transport_runtime object
  subroutine restrict_dry_fields(self, source_transport_runtime)

    use intermesh_constants_mod,   only: get_intermesh_weights_w3_rtran
    use mesh_collection_mod,       only: mesh_collection
    use sci_restrict_mass_w3_kernel_mod, &
                                   only: restrict_mass_w3_kernel_type
    use sci_restrict_scalar_weighted_kernel_mod, &
                                   only: restrict_scalar_weighted_kernel_type
    use sci_restrict_w2_kernel_mod, &
                                   only: restrict_w2_kernel_type
    use sci_restrict_w2h_kernel_mod, &
                                   only: restrict_w2h_kernel_type
    use sci_restrict_w2v_kernel_mod, &
                                   only: restrict_w2v_kernel_type

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    class(transport_runtime_type),         intent(in)    :: source_transport_runtime

    type(function_space_type), pointer :: w2_fs => null()
    type(function_space_type), pointer :: w3_fs => null()
    type(mesh_type),           pointer :: source_mesh => null()
    type(mesh_type),           pointer :: target_mesh => null()
    type(r_tran_field_type),   pointer :: source_rho_d => null()
    type(r_tran_field_type),   pointer :: source_dry_mass => null()
    type(r_tran_field_type),   pointer :: source_dry_mass_ffsl_x => null()
    type(r_tran_field_type),   pointer :: source_dry_mass_ffsl_y => null()
    type(r_tran_field_type),   pointer :: source_dry_flux => null()
    type(r_tran_field_type),   pointer :: weights_w3 => null()
    type(r_tran_field_type),   pointer :: source_detj => null()
    type(r_tran_field_type),   pointer :: target_detj => null()
    type(integer_field_type),  pointer :: face_selector_ew => null()
    type(integer_field_type),  pointer :: face_selector_ns => null()
    type(r_tran_field_type)            :: tmp_rho_d
    type(r_tran_field_type)            :: source_rho_ffsl
    type(r_tran_field_type)            :: target_rho_ffsl
    integer(kind=i_def)                :: source_ncells
    integer(kind=i_def)                :: target_ncells
    integer(kind=i_def)                :: source_mesh_id
    integer(kind=i_def)                :: target_mesh_id
    integer(kind=i_def)                :: step, num_steps, fs_idx
    logical(kind=l_def)                :: any_hori_dep_dist
    integer(kind=i_def)                :: remap_depth

    if ( subroutine_timers ) call timer('transport.runtime_restrict')

    ! N.B. The meshes should not be the same as one another, otherwise the
    ! transport_runtime objects will be the same

    source_mesh_id = source_transport_runtime%get_prime_extrusion_mesh_id()
    target_mesh_id = self%get_prime_extrusion_mesh_id()
    ! Obtain meshes to check that we can coarsen
    source_mesh => mesh_collection%get_mesh(source_mesh_id)
    target_mesh => mesh_collection%get_mesh(target_mesh_id)
    ! Figure out which of the meshes has fewer cells
    source_ncells = source_mesh%get_ncells()
    target_ncells = target_mesh%get_ncells()

    face_selector_ew => get_face_selector_ew(target_mesh_id)
    face_selector_ns => get_face_selector_ns(target_mesh_id)

    target_detj => get_detj_at_w3_r_tran(target_mesh_id)
    source_detj => get_detj_at_w3_r_tran(source_mesh_id)

    if (source_ncells > target_ncells) then
      ! Loop through fields for each step for prime extrusion
      num_steps = source_transport_runtime%get_num_dry_steps()
      do step = 1, num_steps + 1

        ! -------------------------------------------------------------------- !
        ! rho_d and dry_mass
        ! -------------------------------------------------------------------- !
        ! Restrict densities conservatively
        source_rho_d => source_transport_runtime%get_rho_d(source_mesh_id, step)
        weights_w3 => get_intermesh_weights_w3_rtran(source_mesh, target_mesh)
        w3_fs => function_space_collection%get_fs(target_mesh, 0, W3)

        if (.not. self%rho_d(1,step)%is_initialised()) then
          call self%rho_d(1,step)%initialise( vector_space = w3_fs, &
                                              halo_depth=target_mesh%get_halo_depth() )
          call self%dry_mass(1,step)%initialise( vector_space = w3_fs, &
                                                 halo_depth=target_mesh%get_halo_depth() )
        end if

        if (extended_mesh) then
          ! TODO: we should be able to get away with not doing all of these
          ! remappings, based on the direction and last step
          ! Need to remap on the ext. mesh, and make rho and mass consistent
          ! Restrict rho, remap, and then calculate mass
          weights_w3 => get_intermesh_weights_w3_rtran(source_mesh, target_mesh)
          source_rho_d => source_transport_runtime%get_rho_d(source_mesh_id, step)
          if ( check_any_horizontal_method_mol() ) then
            remap_depth = get_required_stencil_depth()
          else
            ! TODO: we should be able to get away with not doing all of these
            ! remappings, based on the direction and last step
            ! Restrict, then remap
            remap_depth = self%get_dep_stencil_extent_xy(self%mesh_ids(1), .false.) &
                        + 2_i_def + max(inner_order, outer_order)
          end if
          ! Restrict and remap rho
          call tmp_rho_d%initialise( vector_space = w3_fs, &
                                     halo_depth=target_mesh%get_halo_depth() )
          call invoke( restrict_scalar_weighted_kernel_type(tmp_rho_d,         &
                                                            source_rho_d,      &
                                                            weights_w3) )
          call self%remap_on_extended_mesh(self%rho_d(1,step), tmp_rho_d,      &
                                           self%rho_monotone_remap,            &
                                           self%rho_enforce_minvalue,          &
                                           self%rho_minvalue, remap_depth)
          ! Now compute mass by multiplying remapped field by det(J)
          ! @todo #4302: replace this with redundant computation
          call invoke_deep_X_times_Y(self%dry_mass(1,step),                    &
                                     self%rho_d(1,step),                       &
                                     target_detj)
        else
          ! Can restrict mass and then obtain density through division
          source_dry_mass => source_transport_runtime%get_dry_mass(source_mesh_id, step)
          call invoke( restrict_mass_w3_kernel_type(self%dry_mass(1,step),     &
                                                    source_dry_mass),          &
                       X_divideby_Y(self%rho_d(1,step), self%dry_mass(1,step), &
                                    target_detj) )
        end if

        ! -------------------------------------------------------------------- !
        ! dry_mass_ffsl: only used with FFSL and only for number of dry steps
        ! -------------------------------------------------------------------- !
        any_hori_dep_dist = check_horz_dep_pts()
        if ( any_hori_dep_dist .and. step < num_steps + 1 ) then
          if ( source_transport_runtime%dry_mass_ffsl_x(1,step)%is_initialised() ) then
            source_dry_mass_ffsl_x => source_transport_runtime%get_dry_mass_ffsl_x(source_mesh_id, step)
            source_dry_mass_ffsl_y => source_transport_runtime%get_dry_mass_ffsl_y(source_mesh_id, step)

            if (.not. self%dry_mass_ffsl_x(1,step)%is_initialised()) then
              call self%dry_mass_ffsl_x(1,step)%initialise( vector_space = w3_fs, &
                                                            halo_depth=target_mesh%get_halo_depth() )
              call self%dry_mass_ffsl_y(1,step)%initialise( vector_space = w3_fs, &
                                                            halo_depth=target_mesh%get_halo_depth() )
            end if

            call source_rho_ffsl%initialise( source_dry_mass_ffsl_x%get_function_space(), &
                                             halo_depth=source_mesh%get_halo_depth() )
            call target_rho_ffsl%initialise( w3_fs, &
                                             halo_depth=target_mesh%get_halo_depth() )

            if (extended_mesh) then
              ! As this will be used for computing departure distances, compute to
              ! full stencil depth
              remap_depth = get_required_stencil_depth()

              ! Restrict and remap rho
              call invoke( X_divideby_Y(source_rho_ffsl,                       &
                                        source_dry_mass_ffsl_x, source_detj),  &
                           restrict_scalar_weighted_kernel_type(               &
                                                    tmp_rho_d,                 &
                                                    source_rho_ffsl,           &
                                                    weights_w3) )
              call self%remap_on_extended_mesh(target_rho_ffsl,                &
                                               tmp_rho_d,                      &
                                               self%rho_monotone_remap,        &
                                               self%rho_enforce_minvalue,      &
                                               self%rho_minvalue, remap_depth)
              ! @todo #4302: replace this with redundant computation
              call invoke_deep_X_times_Y(self%dry_mass_ffsl_x(1, step),        &
                                         target_rho_ffsl,                      &
                                         target_detj)
              call invoke( X_divideby_Y(source_rho_ffsl,                       &
                                        source_dry_mass_ffsl_y, source_detj),  &
                           restrict_scalar_weighted_kernel_type(               &
                                                    tmp_rho_d,                 &
                                                    source_rho_ffsl,           &
                                                    weights_w3) )
              call self%remap_on_extended_mesh(target_rho_ffsl,                &
                                               tmp_rho_d,                      &
                                               self%rho_monotone_remap,        &
                                               self%rho_enforce_minvalue,      &
                                               self%rho_minvalue, remap_depth)
              ! Now remap mass
              ! @todo #4302: replace this with redundant computation
              call invoke_deep_X_times_Y(self%dry_mass_ffsl_y(1, step),        &
                                         target_rho_ffsl,                      &
                                         target_detj)

            else
              ! Can restrict straight into mass fields fields
              call invoke( restrict_mass_w3_kernel_type(                       &
                                                self%dry_mass_ffsl_x(1, step), &
                                                source_dry_mass_ffsl_x),       &
                           restrict_mass_w3_kernel_type(                       &
                                                self%dry_mass_ffsl_y(1, step), &
                                                source_dry_mass_ffsl_y) )

            end if
          end if
        end if

        ! -------------------------------------------------------------------- !
        ! dry_flux: kernel depends on the direction
        ! -------------------------------------------------------------------- !
        if ( step < num_steps + 1 ) then

          source_dry_flux => source_transport_runtime%get_dry_flux(source_mesh_id, step)

          fs_idx = source_dry_flux%which_function_space()
          if (.not. self%dry_flux(1,step)%is_initialised()) then
            w2_fs => function_space_collection%get_fs(target_mesh, 0, fs_idx)
            call self%dry_flux(1,step)%initialise( vector_space = w2_fs )
          end if

          ! Restrict flux, which depends on split direction
          select case ( source_dry_flux%which_function_space() )
          case ( W2 )
            call invoke(                                                       &
                restrict_w2_kernel_type(self%dry_flux(1,step),                 &
                                        source_dry_flux,                       &
                                        face_selector_ew,                      &
                                        face_selector_ns) )
          case ( W2H )
            call invoke(                                                       &
                restrict_w2h_kernel_type(self%dry_flux(1,step),                &
                                         source_dry_flux,                     &
                                         face_selector_ew,                     &
                                         face_selector_ns) )
          case ( W2V )
            call invoke(                                                       &
                restrict_w2v_kernel_type(self%dry_flux(1,step), source_dry_flux) )
          case default
            call log_event('Dry flux space not recognised', LOG_LEVEL_ERROR)
          end select
        end if  ! step is valid for dry flux

      end do  ! loop through steps
    else
      call log_event( 'Can only call restrict_dry_fields when ' // &
                      'target mesh is coarser than source mesh', LOG_LEVEL_ERROR)
    end if

    nullify( source_mesh, target_mesh, source_rho_d, source_dry_mass_ffsl_x,   &
             source_dry_mass_ffsl_y, source_dry_flux, w3_fs, w2_fs,            &
             weights_w3, face_selector_ew, face_selector_ns )

    if ( subroutine_timers ) call timer('transport.runtime_restrict')

  end subroutine restrict_dry_fields

  !> @brief Computes stored dry fields on the shifted mesh for consistent
  !!        transport of Wtheta tracers
  !> @param[in,out] self   The transport_runtime object
  subroutine shift_dry_fields(self)

    use sci_consist_w2_to_sh_w2_kernel_mod, only: consist_w2_to_sh_w2_kernel_type
    use sci_consist_w2h_to_sh_w2h_kernel_mod, only: consist_w2h_to_sh_w2h_kernel_type
    use sci_consist_w2v_to_sh_w2v_kernel_mod, only: consist_w2v_to_sh_w2v_kernel_type
    use psykal_lite_transport_mod,        only: invoke_deep_shift_mass, &
                                                invoke_deep_X_divideby_Y
    use sci_shift_mass_w3_kernel_mod,     only: shift_mass_w3_kernel_type

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self

    integer(kind=i_def)                :: prime_mesh_id, fs_idx, step
    type(mesh_type),           pointer :: prime_extrusion_mesh => null()
    type(mesh_type),           pointer :: shifted_mesh => null()
    type(r_tran_field_type),   pointer :: detj_shifted => null()
    type(r_tran_field_type),   pointer :: detj_prime => null()
    type(r_tran_field_type)            :: rho_d_prime
    type(r_tran_field_type)            :: rho_d_shifted
    type(integer_field_type),  pointer :: face_selector_ew => null()
    type(integer_field_type),  pointer :: face_selector_ns => null()
    type(function_space_type), pointer :: w3_fs => null()
    type(function_space_type), pointer :: w2_fs => null()
    logical(kind=l_def)                :: any_hori_dep_dist

    if ( subroutine_timers ) call timer('transport.runtime_shift')

    any_hori_dep_dist = check_horz_dep_pts()

    if (self%n_meshes > 1) then
      prime_extrusion_mesh => mesh_collection%get_mesh(self%mesh_ids(1))
      prime_mesh_id = prime_extrusion_mesh%get_id()
      shifted_mesh => mesh_collection%get_mesh(self%mesh_ids(2))

      detj_shifted => get_detj_at_w3_r_tran(shifted_mesh%get_id())
      detj_prime => get_detj_at_w3_r_tran(prime_mesh_id)
      w3_fs => function_space_collection%get_fs(shifted_mesh, 0, W3)

      face_selector_ew => get_face_selector_ew(prime_mesh_id)
      face_selector_ns => get_face_selector_ns(prime_mesh_id)

      do step = 1, self%num_dry_steps + 1

        ! -------------------------------------------------------------------- !
        ! rho_d and dry_mass
        ! -------------------------------------------------------------------- !
        if (.not. self%rho_d(2,step)%is_initialised()) then
          call self%rho_d(2,step)%initialise( vector_space = w3_fs, &
                                 halo_depth=shifted_mesh%get_halo_depth() )
          call self%dry_mass(2,step)%initialise( vector_space = w3_fs, &
                                 halo_depth=shifted_mesh%get_halo_depth() )
        end if

        if (extended_mesh) then
          ! Original field has already been remapped, so can perform a "deep"
          ! shift on the original field to get the shifted, remapped density
          ! @todo #4302: replace this with redundant computation
          call invoke_deep_shift_mass(self%dry_mass(2,step),                   &
                                      self%dry_mass(1,step))
          call invoke_deep_X_divideby_Y(self%rho_d(2,step),                    &
                                        self%dry_mass(2,step),                 &
                                        detj_shifted)
        else
          ! Can directly shift mass, then obtain rho by dividing by volume
          call invoke( shift_mass_w3_kernel_type(self%dry_mass(2,step),        &
                                                 self%dry_mass(1,step)),       &
                       X_divideby_Y(self%rho_d(2,step), self%dry_mass(2,step), &
                                    detj_shifted) )
        end if

        ! -------------------------------------------------------------------- !
        ! dry_mass_ffsl: only used with FFSL and only for number of dry steps
        ! -------------------------------------------------------------------- !
        if ( any_hori_dep_dist .and. step < self%num_dry_steps + 1 ) then
          if ( self%dry_mass_ffsl_x(1,step)%is_initialised() ) then
            if (.not. self%dry_mass_ffsl_x(2,step)%is_initialised()) then
              call self%dry_mass_ffsl_x(2,step)%initialise( vector_space = w3_fs, &
                                        halo_depth=shifted_mesh%get_halo_depth() )
              call self%dry_mass_ffsl_y(2,step)%initialise( vector_space = w3_fs, &
                                        halo_depth=shifted_mesh%get_halo_depth() )
            end if

            call rho_d_prime%initialise( self%dry_mass_ffsl_x(1,step)%get_function_space(), &
                                         halo_depth=prime_extrusion_mesh%get_halo_depth() )
            call rho_d_shifted%initialise( w3_fs, &
                                         halo_depth=shifted_mesh%get_halo_depth() )

            if (extended_mesh) then
              ! Mass should already correspond to remapped density
              ! Rather than remapping, perform deep shifting of mass into halos
              ! @todo #4302: replace this with redundant computation
              call invoke_deep_shift_mass(self%dry_mass_ffsl_x(2,step),        &
                                          self%dry_mass_ffsl_x(1,step))
              call invoke_deep_shift_mass(self%dry_mass_ffsl_y(2,step),        &
                                          self%dry_mass_ffsl_y(1,step))

            else
              ! Can just directly shift mass
              call invoke( shift_mass_w3_kernel_type(                          &
                                               self%dry_mass_ffsl_x(2,step),   &
                                               self%dry_mass_ffsl_x(1,step)),  &
                           shift_mass_w3_kernel_type(                          &
                                               self%dry_mass_ffsl_y(2,step),   &
                                               self%dry_mass_ffsl_y(1,step)) )
            end if
          end if
        end if


        ! -------------------------------------------------------------------- !
        ! dry_flux: kernel depends on the direction
        ! -------------------------------------------------------------------- !
        if ( step < self%num_dry_steps + 1 ) then
          ! Transform dry fluxes to the shifted mesh, with case depending on fs_idx
          fs_idx = self%dry_flux(1,step)%which_function_space()

          if (.not. self%dry_flux(2,step)%is_initialised()) then
            w2_fs => function_space_collection%get_fs(shifted_mesh, 0, fs_idx)
            call self%dry_flux(2,step)%initialise( vector_space = w2_fs )
          end if

          select case (fs_idx)
          case (W2)
            call invoke(                                              &
              setval_c(self%dry_flux(2,step), 0.0_r_tran),            &
              consist_w2_to_sh_w2_kernel_type(self%dry_flux(2,step),  &
                                              self%dry_flux(1,step),  &
                                              face_selector_ew,       &
                                              face_selector_ns) )
          case (W2h)
            call invoke(                                               &
              setval_c(self%dry_flux(2,step), 0.0_r_tran),             &
              consist_w2h_to_sh_w2h_kernel_type(self%dry_flux(2,step), &
                                                self%dry_flux(1,step), &
                                                face_selector_ew,      &
                                                face_selector_ns) )
          case (W2v)
            call invoke(                                               &
              consist_w2v_to_sh_w2v_kernel_type(self%dry_flux(2,step), &
                                                self%dry_flux(1,step)) )
          case default
            call log_event( "Can only store dry flux for W2, W2h and W2v spaces", LOG_LEVEL_ERROR )
          end select
        end if  ! step is valid for dry flux

      end do  ! loop through steps
    end if  ! there is a shifted mesh

    nullify( prime_extrusion_mesh, shifted_mesh, detj_shifted, detj_prime, &
             w3_fs, w2_fs, face_selector_ew, face_selector_ns )

    if ( subroutine_timers ) call timer('transport.runtime_shift')

  end subroutine shift_dry_fields

  !> @brief Computes quantities (such as departure points) necessary for the
  !!        consistent transport of tracers using FFSL
  !> @param[in,out] self   The transport_runtime object
  !> @param[in]     mesh   The mesh to compute consistent quantities on
  subroutine compute_consistent_quantities(self, mesh)

    use base_mesh_config_mod,                 only: topology, geometry,        &
                                                    topology_fully_periodic,   &
                                                    geometry_spherical
    use hori_dep_dist_ffsl_kernel_mod,        only: hori_dep_dist_ffsl_kernel_type
    use vert_dep_dist_ffsl_kernel_mod,        only: vert_dep_dist_ffsl_kernel_type
    use departure_points_config_mod,          only: horizontal_limit, &
                                                    horizontal_limit_cap
    use psykal_lite_transport_mod,            only: invoke_ffsl_panel_swap_kernel_type

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self
    type(mesh_type),                       intent(in)    :: mesh

    integer(kind=i_def)                :: mesh_id, i, step
    integer(kind=i_def)                :: function_space
    integer(kind=i_def)                :: stencil_extent
    integer(kind=i_def)                :: max_stencil_extent
    real(kind=r_tran)                  :: dep_min, dep_max
    type(mesh_type),           pointer :: twod_mesh => null()
    type(function_space_type), pointer :: w2_fs => null()
    type(function_space_type), pointer :: w3_2d_fs => null()
    type(r_tran_field_type),   pointer :: dry_mass => null()
    type(r_tran_field_type),   pointer :: dry_mass_copy => null()
    type(r_tran_field_type),   pointer :: dry_mass_x => null()
    type(r_tran_field_type),   pointer :: dry_mass_y => null()
    type(r_tran_field_type),   pointer :: dry_flux => null()
    type(field_type),          pointer :: panel_id => null()
    type(integer_field_type),  pointer :: face_selector_ew => null()
    type(integer_field_type),  pointer :: face_selector_ns => null()
    logical(kind=l_def)                :: any_eqn_consistent, cap_dep_points
    logical(kind=l_def)                :: any_vert_dep_dist, any_hori_dep_dist
    logical(kind=l_def)                :: any_consistent_swift
    logical(kind=l_def)                :: any_consistent_cosmic
    character(len=str_def)             :: field_name

    if ( subroutine_timers ) call timer('transport.runtime_consistent')

    any_eqn_consistent = check_any_eqn_consistent()
    any_consistent_swift = check_any_consistent_swift()
    any_consistent_cosmic = check_any_consistent_cosmic()
    any_vert_dep_dist = check_vert_dep_pts()
    any_hori_dep_dist = check_horz_dep_pts()

    if (any_consistent_swift .or. any_consistent_cosmic .or. &
        (any_eqn_consistent .and. any_vert_dep_dist)) then

      mesh_id = mesh%get_id()
      i = self%idx_from_mesh_id(mesh_id)
      panel_id => get_panel_id(mesh_id)
      face_selector_ew => get_face_selector_ew(mesh_id)
      face_selector_ns => get_face_selector_ns(mesh_id)

      do step = 1, self%num_dry_steps

        dry_mass => self%get_dry_mass(mesh_id, step)
        dry_mass_copy => self%get_dry_mass(mesh_id, step)
        dry_flux => self%get_dry_flux(mesh_id, step)
        ! Check that mass isn't negative
        write(field_name, '(A,I4)') 'dry_mass', step
        call self%check_negative_field(dry_mass, field_name)

        ! Determine direction of step from function space
        function_space = dry_flux%which_function_space()
        stencil_extent = dep_pt_stencil_extent

        ! -------------------------------------------------------------------- !
        ! Vertical step
        ! -------------------------------------------------------------------- !
        if (function_space == W2V .and. any_vert_dep_dist) then
          if (.not. self%tracer_dep_dist_z(i,step)%is_initialised()) then
            w2_fs => dry_flux%get_function_space()
            call self%tracer_dep_dist_z(i,step)%initialise( w2_fs )
            call self%dry_frac_flux_z(i,step)%initialise( w2_fs )
          end if

          call invoke( vert_dep_dist_ffsl_kernel_type(                         &
                                          self%tracer_dep_dist_z(i,step),      &
                                          self%dry_frac_flux_z(i,step),        &
                                          dry_flux,                            &
                                          dry_mass) )

          call log_field_minmax(LOG_LEVEL_DEBUG, 'tracer_dep_dist_z', &
                                self%tracer_dep_dist_z(i,step))
        ! -------------------------------------------------------------------- !
        ! Horizontal step
        ! -------------------------------------------------------------------- !
        else if (function_space == W2H .and. any_hori_dep_dist) then

          cap_dep_points = (horizontal_limit == horizontal_limit_cap)

          ! Inner step quantities ----------------------------------------------
          if (.not. self%tracer_dep_dist_ixy(i,step)%is_initialised()) then
            w2_fs => dry_flux%get_function_space()
            twod_mesh => mesh_collection%get_mesh(mesh, TWOD)
            w3_2d_fs => function_space_collection%get_fs(twod_mesh, 0, W3)
            call self%tracer_dep_dist_ixy(i,step)%initialise( w2_fs )
            call self%dry_frac_flux_ixy(i,step)%initialise( w2_fs )
          end if

          ! Compute tracer departure points
          call invoke(                                                         &
                  setval_c(self%tracer_dep_dist_ixy(i,step), 0.0_r_tran),      &
                  setval_c(self%dry_frac_flux_ixy(i,step), 0.0_r_tran),        &
                  hori_dep_dist_ffsl_kernel_type(                              &
                                          self%tracer_dep_dist_ixy(i,step),    &
                                          self%dry_frac_flux_ixy(i,step),      &
                                          dry_flux,                            &
                                          dry_mass, stencil_extent,            &
                                          dry_mass_copy, stencil_extent,       &
                                          face_selector_ew,                    &
                                          face_selector_ns,                    &
                                          dep_pt_stencil_extent,               &
                                          cap_dep_points) )

          ! Get the required stencil size from the departure points
          call get_field_minmax(self%tracer_dep_dist_ixy(i,step), dep_min, dep_max)
          self%tracer_stencil_extent_ixy(i,step) = &
            MAX( int(abs(dep_max), i_def), int(abs(dep_min), i_def) )

          call log_field_minmax(LOG_LEVEL_DEBUG, 'tracer_dep_dist_ixy', &
                                self%tracer_dep_dist_ixy(i,step))

          ! Outer step quantities ----------------------------------------------
          ! Determine if outer fields needed from initialisation of dry_mass_ffsl
          if (any_consistent_swift) then
            if (.not. self%tracer_dep_dist_oxy(i,step)%is_initialised()) then
              w2_fs => dry_flux%get_function_space()
              twod_mesh => mesh_collection%get_mesh(mesh, TWOD)
              w3_2d_fs => function_space_collection%get_fs(twod_mesh, 0, W3)
              call self%tracer_dep_dist_oxy(i,step)%initialise( w2_fs )
              call self%dry_frac_flux_oxy(i,step)%initialise( w2_fs )
            end if

            dry_mass_x => self%get_dry_mass_ffsl_x(mesh_id, step)
            dry_mass_y => self%get_dry_mass_ffsl_y(mesh_id, step)

            ! Check that mass isn't negative
            write(field_name, '(A,I4)') 'dry_mass_ffsl_x', step
            call self%check_negative_field(dry_mass_x, field_name)
            write(field_name, '(A,I4)') 'dry_mass_ffsl_y', step
            call self%check_negative_field(dry_mass_y, field_name)

            if (topology == topology_fully_periodic &
                .AND. geometry == geometry_spherical) then
              ! Swap the halo values of dry_mass_x and dry_mass_y here: this
              ! reduces the number of different kernels required by FFSL
              max_stencil_extent = get_required_stencil_depth()
              call invoke_ffsl_panel_swap_kernel_type(dry_mass_x, dry_mass_y,    &
                                                      panel_id, max_stencil_extent)
            end if

            ! Compute tracer departure points
            call invoke(                                                       &
                    setval_c(self%tracer_dep_dist_oxy(i,step), 0.0_r_tran),    &
                    setval_c(self%dry_frac_flux_oxy(i,step), 0.0_r_tran),      &
                    hori_dep_dist_ffsl_kernel_type(                            &
                                            self%tracer_dep_dist_oxy(i,step),  &
                                            self%dry_frac_flux_oxy(i,step),    &
                                            dry_flux,                          &
                                            dry_mass_y, stencil_extent,        &
                                            dry_mass_x, stencil_extent,        &
                                            face_selector_ew,                  &
                                            face_selector_ns,                  &
                                            dep_pt_stencil_extent,             &
                                            cap_dep_points) )

            call log_field_minmax(LOG_LEVEL_DEBUG, 'tracer_dep_dist_oxy', &
                                  self%tracer_dep_dist_oxy(i,step))

            ! Get the required stencil size from the departure points
            call get_field_minmax(self%tracer_dep_dist_oxy(i,step), dep_min, dep_max)
            self%tracer_stencil_extent_oxy(i,step) = &
              MAX( int(abs(dep_max), i_def), int(abs(dep_min), i_def) )

          end if  ! Outer step variables
        end if  ! Horizontal
      end do  ! Loop through steps
    end if  ! Whether consistent quantities need computing

    nullify(w2_fs, w3_2d_fs, dry_mass, dry_mass_x, dry_mass_y, &
            dry_flux, twod_mesh, panel_id, face_selector_ew, face_selector_ns)

    if ( subroutine_timers ) call timer('transport.runtime_consistent')

  end subroutine compute_consistent_quantities

! ============================================================================ !
! GETTERS
! ============================================================================ !

  !> @brief Computes number of MoL substeps for a splitting step
  !> @param[in] self       The transport_runtime object
  !> @param[in] mesh_id    Identifier of mesh
  !> @param[in] direction  A transport direction enumerator
  !> @param[in] splitting  A transport splitting enumerator
  !> @param[in] cfl_arg    CFL to use. Optional, and if not provided defaults
  !!                       to namelist options.
  !> @return number_substeps  Number of substeps
  function get_number_substeps(self, mesh_id, direction, splitting, cfl_arg) result(number_substeps)
    use transport_config_mod,           only: cfl_mol_3d_stab, &
                                              cfl_mol_2d_stab, &
                                              cfl_mol_1d_stab
    implicit none

    class(transport_runtime_type), intent(in) :: self
    integer(kind=i_def),           intent(in) :: mesh_id
    integer(kind=i_def),           intent(in) :: direction
    integer(kind=i_def),           intent(in) :: splitting
    real(kind=r_def),   optional,  intent(in) :: cfl_arg
    integer(kind=i_def)                       :: number_substeps
    integer(kind=i_def)                       :: idx
    real(kind=r_def)                          :: cfl_to_use

    idx = self%idx_from_mesh_id(mesh_id)

    if (present(cfl_arg)) then
      cfl_to_use = cfl_arg + tiny_eps
    else
      select case (direction)
      case (direction_v)
        cfl_to_use = cfl_mol_1d_stab + tiny_eps
      case (direction_h)
        cfl_to_use = cfl_mol_2d_stab+tiny_eps
      case (direction_3d)
        cfl_to_use = cfl_mol_3d_stab+tiny_eps
      case default
        call log_event('Direction not recognised', LOG_LEVEL_ERROR)
      end select
    end if

    select case (direction)

      case (direction_v)
        number_substeps = int( self%vertical_cfl_max(idx) / cfl_to_use, i_def) &
                         + 1_i_def
        ! Strang_vhv splitting uses half timestep for the vertical stage
        if ( splitting == splitting_strang_vhv ) then
          number_substeps = int( self%vertical_cfl_max(idx)        &
                              /(2.0_r_tran*cfl_to_use),i_def) &
                          + 1_i_def
        end if
      case (direction_h)
        number_substeps = int( self%horizontal_cfl_max(idx)      &
                              / cfl_to_use, i_def) &
                        + 1_i_def
        ! Strang_hvh splitting uses half timestep for the horizontal stage
        if ( splitting == splitting_strang_hvh ) then
          number_substeps = int( self%horizontal_cfl_max(idx)        &
                              /(2.0_r_tran*cfl_to_use),i_def) &
                          + 1_i_def
        end if

      case (direction_3d)
        number_substeps = int( self%total_cfl_max(idx)            &
                              / cfl_to_use, i_def)  &
                         + 1_i_def
      case default
        number_substeps = 1_i_def
    end select

  end function get_number_substeps

  !> @brief Get the MoL dt for substeps for this mesh / direction / splitting
  !> @param[in] self       The transport_runtime object
  !> @param[in] mesh_id    Identifier of mesh
  !> @param[in] direction  A transport direction enumerator
  !> @param[in] splitting  A transport splitting enumerator
  !> @return dt_substep  The dt for MoL substeps
  function get_dt_substep(self, mesh_id, direction, splitting) result(dt_substep)

    implicit none

    class(transport_runtime_type), intent(in) :: self
    integer(kind=i_def),           intent(in) :: mesh_id
    integer(kind=i_def),           intent(in) :: direction
    integer(kind=i_def),           intent(in) :: splitting
    integer(kind=i_def)                       :: number_substeps
    real(kind=r_tran)                         :: dt_substep

    number_substeps = self%get_number_substeps(mesh_id, direction, splitting)
    dt_substep = real(self%model_clock%get_seconds_per_step(), r_tran) &
                 / real(number_substeps, r_tran)
    if ( splitting  == splitting_strang_vhv .and. direction == direction_v ) then
        dt_substep = dt_substep / 2.0_r_tran
    else if ( splitting  == splitting_strang_hvh .and. direction == direction_h ) then
        dt_substep = dt_substep / 2.0_r_tran
    end if

  end function get_dt_substep

  !> @brief Returns the local mesh id for the transport_runtime
  !> @return The identifier for the underlying local mesh
  function get_local_mesh_id(self) result(local_mesh_id)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def)                               :: local_mesh_id

    local_mesh_id = self%local_mesh_id

  end function get_local_mesh_id

  !> @brief Returns the mesh id for the transport_runtime prime extrusion mesh
  !> @return The identifier for the prime extrusion mesh
  function get_prime_extrusion_mesh_id(self) result(prime_extrusion_mesh_id)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def)                               :: prime_extrusion_mesh_id

    prime_extrusion_mesh_id = self%mesh_ids(1)

  end function get_prime_extrusion_mesh_id

  !> @brief Returns a pointer to the advecting wind
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The advecting wind for that mesh
  function get_advecting_wind(self, mesh_id) result(advecting_wind)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'advecting_wind'
    advecting_wind => self%advecting_wind(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_advecting_wind

  !> @brief Returns a pointer to the advecting wind associated with a direction
  !> @param[in] mesh_id    The ID of the mesh to get the object for
  !> @param[in] direction  The enumerator for the direction
  !> @return The advecting wind for that mesh and specified direction
  function get_directional_advecting_wind(self, mesh_id, direction) result(advecting_wind)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: direction
    type(r_tran_field_type),               pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'directional_advecting_wind'

    select case (direction)
    case (direction_3d)
      advecting_wind => self%advecting_wind(self%idx_from_mesh_id(mesh_id))
    case (direction_h)
      advecting_wind => self%horizontal_advecting_wind(self%idx_from_mesh_id(mesh_id))
    case (direction_v)
      advecting_wind => self%vertical_advecting_wind(self%idx_from_mesh_id(mesh_id))
    case default
      call log_event('get_directional_advecting_wind: Direction not recognised', LOG_LEVEL_ERROR)
    end select

    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_directional_advecting_wind

   !> @brief Returns a pointer to the horizontal advecting wind
   !> @param[in] mesh_id The ID of the mesh to get the object for
   !> @return The horizontal part of the advecting wind
  function get_horizontal_advecting_wind(self, mesh_id) result(advecting_wind)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'horizontal_advecting_wind'
    advecting_wind => self%horizontal_advecting_wind(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_horizontal_advecting_wind

  !> @brief Returns a pointer to the vertical advecting wind
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The vertical part of the advecting wind
  function get_vertical_advecting_wind(self, mesh_id) result(advecting_wind)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    type(r_tran_field_type),               pointer    :: advecting_wind
    character(str_def)                                :: field_name

    field_name = 'vertical_advecting_wind'
    advecting_wind => self%vertical_advecting_wind(self%idx_from_mesh_id(mesh_id))
    call check_initialised_field(advecting_wind, field_name, mesh_id)

  end function get_vertical_advecting_wind

  !> @brief Returns a pointer to the horizontal departure distances at W2h DoFs
  !> @param[in] mesh_id     The ID of the mesh to get the object for
  !> @param[in] strang      Logical for whether to return Strang split points
  !> @param[in] outer_step  Logical for whether to return points for outer step
  !> @return The departure distances at W2h DoFs
  function get_dep_dist_xy_w2(self, mesh_id, strang, outer_step) result(dep_dist_xy_w2)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    logical(kind=l_def),                   intent(in) :: outer_step
    type(r_tran_field_type),               pointer    :: dep_dist_xy_w2
    character(str_def)                                :: field_name

    field_name = 'dep_dist_xy_w2'
    if (strang .and. outer_step) then
      dep_dist_xy_w2 => self%dep_dist_oxy_half_w2(self%idx_from_mesh_id(mesh_id))
    else if (strang) then
      dep_dist_xy_w2 => self%dep_dist_xy_half_w2(self%idx_from_mesh_id(mesh_id))
    else if (outer_step) then
      dep_dist_xy_w2 => self%dep_dist_oxy_w2(self%idx_from_mesh_id(mesh_id))
    else
      dep_dist_xy_w2 => self%dep_dist_xy_w2(self%idx_from_mesh_id(mesh_id))
    end if
    call check_initialised_field(dep_dist_xy_w2, field_name, mesh_id)

  end function get_dep_dist_xy_w2


  !> @brief Returns a pointer to the z departure distances at W2v DoFs
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] strang  Logical for whether to return Strang split distances
  !> @return The departure distances for the z direction at W2v DoFs
  function get_dep_dist_z_w2(self, mesh_id, strang) result(dep_dist_z_w2)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    type(r_tran_field_type),               pointer    :: dep_dist_z_w2
    character(str_def)                                :: field_name

    field_name = 'dep_dist_z_w2'
    if (strang) then
      dep_dist_z_w2 => self%dep_dist_z_half_w2(self%idx_from_mesh_id(mesh_id))
    else
      dep_dist_z_w2 => self%dep_dist_z_w2(self%idx_from_mesh_id(mesh_id))
    end if
    call check_initialised_field(dep_dist_z_w2, field_name, mesh_id)

  end function get_dep_dist_z_w2

  !> @brief Returns a pointer to the detj_at_w3 field transported in x
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] strang  Logical for whether to return Strang split volume
  !> @return The cell volume after transport in x
  function get_adv_detj_x(self, mesh_id, strang) result(detj_at_w3)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    type(r_tran_field_type),               pointer    :: detj_at_w3
    character(str_def)                                :: field_name

    field_name = 'adv_detj_x'
    if (strang) then
      detj_at_w3 => self%adv_detj_x_half(self%idx_from_mesh_id(mesh_id))
    else
      detj_at_w3 => self%adv_detj_x(self%idx_from_mesh_id(mesh_id))
    end if
    call check_initialised_field(detj_at_w3, field_name, mesh_id)

  end function get_adv_detj_x

  !> @brief Returns a pointer to the detj_at_w3 field transported in y
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] strang  Logical for whether to return Strang split volume
  !> @return The cell volume after transport in y
  function get_adv_detj_y(self, mesh_id, strang) result(detj_at_w3)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    type(r_tran_field_type),               pointer    :: detj_at_w3
    character(str_def)                                :: field_name

    field_name = 'adv_detj_y'
    if (strang) then
      detj_at_w3 => self%adv_detj_y_half(self%idx_from_mesh_id(mesh_id))
    else
      detj_at_w3 => self%adv_detj_y(self%idx_from_mesh_id(mesh_id))
    end if
    call check_initialised_field(detj_at_w3, field_name, mesh_id)

  end function get_adv_detj_y

  !> @brief Returns a pointer to the detj_at_w3 field transported in x and y
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] strang  Logical for whether to return Strang split volume
  !> @return The cell volume after transport in x and y
  function get_adv_detj_xy(self, mesh_id, strang) result(detj_at_w3)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    type(r_tran_field_type),               pointer    :: detj_at_w3
    character(str_def)                                :: field_name

    field_name = 'adv_detj_xy'
    if (strang) then
      detj_at_w3 => self%adv_detj_xy_half(self%idx_from_mesh_id(mesh_id))
    else
      detj_at_w3 => self%adv_detj_xy(self%idx_from_mesh_id(mesh_id))
    end if
    call check_initialised_field(detj_at_w3, field_name, mesh_id)

  end function get_adv_detj_xy

  !> @brief Returns a pointer to the fractional vertical wind
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] strang  Logical as to whether to return VHV frac wind
  !> @return The fractional vertical wind at W2v DOFs
  function get_frac_wind_z(self, mesh_id, strang) result(frac_wind_z)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    type(r_tran_field_type),               pointer    :: frac_wind_z

    if (strang) then
      frac_wind_z => self%frac_wind_z_half(self%idx_from_mesh_id(mesh_id))
    else
      frac_wind_z => self%frac_wind_z(self%idx_from_mesh_id(mesh_id))
    end if

  end function get_frac_wind_z

  !> @brief Returns a pointer to the fractional horizontal wind flux
  !> @param[in] mesh_id     The ID of the mesh to get the object for
  !> @param[in] strang      Logical for whether values are from HVH splitting
  !> @param[in] outer_step  Logical for whether wind is from outer step
  !> @return The fractional wind flux at W2h DOFs
  function get_frac_wind_xy(self, mesh_id, strang, outer_step) result(frac_wind_xy)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    logical(kind=l_def),                   intent(in) :: outer_step
    type(r_tran_field_type),               pointer    :: frac_wind_xy

    if (strang .and. outer_step) then
      frac_wind_xy => self%frac_wind_oxy_half(self%idx_from_mesh_id(mesh_id))
    else if (strang) then
      frac_wind_xy => self%frac_wind_xy_half(self%idx_from_mesh_id(mesh_id))
    else if (outer_step) then
      frac_wind_xy => self%frac_wind_oxy(self%idx_from_mesh_id(mesh_id))
    else
      frac_wind_xy => self%frac_wind_xy(self%idx_from_mesh_id(mesh_id))
    end if

  end function get_frac_wind_xy

  !> @brief Returns a pointer to the consistent tracer departure points
  !> @param[in] mesh_id      The ID of the mesh to get the object for
  !> @param[in] step         The split step to get the departure points for
  !> @param[in] outer_step   Logical denoting outer SWIFT step
  !> @return The tracer departure points at W2 DoFs
  function get_tracer_dep_dist_xy(self, mesh_id, step, outer_step) result(tracer_dep_points_xy)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    logical(kind=l_def),                   intent(in) :: outer_step
    type(r_tran_field_type),               pointer    :: tracer_dep_points_xy
    character(str_def)                                :: field_name

    if (outer_step) then
      field_name = 'tracer_dep_points_ox'
      tracer_dep_points_xy => self%tracer_dep_dist_oxy(self%idx_from_mesh_id(mesh_id), step)
    else
      field_name = 'tracer_dep_points_ix'
      tracer_dep_points_xy => self%tracer_dep_dist_ixy(self%idx_from_mesh_id(mesh_id), step)
    end if

    call check_initialised_field(tracer_dep_points_xy, field_name, mesh_id)

  end function get_tracer_dep_dist_xy

  !> @brief Returns a pointer to the consistent z departure points
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step    The split step to get the departure points for
  !> @return The consistent departure points for the z direction at W2 DoFs
  function get_tracer_dep_dist_z(self, mesh_id, step) result(tracer_dep_points_z)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: tracer_dep_points_z
    character(str_def)                                :: field_name

    field_name = 'tracer_dep_points_z'
    tracer_dep_points_z => self%tracer_dep_dist_z(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(tracer_dep_points_z, field_name, mesh_id)

  end function get_tracer_dep_dist_z

  !> @brief Returns a pointer to the dry inner fractional flux
  !> @param[in] mesh_id      The ID of the mesh to get the object for
  !> @param[in] step         The split step to get the fractional flux for
  !> @param[in] outer_step   Logical denoting outer SWIFT step
  !> @return The dry inner fractional flux
  function get_dry_frac_flux_xy(self, mesh_id, step, outer_step) result(dry_frac_flux_xy)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    logical(kind=l_def),                   intent(in) :: outer_step
    type(r_tran_field_type),               pointer    :: dry_frac_flux_xy
    character(str_def)                                :: field_name

    if (outer_step) then
      field_name = 'dry_frac_flux_ox'
      dry_frac_flux_xy => self%dry_frac_flux_oxy(self%idx_from_mesh_id(mesh_id), step)
    else
      field_name = 'dry_frac_flux_ix'
      dry_frac_flux_xy => self%dry_frac_flux_ixy(self%idx_from_mesh_id(mesh_id), step)
    end if

    call check_initialised_field(dry_frac_flux_xy, field_name, mesh_id)

  end function get_dry_frac_flux_xy

  !> @brief Returns a pointer to the consistent z fractional flux
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step    The split step to get the fractional flux for
  !> @return The consistent fractional flux for the z direction
  function get_dry_frac_flux_z(self, mesh_id, step) result(dry_frac_flux_z)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: dry_frac_flux_z
    character(str_def)                                :: field_name

    field_name = 'dry_frac_flux_z'
    dry_frac_flux_z => self%dry_frac_flux_z(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(dry_frac_flux_z, field_name, mesh_id)

  end function get_dry_frac_flux_z

  !> @brief Returns a pointer to the transport of unity in x
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] strang  Logical for whether values are from Strang splitting
  !> @return The update of transport of unity in x
  function get_adv_unity_x(self, mesh_id, strang) result(adv_unity_x)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    type(r_tran_field_type),               pointer    :: adv_unity_x
    character(str_def)                                :: field_name

    field_name = 'adv_unity_x'
    if (strang) then
      adv_unity_x => self%adv_unity_half_x(self%idx_from_mesh_id(mesh_id))
    else
      adv_unity_x => self%adv_unity_x(self%idx_from_mesh_id(mesh_id))
    end if
    call check_initialised_field(adv_unity_x, field_name, mesh_id)

  end function get_adv_unity_x

  !> @brief Returns a pointer to the transport of unity in y
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] strang  Logical for whether values are from Strang splitting
  !> @return The update of transport of unity in y
  function get_adv_unity_y(self, mesh_id, strang) result(adv_unity_y)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    type(r_tran_field_type),               pointer    :: adv_unity_y
    character(str_def)                                :: field_name

    field_name = 'adv_unity_y'
    if (strang) then
      adv_unity_y => self%adv_unity_half_y(self%idx_from_mesh_id(mesh_id))
    else
      adv_unity_y => self%adv_unity_y(self%idx_from_mesh_id(mesh_id))
    end if
    call check_initialised_field(adv_unity_y, field_name, mesh_id)

  end function get_adv_unity_y


  !> @brief Returns a pointer to the transport of unity in z
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] strang  Logical for whether values are from Strang splitting
  !> @return The update of transport of unity in z
  function get_adv_unity_z(self, mesh_id, strang) result(adv_unity_z)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: strang
    type(r_tran_field_type),               pointer    :: adv_unity_z
    character(str_def)                                :: field_name

    field_name = 'adv_unity_z'
    if (strang) then
      adv_unity_z => self%adv_unity_half_z(self%idx_from_mesh_id(mesh_id))
    else
      adv_unity_z => self%adv_unity_z(self%idx_from_mesh_id(mesh_id))
    end if
    call check_initialised_field(adv_unity_z, field_name, mesh_id)

  end function get_adv_unity_z


  !> @brief Returns a pointer to the vertical interpolation coefficients
  !!        for semi-Lagrangian transport of a W3 or Wtheta field
  !> @param[in] field   The field to apply the coefficients to
  !> @param[in] order   The order of the coefficients
  !> @param[in] number  Which coefficient number to get
  !!                    (1-4 for cubic, 1-6 for quintic, 1-2 for linear)
  !> @return The SL interpolation coefficients
  function get_vert_sl_coef(self, field, order, number) result(coef)

    use fs_continuity_mod,             only: W3, Wtheta
    use transport_config_mod,          only: vertical_sl_order_cubic,     &
                                             vertical_sl_order_quintic,   &
                                             vertical_sl_order_cubic_hermite

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    type(r_tran_field_type),               intent(in) :: field
    integer(kind=i_def),                   intent(in) :: order
    integer(kind=i_def),                   intent(in) :: number
    type(r_tran_field_type),               pointer    :: coef

    integer(kind=i_def) :: mesh_id

    ! Get mesh ID
    mesh_id = field%get_mesh_id()

    ! self%vert_cubic/quintic_coef array has index (mesh,function_space,coefficient_number)

    select case ( field%which_function_space() )
    case ( W3 )
      if (order == vertical_sl_order_cubic) then
        ! Cubic coefficients
        coef => self%vert_cubic_coef(self%idx_from_mesh_id(mesh_id), 1, number)
      else if (order == vertical_sl_order_cubic_hermite) then
        ! Cubic-Hermite coefficients
        coef => self%vert_cubic_coef(self%idx_from_mesh_id(mesh_id), 3, number)
      else if (order == vertical_sl_order_quintic) then
        ! Quintic coefficients
        coef => self%vert_quintic_coef(self%idx_from_mesh_id(mesh_id), 1, number)
      else
        ! Linear coefficients
        coef => self%vert_linear_coef(self%idx_from_mesh_id(mesh_id), 1, number)
      end if
    case ( Wtheta )
      if (order == vertical_sl_order_cubic) then
        ! Cubic coefficients
        coef => self%vert_cubic_coef(self%idx_from_mesh_id(mesh_id), 2, number)
      else if (order == vertical_sl_order_cubic_hermite) then
        ! Cubic-Hermite coefficients
        coef => self%vert_cubic_coef(self%idx_from_mesh_id(mesh_id), 4, number)
      else if (order == vertical_sl_order_quintic) then
        ! Quintic coefficients
        coef => self%vert_quintic_coef(self%idx_from_mesh_id(mesh_id), 2, number)
      else
        ! Linear coefficients
        coef => self%vert_linear_coef(self%idx_from_mesh_id(mesh_id), 2, number)
      end if
    case default
      call log_event( "get_vert_sl_coef only valid for W3 & Wtheta spaces", LOG_LEVEL_ERROR )
    end select

  end function get_vert_sl_coef

  !> @brief Returns a pointer to the vertical interpolation indices
  !!        for semi-Lagrangian transport of a W3/Wtheta field
  !> @param[in] field   The field to apply the coefficients to
  !> @param[in] order   The order of the coefficients for the index
  !> @param[in] number  Which coefficient index to get
  !!                    (1-4 for cubic, 1-6 for quintic, 1-2 for linear)
  !> @return The SL indices
  function get_vert_sl_index(self, field, order, number) result(index)

    use fs_continuity_mod,             only: W3, Wtheta
    use transport_config_mod,          only: vertical_sl_order_cubic,     &
                                             vertical_sl_order_quintic,   &
                                             vertical_sl_order_cubic_hermite

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    type(r_tran_field_type),               intent(in) :: field
    integer(kind=i_def),                   intent(in) :: order
    integer(kind=i_def),                   intent(in) :: number
    type(integer_field_type),              pointer    :: index

    integer(kind=i_def) :: mesh_id

    ! Get mesh ID
    mesh_id = field%get_mesh_id()

    ! self%vert_cubic/quintic_index array has index (mesh,function_space,coefficient_number)

    select case ( field%which_function_space() )
    case ( W3 )
      select case ( order )
      case (vertical_sl_order_cubic)
        ! Cubic coefficients index
        index => self%vert_cubic_index(self%idx_from_mesh_id(mesh_id),1,number)
      case (vertical_sl_order_cubic_hermite)
        ! Cubic-Hermite coefficients index
        index => self%vert_cubic_index(self%idx_from_mesh_id(mesh_id),3,number)
      case (vertical_sl_order_quintic)
        ! Quintic coefficients index
        index => self%vert_quintic_index(self%idx_from_mesh_id(mesh_id),1,number)
      end select
    case ( Wtheta )
      select case ( order )
      case (vertical_sl_order_cubic)
        ! Cubic coefficients index
        index => self%vert_cubic_index(self%idx_from_mesh_id(mesh_id),2,number)
      case (vertical_sl_order_cubic_hermite)
        ! Cubic-Hermite coefficients index
        index => self%vert_cubic_index(self%idx_from_mesh_id(mesh_id),4,number)
      case (vertical_sl_order_quintic)
        ! Quintic coefficients index
        index => self%vert_quintic_index(self%idx_from_mesh_id(mesh_id),2,number)
      end select
    case default
      call log_event( "get_vert_sl_index only valid for W3 & Wtheta spaces", LOG_LEVEL_ERROR )
    end select

  end function get_vert_sl_index

  !> @brief Returns a pointer to required stencil size for FFSL transport
  !!        based on the maximum horizontal departure distance
  !> @param[in] mesh_id     The ID of the mesh to get the object for
  !> @param[in] outer_step  Logical indicating whether to return value for outer step
  !> @return The required stencil depth
  function get_dep_stencil_extent_xy(self, mesh_id, outer_step) result(dep_stencil_extent_xy)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    logical(kind=l_def),                   intent(in) :: outer_step
    integer(kind=i_def),                   pointer    :: dep_stencil_extent_xy

    if (outer_step) then
      dep_stencil_extent_xy => self%dep_stencil_extent_oxy(self%idx_from_mesh_id(mesh_id))
    else
      dep_stencil_extent_xy => self%dep_stencil_extent_xy(self%idx_from_mesh_id(mesh_id))
    end if

  end function get_dep_stencil_extent_xy

  !> @brief Returns a pointer to required stencil size for consistent FFSL
  !!        transport based on the maximum horizontal inner departure distance
  !> @param[in] mesh_id      The ID of the mesh to get the object for
  !> @param[in] step         The split step to get the extent for
  !> @param[in] outer_step   Logical denoting outer SWIFT step
  !> @return The required stencil depth
  function get_tracer_stencil_extent_xy(self, mesh_id, step, outer_step) result(dep_stencil_extent_xy)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    logical(kind=l_def),                   intent(in) :: outer_step
    integer(kind=i_def),                   pointer    :: dep_stencil_extent_xy

    if (outer_step) then
      dep_stencil_extent_xy => self%tracer_stencil_extent_oxy(self%idx_from_mesh_id(mesh_id), step)
    else
      dep_stencil_extent_xy => self%tracer_stencil_extent_ixy(self%idx_from_mesh_id(mesh_id), step)
    end if

  end function get_tracer_stencil_extent_xy

  !> @brief Returns number of split transport steps for the dry density
  !> @return The number of split transport steps for the dry density
  function get_num_dry_steps(self) result(num_dry_steps)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def)                               :: num_dry_steps

    num_dry_steps = self%num_dry_steps

  end function get_num_dry_steps

  !> @brief Returns a pointer stored field at the start of the time step
  !> @return The field at the start of the time step
  function get_field_n(self) result(field_n)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    type(r_tran_field_type),               pointer    :: field_n

    field_n => self%field_n

  end function get_field_n

  !> @brief Returns a pointer to a dry density field from FFSL
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the density
  !> @return The dry density field after its transport
  function get_rho_d(self, mesh_id, step) result(rho_d)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: rho_d
    character(str_def)                                :: field_name

    field_name = 'rho_d'
    rho_d => self%rho_d(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(rho_d, field_name, mesh_id)

  end function get_rho_d

  !> @brief Returns a pointer to a dry mass field
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the density
  !> @return The dry mass field after its transport
  function get_dry_mass(self, mesh_id, step) result(dry_mass)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: dry_mass
    character(str_def)                                :: field_name

    field_name = 'dry_mass'
    dry_mass => self%dry_mass(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(dry_mass, field_name, mesh_id)

  end function get_dry_mass

  !> @brief Returns a pointer to a dry density field from an FFSL x-sweep
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the density
  !> @return The dry density field after its transport
  function get_dry_mass_ffsl_x(self, mesh_id, step) result(dry_mass_ffsl)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: dry_mass_ffsl
    character(str_def)                                :: field_name

    field_name = 'dry_mass_ffsl_x'
    dry_mass_ffsl => self%dry_mass_ffsl_x(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(dry_mass_ffsl, field_name, mesh_id)

  end function get_dry_mass_ffsl_x

  !> @brief Returns a pointer to a dry density field from an FFSL y-sweep
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the density
  !> @return The dry density field after its transport
  function get_dry_mass_ffsl_y(self, mesh_id, step) result(dry_mass_ffsl)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: dry_mass_ffsl
    character(str_def)                                :: field_name

    field_name = 'dry_mass_ffsl_y'
    dry_mass_ffsl => self%dry_mass_ffsl_y(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(dry_mass_ffsl, field_name, mesh_id)

  end function get_dry_mass_ffsl_y

  !> @brief Returns a pointer to a mass flux for a particular step
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the mass flux
  !> @return The mass flux
  function get_flux(self, mesh_id, step) result(flux)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: flux

    flux => self%flux(self%idx_from_mesh_id(mesh_id), step)

  end function get_flux

  !> @brief Returns a pointer to the flux from transporting dry density
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @param[in] step The step from which to return the dry flux
  !> @return The dry density flux
  function get_dry_flux(self, mesh_id, step) result(dry_flux)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def),                   intent(in) :: step
    type(r_tran_field_type),               pointer    :: dry_flux
    character(str_def)                                :: field_name

    field_name = 'dry_flux'
    dry_flux => self%dry_flux(self%idx_from_mesh_id(mesh_id), step)
    call check_initialised_field(dry_flux, field_name, mesh_id)

  end function get_dry_flux

  !> @brief Returns the counter of tracer transport steps
  !> @return The tracer step counter
  function get_tracer_step_ctr(self) result(tracer_step_ctr)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def) :: tracer_step_ctr

    tracer_step_ctr = self%tracer_step_ctr

  end function get_tracer_step_ctr

! ============================================================================ !
! UTILITIES
! ============================================================================ !

  !> @brief Increments the counter of tracer transport steps
  subroutine inc_tracer_step_ctr(self)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self

    self%tracer_step_ctr = self%tracer_step_ctr + 1

  end subroutine inc_tracer_step_ctr

  !> @brief Resets the counter of tracer transport steps
  subroutine reset_tracer_step_ctr(self)

    implicit none

    class(transport_runtime_type), target, intent(inout) :: self

    self%tracer_step_ctr = 1

  end subroutine reset_tracer_step_ctr

  !> @brief Computes the total number of rho transport steps
  !> @result    num_dry_steps    Total number of transport steps for rho
  function compute_num_dry_steps(self) result(num_dry_steps)

    use transport_config_mod,           only: profile_size,           &
                                              field_names,            &
                                              splitting,              &
                                              dry_field_name

    implicit none

    ! Arguments
    class(transport_runtime_type), target, intent(in) :: self
    ! Internal variables
    integer(kind=i_def) :: num_dry_steps
    integer(kind=i_def) :: config, dry_config
    logical(kind=l_def) :: dry_config_found

    ! Extract dry density metadata
    dry_config_found = .false.
    do config = 1, profile_size
      if ( trim(field_names(config)) == trim(dry_field_name) ) then
        dry_config_found = .true.
        dry_config = config
        exit
      end if
    end do

    if (.not. dry_config_found) then
      write(log_scratch_space, '(2A)') &
        'transport_runtime: Cannot set up consistent tracer transport ' // &
        'if there is no field named ', trim(dry_field_name)
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end if

    ! Compute total number of split steps
    select case(splitting(dry_config))
    case(splitting_strang_hvh, splitting_strang_vhv)
      num_dry_steps = 3
    case(splitting_hv, splitting_vh)
      num_dry_steps = 2
    case(splitting_none)
      num_dry_steps = 1
    case default
      write(log_scratch_space, '(A)') &
        'transport_runtime: Your splitting is not implemented with ' // &
        'consistent tracer transport'
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end select

  end function compute_num_dry_steps

  !> @brief Returns the function space for the direction of the dry step
  !> @param[in] step  Index of the dry density splitting step
  !> @result    fs    Enumerator for the W2 function space
  function direction_w2_fs(self, step) result(fs)

    use transport_config_mod,           only: profile_size,           &
                                              field_names,            &
                                              splitting,              &
                                              dry_field_name

    implicit none

    ! Arguments
    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: step
    ! Internal variables
    integer(kind=i_def) :: config, dry_config, fs
    logical(kind=l_def) :: dry_config_found

    ! Extract dry density metadata
    dry_config_found = .false.
    do config = 1, profile_size
      if ( trim(field_names(config)) == trim(dry_field_name) ) then
        dry_config_found = .true.
        dry_config = config
        exit
      end if
    end do

    if (.not. dry_config_found) then
      write(log_scratch_space, '(2A)') &
        'transport_runtime: Cannot set up compute dry steps ' // &
        'if there is no field named ', trim(dry_field_name)
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end if

    ! Compute total number of split steps
    select case(splitting(dry_config))
    case(splitting_strang_hvh)
      select case(step)
      case(1_i_def, 3_i_def)
        fs = W2h
      case(2_i_def)
        fs = W2v
      case default
        fs = 0
      end select
    case(splitting_strang_vhv)
      select case(step)
      case(1_i_def, 3_i_def)
        fs = W2v
      case(2_i_def)
        fs = W2h
      case default
        fs = 0
      end select
    case(splitting_hv)
      select case(step)
      case(1_i_def)
        fs = W2h
      case(2_i_def)
        fs = W2v
      case default
        fs = 0
      end select
    case(splitting_vh)
      select case(step)
      case(1_i_def)
        fs = W2v
      case(2_i_def)
        fs = W2h
      case default
        fs = 0
      end select
    case(splitting_none)
      fs = W2
    case default
      write(log_scratch_space, '(A)') &
        'transport_runtime: Your splitting is not implemented'
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end select

  end function direction_w2_fs

  !> @brief Private function for getting array index corresponding to mesh_id
  !> @param[in] self      The transport_runtime object
  !> @param[in] mesh_id   Identifier of mesh to find
  function idx_from_mesh_id(self, mesh_id) result(idx)

    implicit none

    class(transport_runtime_type), target, intent(in) :: self
    integer(kind=i_def),                   intent(in) :: mesh_id
    integer(kind=i_def)                               :: idx
    integer(kind=i_def)                               :: i

    idx = imdi
    do i = 1, self%n_meshes
      if ( mesh_id == self%mesh_ids(i) ) idx = i
    end do

    if ( idx == imdi ) then
      write(log_scratch_space, '(A,I4)') 'transport_runtime does not contain mesh: ', &
                                          mesh_id
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end if

  end function idx_from_mesh_id

  subroutine remap_on_extended_mesh(self, remap_field, field,             &
                                    monotone, enforce_minvalue, minvalue, &
                                    depth)

    implicit none
    class(transport_runtime_type), target, intent(inout) :: self

    type(r_tran_field_type), intent(inout) :: remap_field
    type(r_tran_field_type), intent(in)    :: field

    logical(kind=l_def), intent(in) :: monotone
    logical(kind=l_def), intent(in) :: enforce_minvalue
    real(kind=r_tran),   intent(in) :: minvalue
    integer(kind=i_def), intent(in) :: depth

    integer(kind=i_def) :: nremap

    type(mesh_type),           pointer :: mesh => null(), &
                                          twod_mesh => null()
    type(function_space_type), pointer :: w3_fs => null()

    if ( .not. self%computed_remapping ) then
      ! Compute remapping weights for this mesh
      if ( linear_remap ) then
        nremap = 2
      else
        nremap = 4
      end if
      mesh => field%get_mesh()
      twod_mesh => mesh_collection%get_mesh(mesh, TWOD)
      w3_fs => function_space_collection%get_fs(twod_mesh, 0, W3, nremap)
      call self%remap_weights%initialise( w3_fs, halo_depth=twod_mesh%get_halo_depth() )
      call self%remap_indices%initialise( w3_fs, halo_depth=twod_mesh%get_halo_depth() )
      call initialise_remap_on_extended_mesh(self%remap_weights, self%remap_indices)
      self%computed_remapping = .true.
    end if

    call remap_field_on_extended_mesh(remap_field, field, &
                                      self%remap_weights, &
                                      self%remap_indices, &
                                      monotone,           &
                                      enforce_minvalue,   &
                                      minvalue,           &
                                      depth )
    nullify( mesh, twod_mesh, w3_fs )

  end subroutine remap_on_extended_mesh

  !> @brief Checks a field for values less than epsilon, and throws an error
  !!        if these values exist
  !> @details It is not possible to compute sensible consistent departure
  !!          distances for tracers if the dry mass is no longer positive.
  subroutine check_negative_field(self, field, field_name)

    use sci_field_minmax_alg_mod, only: get_local_field_minmax

    implicit none

    ! Arguments
    class(transport_runtime_type), target, intent(in) :: self
    type(r_tran_field_type),               intent(in) :: field
    character(len=*),                      intent(in) :: field_name

    ! Internal variables
    real(kind=r_tran) :: field_min
    real(kind=r_tran) :: field_max

    call get_local_field_minmax(field, field_min, field_max)

    if (field_min < EPS_R_TRAN) then
      write(log_scratch_space, '(A,E16.8,A,E16.8,A)')                          &
        'The minimum of field ' // adjustl(trim(field_name)) // ' is ',        &
        field_min, ' which is below the accepted minimum of ', EPS_R_TRAN,     &
        ' which makes it impossible to find consistent departure distances. '  &
        // 'Stopping model rather than continuing'
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end if

  end subroutine check_negative_field

end module transport_runtime_alg_mod
