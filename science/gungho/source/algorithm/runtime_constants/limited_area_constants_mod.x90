!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!
!> @brief Provides constants used for limited area models.
!>
!> @details This module controls the set-up of various limited area model
!>          objects that do not change during a run. These objects are
!>          accessed from this module through appropriate 'get' functions.
!-------------------------------------------------------------------------------

module limited_area_constants_mod

  ! Infrastructure
  use constants_mod,                     only: i_def, r_def, str_def, str_short
  use extrusion_mod,                     only: TWOD
  use field_mod,                         only: field_type
  use r_solver_field_mod,                only: r_solver_field_type
  use field_parent_mod,                  only: field_parent_type, write_interface
  use field_collection_mod,              only: field_collection_type
  use field_collection_iterator_mod,     only: field_collection_iterator_type, &
                                               field_collection_real_iterator_type
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use function_space_chain_mod,          only: multigrid_function_space_chain
  use fs_continuity_mod,                 only: W2, W3, Wtheta
  use inventory_by_mesh_mod,             only: inventory_by_mesh_type
  use io_config_mod,                     only: subroutine_timers
  use lfric_xios_write_mod,              only: write_field_generic
  use log_mod,                           only: log_event,       &
                                               LOG_LEVEL_INFO,  &
                                               LOG_LEVEL_ERROR, &
                                               LOG_LEVEL_DEBUG
  use mesh_collection_mod,               only: mesh_collection
  use mesh_mod,                          only: mesh_type
  use sci_restrict_scalar_masked_kernel_mod, only: restrict_scalar_masked_kernel_type
  use sci_restrict_masked_w2_kernel_mod, only: restrict_masked_w2_kernel_type
  use runtime_tools_mod,                 only: primary_mesh_label,     &
                                               twod_mesh_label
  use timer_mod,                         only: timer


  use sci_psykal_light_mod,              only: invoke_copy_to_rsolver
  ! Configuration
  use base_mesh_config_mod,              only: geometry, geometry_spherical
  use boundaries_config_mod,             only: normal_only, lbc_method, &
                                               lbc_method_coordinate_based
  use finite_element_config_mod,         only: coord_system,     &
                                               coord_system_xyz, &
                                               element_order
  use formulation_config_mod,            only: l_multigrid
  use logging_config_mod,                only: run_log_level, &
                                               run_log_level_debug
  use multigrid_config_mod,              only: multigrid_chain_nitems

  ! Limited-area mask methods
  use limited_area_masks_alg_mod,        only: create_limited_area_mask,      &
                                               create_parallel_boundary_mask, &
                                               create_boundary_mask,          &
                                               create_blend_mask,             &
                                               create_lbc_mask,               &
                                               check_w2b_mask, &
                                               create_onion_layers

  implicit none

  private

  ! Variables private to this module that can only be accessed by public
  ! functions returning pointers to them

  ! Limited-area mask collection
  type(field_collection_type), target :: mask_collection

  ! The mask lists are associated with and in the same order as the
  ! mesh_id_list. i.e. They are lists of fields that define masks on all the
  ! meshes.
  ! The mask_w2_inventory, masks_w3_inventory and mask_wtheta_inventory give
  ! fields that are 1.0 in the interior of the domain (as defined by the
  ! solver boundary) and 0.0 elsewhere, for the W2, W3 and Wtheta
  ! function spaces.
  ! The mask_lbc*_inventory give fields that are 0.0 in the interior but are 1.0
  ! elsewhere, as defined by the width of the Lateral Boundary
  ! Conditions (LBCs),for the W2, W3 and Wtheta function spaces.
  ! The mask_blend*_inventory gives fields that are similar to the mask_lbc*_inventory
  ! but with weights that ramp from 1.0 to 0.0 in the interior, for the W2,
  ! W3 and Wtheta function spaces.
  ! The mask_boundary_w2_inventory gives fields that are 1.0 on the solver boundary
  ! (in the W2 space) and 0.0 elsewhere.
  ! onion_layers is a single field that identifies the cells in each concentric
  ! layer of the LAM blending zone, on the primary mesh.
  type(inventory_by_mesh_type) :: mask_w2_inventory
  type(inventory_by_mesh_type) :: mask_w3_inventory
  type(inventory_by_mesh_type) :: mask_wtheta_inventory
  type(inventory_by_mesh_type) :: mask_lbc_w2_inventory
  type(inventory_by_mesh_type) :: mask_lbc_w3_inventory
  type(inventory_by_mesh_type) :: mask_lbc_wtheta_inventory
  type(inventory_by_mesh_type) :: mask_blend_w2_inventory
  type(inventory_by_mesh_type) :: mask_blend_w3_inventory
  type(inventory_by_mesh_type) :: mask_blend_wtheta_inventory
  type(inventory_by_mesh_type) :: mask_boundary_w2_inventory
  type(field_type), target :: onion_layers

  ! r_solver masks
  type(inventory_by_mesh_type) :: mask_w2_r_solver_inventory
  type(inventory_by_mesh_type) :: mask_w3_r_solver_inventory
  type(inventory_by_mesh_type) :: mask_wt_r_solver_inventory

  ! Public functions to create and access the module contents
  public :: create_limited_area_constants
  public :: final_limited_area_constants
  public :: get_mask
  public :: get_mask_r_solver
  public :: get_boundary_mask
  public :: get_lbc_mask
  public :: get_blend_mask
  public :: get_onion_layers
  public :: write_masks

contains

  !> @brief Subroutine to create the limited area constants
  !> @param[in] mesh_id_list List of mesh_ids, assumed to be in an unknown order
  !> @param[in] chi          List of coordinate fields assoc. with and in the
  !!                         same order mesh_id_list
  !> @param[in] label_list   List of mesh labels assoc. with and in the
  !!                         same order mesh_id_list
  subroutine create_limited_area_constants(mesh_id_list,  &
                                           chi,           &
                                           label_list)
    implicit none

    ! Arguments
    integer(kind=i_def),    intent(in) :: mesh_id_list(:)
    type(field_type),       intent(in) :: chi(:,:)
    integer(kind=i_def),    intent(in) :: label_list(:)

    ! Internal variables
    type(function_space_type), pointer :: w2_fs     => null()
    type(function_space_type), pointer :: w3_fs     => null()
    type(function_space_type), pointer :: wtheta_fs => null()
    type(function_space_type), pointer :: w3_fs_2d  => null()

    type(mesh_type), pointer :: mesh        => null()
    type(mesh_type), pointer :: mesh_coarse => null()
    type(mesh_type), pointer :: mesh_fine   => null()

    type(mesh_type), pointer :: single_layer_mesh => null()

    ! Masks used to define the boundary conditions on the helmholtz solver
    ! These could be only normal or perpendicular to the solver boundary or
    ! alternatively they could be both normal (perpendicular) and tangential
    ! (parallel) to the solver boundary.
    type(field_type) :: w2parallel_mask
    type(field_type) :: w2perp_mask
    type(field_type) :: w2interior_mask

    ! Temporary mask fields to point to those in inventories
    type(field_type),          pointer :: mask_w2 => null()
    type(field_type),          pointer :: mask_w3 => null()
    type(field_type),          pointer :: mask_wtheta => null()
    type(field_type),          pointer :: mask_lbc_w2 => null()
    type(field_type),          pointer :: mask_lbc_w3 => null()
    type(field_type),          pointer :: mask_lbc_wtheta => null()
    type(field_type),          pointer :: mask_blend_w2 => null()
    type(field_type),          pointer :: mask_blend_w3 => null()
    type(field_type),          pointer :: mask_blend_wtheta => null()
    type(field_type),          pointer :: mask_boundary_w2 => null()
    type(r_solver_field_type), pointer :: mask_w2_r_solver => null()
    type(r_solver_field_type), pointer :: mask_w3_r_solver => null()
    type(r_solver_field_type), pointer :: mask_wt_r_solver => null()

    ! Fields used to calculate the masks on multigrid mesh levels.
    ! e.g. To create mask_w3_inventory(mesh_coarse) it restricts
    ! using the w3_source_mask as a field, but using the w3_mask
    ! as the mask.
    type(field_type), pointer :: w3_source_mask => null()
    type(field_type), pointer :: w3_fine_mask => null()
    type(field_type), pointer :: w2_source_mask => null()
    type(field_type), pointer :: w2_fine_mask => null()

    integer(kind=i_def) :: i, num_meshes
    integer(kind=i_def) :: mesh_id_fine

    if ( subroutine_timers ) call timer('limited_area_constants_alg')
    call log_event( "Gungho: creating limited_area_constants", LOG_LEVEL_INFO )

    call mask_collection%initialise(name='mask_collection')

    num_meshes = size(mesh_id_list)

    ! Set up inventories
    call mask_w2_inventory%initialise(name='w2_mask', table_len=num_meshes)
    call mask_w3_inventory%initialise(name='w3_mask', table_len=num_meshes)
    call mask_wtheta_inventory%initialise(name='wtheta_mask', table_len=num_meshes)
    call mask_lbc_w2_inventory%initialise(name='w2lbc_mask', table_len=num_meshes)
    call mask_lbc_w3_inventory%initialise(name='w3lbc_mask', table_len=num_meshes)
    call mask_lbc_wtheta_inventory%initialise(name='wthetalbc_mask', table_len=num_meshes)
    call mask_blend_w2_inventory%initialise(name='w2blend_mask', table_len=num_meshes)
    call mask_blend_w3_inventory%initialise(name='w3blend_mask', table_len=num_meshes)
    call mask_blend_wtheta_inventory%initialise(name='wthetablend_mask', table_len=num_meshes)
    call mask_boundary_w2_inventory%initialise(name='w2boundary_mask', table_len=num_meshes)
    call mask_w3_r_solver_inventory%initialise(name="mask_w3_r_solver", table_len=num_meshes)
    call mask_w2_r_solver_inventory%initialise(name="mask_w2_r_solver", table_len=num_meshes)
    call mask_wt_r_solver_inventory%initialise(name="mask_wt_r_solver", table_len=num_meshes)

    !===================== Start loop and creation of fields ==================!

    ! Loop through meshes to find the ones we're interested in, i.e. primary and twod
    ! TODO: #2790 should change this structure to avoid looping through meshes

    !========= Create fields ================================!

    do i = 1, num_meshes

      if ( label_list(i) == primary_mesh_label ) then

        mesh => mesh_collection%get_mesh( mesh_id_list(i) )

        w2_fs => function_space_collection%get_fs( mesh, element_order, W2 )
        w3_fs => function_space_collection%get_fs( mesh, element_order, W3 )
        wtheta_fs => function_space_collection%get_fs( mesh, element_order, Wtheta )

        single_layer_mesh => mesh_collection%get_mesh( mesh, TWOD )
        w3_fs_2d          => function_space_collection%get_fs( &
                             single_layer_mesh, element_order, W3 )
        call onion_layers%initialise( vector_space = w3_fs, name = 'onion_layers', halo_depth=2 )
        call create_onion_layers( onion_layers )
        call mask_collection%add_field( onion_layers )

        ! Basic masks ----------------------------------------------------------
        call mask_w2_inventory%add_field(mask_w2, w2_fs, mesh, name='w2_mask')
        call mask_w3_inventory%add_field(mask_w3, w3_fs, mesh, name='w3_mask')
        call mask_wtheta_inventory%add_field(mask_wtheta, wtheta_fs, mesh, name='wtheta_mask')
        call mask_boundary_w2_inventory%add_field(mask_boundary_w2, w2_fs, mesh, name='w2boundary_mask')

        call w2perp_mask%initialise( vector_space = w2_fs )
        call w2parallel_mask%initialise( vector_space = w2_fs )
        call w2interior_mask%initialise( vector_space = w2_fs )

        if (normal_only) then
          call log_event( "Using w2 dofs on boundary for LBC", &
               LOG_LEVEL_DEBUG )
          call create_boundary_mask( mask_boundary_w2, onion_layers, chi(:,i) )
          call create_limited_area_mask( mask_w2, onion_layers, chi(:,i) )
        else
          call log_event( "Using w2 dofs on boundary and tangential 1 cell in", &
               LOG_LEVEL_DEBUG )
          call create_boundary_mask( w2perp_mask, onion_layers, chi(:,i) )
          call create_parallel_boundary_mask ( w2parallel_mask, chi(:,i) )
          call create_limited_area_mask( w2interior_mask, onion_layers, chi(:,i) )

          call invoke( &
             ! Add the W2parallel and W2perp masks together
             X_plus_Y ( mask_boundary_w2,  w2perp_mask, w2parallel_mask ), &
             ! Subtract the W2parallel mask from the W2interior_mask
             X_minus_Y( mask_w2, w2interior_mask, w2parallel_mask ) )
        end if

        ! Check that the W2 boundary mask has the correct number of dofs
        ! if we're using the coordinate_based method
        if ( lbc_method == lbc_method_coordinate_based )then
          call check_w2b_mask( mask_boundary_w2 )
        end if

        call create_limited_area_mask( mask_w3, onion_layers, chi(:,i) )
        call create_limited_area_mask( mask_wtheta, onion_layers, chi(:,i) )

        ! Add the masks to the mask_collection to enable writing out
        call mask_collection%add_field( mask_w2 )
        call mask_collection%add_field( mask_w3 )
        call mask_collection%add_field( mask_wtheta )
        call mask_collection%add_field( mask_boundary_w2 )

        ! r_solver masks -------------------------------------------------------
        call mask_w2_r_solver_inventory%add_field(mask_w2_r_solver, w2_fs, mesh)
        call mask_w3_r_solver_inventory%add_field(mask_w3_r_solver, w3_fs, mesh)
        call mask_wt_r_solver_inventory%add_field(mask_wt_r_solver, wtheta_fs, mesh)

        call invoke_copy_to_rsolver(mask_w2_r_solver, mask_w2)
        call invoke_copy_to_rsolver(mask_w3_r_solver, mask_w3)
        call invoke_copy_to_rsolver(mask_wt_r_solver, mask_wtheta)

        nullify(mask_w2, mask_w3, mask_wtheta, mask_w2_r_solver, &
                mask_w3_r_solver, mask_wt_r_solver, mask_boundary_w2)

        ! LBC masks ------------------------------------------------------------
        call mask_lbc_w2_inventory%add_field(mask_lbc_w2, w2_fs, mesh, name='w2lbc_mask')
        call mask_lbc_w3_inventory%add_field(mask_lbc_w3, w3_fs, mesh, name='w3lbc_mask')
        call mask_lbc_wtheta_inventory%add_field(mask_lbc_wtheta, wtheta_fs, mesh, name='wthetalbc_mask')

        call create_lbc_mask( mask_lbc_w2, onion_layers, chi(:,i) )
        call create_lbc_mask( mask_lbc_w3, onion_layers, chi(:,i) )
        call create_lbc_mask( mask_lbc_wtheta, onion_layers, chi(:,i) )

        call mask_collection%add_field( mask_lbc_w2 )
        call mask_collection%add_field( mask_lbc_w3 )
        call mask_collection%add_field( mask_lbc_wtheta )

        nullify(mask_lbc_w2, mask_lbc_w3, mask_lbc_wtheta)

        ! Blend masks ----------------------------------------------------------
        call mask_blend_w2_inventory%add_field(mask_blend_w2, w2_fs, mesh, name='w2blend_mask')
        call mask_blend_w3_inventory%add_field(mask_blend_w3, w3_fs, mesh, name='w3blend_mask')
        call mask_blend_wtheta_inventory%add_field(mask_blend_wtheta, wtheta_fs, mesh, name='wthetablend_mask')

        call create_blend_mask( mask_blend_w2, onion_layers, chi(:,i) )
        call create_blend_mask( mask_blend_w3, onion_layers, chi(:,i) )
        call create_blend_mask( mask_blend_wtheta, onion_layers, chi(:,i) )

        call mask_collection%add_field( mask_blend_w2 )
        call mask_collection%add_field( mask_blend_w3 )
        call mask_collection%add_field( mask_blend_wtheta )

        nullify(mask_blend_w2, mask_blend_w3, mask_blend_wtheta)

        if (run_log_level == run_log_level_debug) call list_mask_fields()

      end if
    end do

    ! ------------------------------------------------------------------------ !
    ! Multigrid masks
    ! ------------------------------------------------------------------------ !
    if (l_multigrid) then
      ! If using multigrid, create the masks on each multigrid level mesh.

      ! w3_fs has been set from the primary_mesh above
      w3_fs => multigrid_function_space_chain%get_start()

      do i = 1, multigrid_chain_nitems-1

        ! Define mesh indexes for the fine level mesh
        mesh_fine => w3_fs%get_mesh()
        mesh_id_fine =  mesh_fine%get_id()

        ! Set the input as the fine level mesh masks
        call mask_w3_inventory%get_field(mesh_fine, w3_source_mask)
        call mask_w3_inventory%get_field(mesh_fine, w3_fine_mask)
        call mask_w2_inventory%get_field(mesh_fine, w2_source_mask)
        call mask_w2_inventory%get_field(mesh_fine, w2_fine_mask)

        ! Define mesh indexes for the coarse level mesh
        w3_fs => multigrid_function_space_chain%get_next()

        mesh_coarse => w3_fs%get_mesh()

        w2_fs => function_space_collection%get_fs( mesh_coarse, element_order, W2 )

        call mask_w3_inventory%add_field(mask_w3, w3_fs, mesh_coarse)
        call mask_w2_inventory%add_field(mask_w2, w2_fs, mesh_coarse)

        ! Define the masks on the coarse level meshes using restrict kernels.
        ! coarse_level_mask (coarse cell) = average ( fine_level_mask (fine cells) )
        ! where the average is only performed over the cells with non-zero values.
        call invoke(                                                        &
            restrict_scalar_masked_kernel_type(mask_w3, w3_source_mask,     &
                                               w3_fine_mask),               &
            setval_C( mask_w2, 0.0_r_def ),                                 &
            restrict_masked_w2_kernel_type(mask_w2, w2_source_mask,         &
                                           w2_fine_mask) )

        call mask_w3_r_solver_inventory%add_field(mask_w3_r_solver, w3_fs, mesh_coarse)
        call mask_w2_r_solver_inventory%add_field(mask_w2_r_solver, w2_fs, mesh_coarse)
        call invoke_copy_to_rsolver(mask_w3_r_solver, mask_w3)
        call invoke_copy_to_rsolver(mask_w2_r_solver, mask_w2)
        nullify(mask_w3, mask_w2, mask_w3_r_solver, mask_w2_r_solver)
      end do
    end if

    nullify(w2_fs, w3_fs, wtheta_fs)

    call log_event( "Gungho: created limited_area_constants", LOG_LEVEL_INFO )
    if ( subroutine_timers ) call timer('limited_area_constants_alg')

  end subroutine create_limited_area_constants

  !> @brief Write out the name of each mask in the mask field collection
  subroutine list_mask_fields()

    implicit none

    type( field_type ), pointer :: field_ptr  => null()
    type(field_collection_real_iterator_type)  :: iterator
    character(str_def) :: name

    call log_event( "Mask Collection fields:", LOG_LEVEL_DEBUG )

    call iterator%initialise(mask_collection)
    do
      if ( .not.iterator%has_next() ) exit
      field_ptr => iterator%next()
      name = trim(adjustl( field_ptr%get_name() ))
      call log_event( name, LOG_LEVEL_DEBUG )
    end do
    field_ptr => null()

  end subroutine list_mask_fields

  subroutine write_masks()
    use diagnostic_alg_mod,            only: extract_w2h_diagnostic_alg
    use lfric_xios_write_mod,          only: write_field_generic
    use field_parent_mod,              only: write_interface
    implicit none

    type( field_type ), pointer :: field_ptr  => null()
    type(field_collection_real_iterator_type)  :: iterator
    character(str_def) :: name
    type(function_space_type), pointer :: fs => null()

    type(field_type)                :: h_component, v_component

    procedure(write_interface), pointer  :: h_comp_write_ptr => null()
    procedure(write_interface), pointer  :: v_comp_write_ptr => null()
    procedure(write_interface), pointer  :: tmp_write_ptr => null()

    ! write out each mask in the collection
    call iterator%initialise(mask_collection)
    do
      if ( .not.iterator%has_next() ) exit

      field_ptr => iterator%next()
      name = trim(adjustl( field_ptr%get_name() ))
      fs => field_ptr%get_function_space()

      select case(fs%which())
      case (W2)
        ! XIOS output for W2 is 2D, so the output is
        ! for the horiztonal component on 'edges' and
        ! vertical component on 'faces'

        call extract_w2h_diagnostic_alg( h_component, v_component, &
                                         field_ptr )
        v_comp_write_ptr => write_field_generic
        call v_component%set_write_behaviour(v_comp_write_ptr)
        h_comp_write_ptr => write_field_generic
        call h_component%set_write_behaviour(h_comp_write_ptr)
        call h_component%write_field( "h_"//trim(name) )
        call v_component%write_field( "v_"//trim(name) )
      case default
        tmp_write_ptr => write_field_generic
        call field_ptr%set_write_behaviour(tmp_write_ptr)
        call field_ptr%write_field(name)
      end select
    end do
    field_ptr => null()

  end subroutine write_masks

  !> @brief  Returns pointer to the interior mask
  !> @param[in] space The function space of the interior mask
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The interior mask field
  function get_mask(space, mesh_id) result(mask_ptr)
    implicit none
    integer(kind=i_def), intent(in) :: mesh_id
    integer(kind=i_def), intent(in) :: space
    type(mesh_type),        pointer :: mesh => null()
    type(field_type),       pointer :: mask_ptr

    mesh => mesh_collection%get_mesh(mesh_id)

    select case (space)
      case (W2)
        call mask_w2_inventory%get_field(mesh, mask_ptr)
      case (W3)
        call mask_w3_inventory%get_field(mesh, mask_ptr)
      case (Wtheta)
        call mask_wtheta_inventory%get_field(mesh, mask_ptr)
      case default
        mask_ptr => null()
        call log_event( "Mask not available on requested space", &
          LOG_LEVEL_ERROR)
    end select
    nullify(mesh)

  end function get_mask

  !> @brief  Returns pointer to the interior mask at r_solver precision
  !> @param[in] space The function space of the interior mask
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The interior mask field
  function get_mask_r_solver(space, mesh_id) result(sol_mask_ptr)
    implicit none
    integer(kind=i_def), intent(in)    :: mesh_id
    integer(kind=i_def), intent(in)    :: space
    type(r_solver_field_type), pointer :: sol_mask_ptr
    type(mesh_type),           pointer :: mesh => null()

    mesh => mesh_collection%get_mesh(mesh_id)

    select case (space)
      case (W2)
        call mask_w2_r_solver_inventory%get_field(mesh, sol_mask_ptr)
      case (W3)
        call mask_w3_r_solver_inventory%get_field(mesh, sol_mask_ptr)
      case (Wtheta)
        call mask_wt_r_solver_inventory%get_field(mesh, sol_mask_ptr)
      case default
        sol_mask_ptr => null()
        call log_event( "r_solver Mask not available on requested space", &
          LOG_LEVEL_ERROR)
    end select
    nullify(mesh)

  end function get_mask_r_solver

  !> @brief  Returns pointer to the boundary mask
  !> @param[in] space The function space of the boundary mask
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The boundary mask field
  function get_boundary_mask(space, mesh_id) result(mask_ptr)
    implicit none
    integer(kind=i_def), intent(in) :: mesh_id
    integer(kind=i_def), intent(in) :: space
    type(mesh_type),        pointer :: mesh => null()
    type(field_type),       pointer :: mask_ptr

    mesh => mesh_collection%get_mesh(mesh_id)

    select case (space)
      case (W2)
        call mask_boundary_w2_inventory%get_field(mesh, mask_ptr)
      case default
        mask_ptr => null()
        call log_event( "Boundary mask not available on requested space", &
          LOG_LEVEL_ERROR)
    end select
    nullify(mesh)

  end function get_boundary_mask

  !> @brief  Returns pointer to the LBC mask
  !> @param[in] space The function space of the LBC mask
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The LBC mask field
  function get_lbc_mask(space, mesh_id) result(mask_ptr)
    implicit none
    integer(kind=i_def), intent(in) :: mesh_id
    integer(kind=i_def), intent(in) :: space
    type(mesh_type),        pointer :: mesh => null()
    type(field_type),       pointer :: mask_ptr

    mesh => mesh_collection%get_mesh(mesh_id)

    select case (space)
      case (W2)
        call mask_lbc_w2_inventory%get_field(mesh, mask_ptr)
      case (W3)
        call mask_lbc_w3_inventory%get_field(mesh, mask_ptr)
      case (Wtheta)
        call mask_lbc_wtheta_inventory%get_field(mesh, mask_ptr)
      case default
        mask_ptr => null()
        call log_event( "Mask not available on requested space", &
          LOG_LEVEL_ERROR)
    end select
    nullify(mesh)

  end function get_lbc_mask

  !> @brief  Returns pointer to the onion_layer mask
  !> @return The onion_layer mask
  function get_onion_layers() result(mask_ptr)
    implicit none

    type(field_type),       pointer :: mask_ptr

    mask_ptr => onion_layers

  end function get_onion_layers

  !> @brief  Returns pointer to the blend mask
  !> @param[in] space The function space of the blend mask
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The blend mask field
  function get_blend_mask(space, mesh_id) result(mask_ptr)
    implicit none
    integer(kind=i_def), intent(in) :: mesh_id
    integer(kind=i_def), intent(in) :: space
    type(mesh_type),        pointer :: mesh => null()
    type(field_type),       pointer :: mask_ptr

    mesh => mesh_collection%get_mesh(mesh_id)

    select case (space)
    case (W2)
      call mask_blend_w2_inventory%get_field(mesh, mask_ptr)
    case (W3)
      call mask_blend_w3_inventory%get_field(mesh, mask_ptr)
    case (Wtheta)
      call mask_blend_wtheta_inventory%get_field(mesh, mask_ptr)
    case default
      mask_ptr => null()
      call log_event( "Blend mask not available on requested space", &
        LOG_LEVEL_ERROR)
    end select
    nullify(mesh)

  end function get_blend_mask

  !> @brief Explicitly reclaim memory from module scope variables
  !
  subroutine final_limited_area_constants()

    implicit none

    call mask_w2_inventory%clear()
    call mask_w3_inventory%clear()
    call mask_wtheta_inventory%clear()
    call mask_lbc_w2_inventory%clear()
    call mask_lbc_w3_inventory%clear()
    call mask_lbc_wtheta_inventory%clear()
    call mask_blend_w2_inventory%clear()
    call mask_blend_w3_inventory%clear()
    call mask_blend_wtheta_inventory%clear()
    call mask_boundary_w2_inventory%clear()
    call mask_w3_r_solver_inventory%clear()
    call mask_w2_r_solver_inventory%clear()
    call mask_wt_r_solver_inventory%clear()

  end subroutine final_limited_area_constants

end module limited_area_constants_mod
