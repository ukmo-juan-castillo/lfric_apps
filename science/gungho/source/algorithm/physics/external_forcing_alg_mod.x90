!-------------------------------------------------------------------------------
! (C) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-------------------------------------------------------------------------------
!> @brief Interface to external forcing code.
module external_forcing_alg_mod

  use external_forcing_config_mod,     only: theta_forcing,                      &
                                             theta_forcing_none,                 &
                                             theta_forcing_held_suarez,          &
                                             theta_forcing_earth_like,           &
                                             theta_forcing_tidally_locked_earth, &
                                             theta_forcing_shallow_hot_jupiter,  &
                                             theta_forcing_deep_hot_jupiter,     &
                                             theta_forcing_temp_tend,            &
                                             wind_forcing,                       &
                                             wind_forcing_none,                  &
                                             wind_forcing_held_suarez,           &
                                             wind_forcing_filtering,             &
                                             wind_forcing_diffusion,             &
                                             filtering_order,                    &
                                             diffusion_order,                    &
                                             diffusion_coefficient
  use log_mod,                         only: log_event, log_scratch_space,       &
                                             LOG_LEVEL_INFO, LOG_LEVEL_ERROR
  use lfric_xios_write_mod,            only: write_field_generic
  use field_parent_mod,                only: write_interface

  use held_suarez_fv_kernel_mod,       only: held_suarez_fv_kernel_type
  use held_suarez_fv_wind_kernel_mod,  only: held_suarez_fv_wind_kernel_type
  use earth_like_kernel_mod,           only: earth_like_kernel_type
  use tidally_locked_earth_kernel_mod, only: tidally_locked_earth_kernel_type
  use shallow_hot_jupiter_kernel_mod,  only: shallow_hot_jupiter_kernel_type
  use deep_hot_jupiter_kernel_mod,     only: deep_hot_jupiter_kernel_type
  use momentum_smagorinsky_kernel_mod, only: momentum_smagorinsky_kernel_type

  ! Derived Types
  use constants_mod,                   only: i_def, r_def, l_def
  use field_mod,                       only: field_type
  use field_collection_mod,            only: field_collection_type

  use fs_continuity_mod,               only: W1, W2, Wtheta
  use fem_constants_mod,               only: get_rmultiplicity
  use geometric_constants_mod,         only: get_coordinates, &
                                             get_da_at_w2,    &
                                             get_panel_id,    &
                                             get_height
  use mesh_mod,                        only: mesh_type

  use io_config_mod,                   only: subroutine_timers, write_diag, &
                                             use_xios_io
  use physical_op_constants_mod,       only: get_dx_at_w2
  use planet_config_mod,               only: kappa

  use reference_element_mod,           only: T
  use sci_set_any_dof_kernel_mod,      only: set_any_dof_kernel_type

  use temp_tend_profile_alg_mod,       only: temp_tend_profile_alg
  use timer_mod,                       only: timer

  use w2_filter_alg_mod,               only: w2_filter_alg

  use external_forcing_diagnostics_mod, only: write_forcing_diagnostics

  implicit none

  private
  public :: external_forcing_alg

contains

  !> @details Interface to external forcing of temperature and wind.
  !>          The choices of temperature and wind forcing are independent,
  !>          such that any combination of temperature forcing will work with
  !>          any combination of wind forcing (or either can be set to none
  !>          and unforced).
  !> @param[in]     derived_fields     Group of derived fields
  !> @param[in]     u                  3D wind field
  !> @param[in]     theta              Theta field
  !> @param[in]     exner              Exner pressure
  !> @param[in]     exner_in_wth       Exner pressure on Wtheta space
  !> @param[in]     dt                 The model timestep length
  !> @param[out]    dtheta_forcing     Theta increment from external forcing
  !> @param[out]    du_forcing         Wind increment from external forcing
  !> @param[in,out] theta_forcing_done Flag to say if theta code run
  !> @param[in,out] wind_forcing_done  Flag to say if wind code run
  subroutine external_forcing_alg(derived_fields, u, theta, exner, exner_in_wth, &
                                  dt, dtheta_forcing, du_forcing,                &
                                  theta_forcing_done, wind_forcing_done)

    implicit none

    type( field_collection_type ), intent(in) :: derived_fields
    type( field_type ), intent( in )  :: u, theta, exner, exner_in_wth
    type( field_type ), intent( out ) :: dtheta_forcing, du_forcing
    real( kind=r_def ), intent( in )  :: dt

    logical( kind=l_def ), intent(inout) :: theta_forcing_done, &
                                            wind_forcing_done

    ! Temporary field to unpack from field collection
    type( field_type ), pointer :: u_physics => null()
    type( field_type ), pointer :: w2_rmultiplicity => null()
    type( field_type ), pointer :: dA => null()
    type( field_type ), pointer :: chi(:) => null()
    type( field_type ), pointer :: panel_id => null()
    type( field_type ), pointer :: height_wth => null()
    type( field_type ), pointer :: height_w1 => null()
    type( field_type ), pointer :: height_w2 => null()
    type( field_type ), pointer :: dx_at_w2 => null()

    type( field_type ) :: u_smoothed, dx, visc_m

    integer( kind=i_def ) :: order
    real( kind=r_def )    :: diffusion_coefficient_scaled, dx_sum, dx_size

    type( mesh_type ),  pointer :: mesh => null()
    procedure(write_interface), pointer :: write_behaviour => null()

    if ( subroutine_timers ) call timer("external_forcing_alg")

    mesh => theta%get_mesh()
    height_wth => get_height( Wtheta, mesh%get_id() )

    if (theta_forcing /= theta_forcing_none) then

      call dtheta_forcing%initialise( vector_space = theta%get_function_space() )
      call invoke( setval_c(dtheta_forcing, 0.0_r_def) )

      chi => get_coordinates( mesh%get_id() )
      panel_id => get_panel_id( mesh%get_id() )

      select case(theta_forcing)

        case(theta_forcing_held_suarez)

          call log_event( 'slow_physics: Running Held-Suarez theta forcing', &
                          LOG_LEVEL_INFO )

          call invoke(held_suarez_fv_kernel_type(dtheta_forcing, theta, &
                                                 exner_in_wth, chi,     &
                                                 panel_id, kappa, dt) )

        case(theta_forcing_earth_like)

          call log_event( 'slow_physics: Running Earth-Like theta forcing', &
                          LOG_LEVEL_INFO )

          call invoke(earth_like_kernel_type(dtheta_forcing, theta,         &
                                             exner_in_wth, height_wth, chi, &
                                             panel_id, kappa, dt) )

        case(theta_forcing_tidally_locked_earth)

          call log_event( 'slow_physics: Running TLE theta forcing', &
                          LOG_LEVEL_INFO )

          call invoke(tidally_locked_earth_kernel_type(dtheta_forcing, theta, &
                                                       exner_in_wth, chi,     &
                                                       panel_id, kappa, dt) )

        case(theta_forcing_shallow_hot_jupiter)

          call log_event( 'slow_physics: Running shallow hot Jupiter theta forcing', &
                          LOG_LEVEL_INFO )

          call invoke(shallow_hot_jupiter_kernel_type(dtheta_forcing, theta, &
                                                      exner_in_wth, height_wth, chi, &
                                                      panel_id, kappa, dt) )

        case(theta_forcing_deep_hot_jupiter)

          call log_event( 'slow_physics: Running deep hot Jupiter theta forcing', &
                          LOG_LEVEL_INFO )

          call invoke(deep_hot_jupiter_kernel_type(dtheta_forcing, theta, &
                                                   exner_in_wth, chi, panel_id, dt) )

        case(theta_forcing_temp_tend)

          call temp_tend_profile_alg( dtheta_forcing, exner_in_wth )

        case default

          call log_event( 'slow_physics: Incorrect theta_forcing option', &
                          LOG_LEVEL_ERROR )

      end select

      theta_forcing_done = .true. ! Collect this increment later on

      if (write_diag .and. use_xios_io) then
        write_behaviour => write_field_generic
        call dtheta_forcing%set_write_behaviour(write_behaviour)
        call dtheta_forcing%write_field('forcing__dtheta_force')
      end if

      nullify( chi, panel_id )

    end if

    if (wind_forcing /= wind_forcing_none) then

      select case(wind_forcing)

        case(wind_forcing_held_suarez)

          call log_event( 'slow_physics: Running Held-Suarez wind forcing', &
                          LOG_LEVEL_INFO )

          w2_rmultiplicity => get_rmultiplicity( W2, mesh%get_id() ) ! 1/multiplicity of w2
          dA => get_da_at_w2( mesh%get_id() )

          call derived_fields%get_field('u_physics', u_physics)

          call du_forcing%initialise( vector_space = u_physics%get_function_space() )
          call invoke(setval_c(du_forcing, 0.0_r_def))

          call invoke(held_suarez_fv_wind_kernel_type(du_forcing, u_physics, &
                                                      w2_rmultiplicity,      &
                                                      exner, exner_in_wth,   &
                                                      kappa, dt),            &
                      inc_X_times_Y(du_forcing, dA) )

          nullify( w2_rmultiplicity, u_physics, dA )

        case(wind_forcing_filtering)

          write(log_scratch_space,'(A,I3)')                                &
               'slow_physics: Running wind filtering forcing with order ', &
                filtering_order
          call log_event( log_scratch_space, LOG_LEVEL_INFO )

          call du_forcing%initialise( vector_space = u%get_function_space() )
          call invoke(setval_c(du_forcing, 0.0_r_def))

          call u_smoothed%initialise( vector_space = u%get_function_space() )
          call invoke(setval_X(u_smoothed, u))

          do order = 1, filtering_order
            call w2_filter_alg(u_smoothed)
          end do
          call invoke(X_minus_Y(du_forcing, u_smoothed, u))

        case(wind_forcing_diffusion)

          write(log_scratch_space,'(A,F6.3,A,I3)')                                  &
               'slow_physics: Running horizontal wind diffusion with coefficient ', &
               diffusion_coefficient, 'and order ', diffusion_order
          call log_event( log_scratch_space, LOG_LEVEL_INFO )

          ! The code below uses the Smagorinsky kernel to calculate the
          ! the horizontal diffusion of wind. Note the diffusion coefficient
          ! in this code is dimensionless which means we first scale it with
          ! the typical horizontal grid scale size.
          !
          ! Also note we turn off the horizontal diffusion of the vertical
          ! wind component by setting the returned vertical wind increment to
          ! zero.
          !
          panel_id => get_panel_id(mesh%get_id())
          height_w1 => get_height(W1, mesh%get_id())
          height_w2 => get_height(W2, mesh%get_id())

          dx_at_w2 => get_dx_at_w2(mesh%get_id())

          call visc_m%initialise( vector_space = theta%get_function_space())
          call dx%initialise( vector_space = dx_at_w2%get_function_space() )
          call invoke(setval_c(dx, 1.0_r_def))
          call invoke(sum_X(dx_sum, dx_at_w2))
          call invoke(sum_X(dx_size, dx))
          diffusion_coefficient_scaled = diffusion_coefficient * (dx_sum / dx_size) ** 2
          call invoke(setval_c(visc_m, diffusion_coefficient_scaled))

          call du_forcing%initialise( vector_space = u%get_function_space() )
          call invoke(setval_c(du_forcing, 0.0_r_def))

          call u_smoothed%initialise( vector_space = u%get_function_space() )
          call invoke(setval_X(u_smoothed, u))

          do order = 1, diffusion_order
            call invoke(momentum_smagorinsky_kernel_type(du_forcing, &
                                                         u_smoothed, &
                                                         1,          &
                                                         dx_at_w2,   &
                                                         1,          &
                                                         height_w2,  &
                                                         height_w1,  &
                                                         visc_m,     &
                                                         1,          &
                                                         panel_id,   &
                                                         1))
            call invoke(set_any_dof_kernel_type(du_forcing, T, 0.0_r_def))
            call invoke(inc_X_plus_Y(u_smoothed, du_forcing),        &
                        setval_c(du_forcing, 0.0_r_def))
          end do
          call invoke(X_minus_Y(du_forcing, u_smoothed, u))

          nullify(panel_id, height_w1, height_w2, dx_at_w2)

        case default

          call log_event( 'slow_physics: Incorrect wind_forcing option', &
                          LOG_LEVEL_ERROR )

      end select

      wind_forcing_done = .true. ! Collect this increment later on

      nullify( w2_rmultiplicity, u_physics, dA )

    end if

    nullify( mesh )

    !
    ! Write out diagnostics (if available)
    !
    call write_forcing_diagnostics(du_forcing=du_forcing, output_wind_inc=wind_forcing_done)

    if ( subroutine_timers ) call timer("external_forcing_alg")

  end subroutine external_forcing_alg

end module external_forcing_alg_mod
