!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!> Test the vorticity rhs computation
!>
module compute_total_pv_kernel_mod_test

  use constants_mod,                       only : i_def, r_def, PI
  use get_unit_test_m3x3_q3x3x3_sizes_mod, only : get_w0_m3x3_q3x3x3_size, &
                                                  get_w1_m3x3_q3x3x3_size, &
                                                  get_w3_m3x3_q3x3x3_size
  use get_unit_test_m3x3_dofmap_mod,       only : get_w0_m3x3_dofmap, &
                                                  get_w1_m3x3_dofmap, &
                                                  get_w3_m3x3_dofmap, &
                                                  get_wchi_m3x3_dofmap
  use get_unit_test_q3x3x3_basis_mod,      only : get_w0_q3x3x3_diff_basis,   &
                                                  get_w0_q3x3x3_basis,        &
                                                  get_w1_q3x3x3_basis,        &
                                                  get_w3_q3x3x3_basis,        &
                                                  get_wchi_q3x3x3_diff_basis, &
                                                  get_wchi_q3x3x3_basis
  use get_unit_test_q3x3x3_quadrature_mod, only : get_gaussian_q3x3x3_quadrature_weights_xy, &
                                                  get_gaussian_q3x3x3_quadrature_weights_z
  use get_unit_test_3x3x3_chi_mod,         only : get_wchi_3x3x3_field
  use coord_transform_mod,                 only : xyz2llr, llr2xyz
  use pFUnit_Mod

  implicit none

  private
  public :: set_up, tear_Down, test_all

  integer(i_def), parameter :: element_order = 0

  real(r_def), parameter :: planet_radius = 6000000.0_r_def

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @before
  subroutine set_up()

    use base_mesh_config_mod,      only : geometry_spherical, &
                                          topology_fully_periodic
    use extrusion_config_mod,      only : method_uniform, &
                                          stretching_method_linear
    use finite_element_config_mod, only : cellshape_quadrilateral, &
                                          coord_system_xyz
    use feign_config_mod,          only : feign_extrusion_config,      &
                                          feign_finite_element_config, &
                                          feign_planet_config,         &
                                          feign_base_mesh_config
    use sci_chi_transform_mod,     only : init_chi_transforms

    implicit none

    call feign_base_mesh_config( file_prefix='foo',                &
                                 prime_mesh_name='unit_test',      &
                                 geometry=geometry_spherical,      &
                                 prepartitioned=.false.,           &
                                 topology=topology_fully_periodic, &
                                 fplane=.false., f_lat_deg=0.0_r_def )

    call feign_extrusion_config( planet_radius=planet_radius,                &
                                 domain_height=10.0_r_def,                   &
                                 method=method_uniform,                      &
                                 number_of_layers=2_i_def,                   &
                                 stretching_method=stretching_method_linear, &
                                 stretching_height=1.0_r_def )

    call feign_finite_element_config(           &
             cellshape=cellshape_quadrilateral, &
             coord_order=0_i_def,               &
             coord_system=coord_system_xyz,     &
             element_order=0_i_def,             &
             rehabilitate=.true.,               &
             vorticity_in_w1=.false. )

    call feign_planet_config( gravity=10.0_r_def, omega=8.0E-5_r_def, &
                              rd=300.0_r_def, cp=1000.0_r_def,        &
                              p_zero=100000.0_r_def,                  &
                              scaling_factor=1.0_r_def )
    call init_chi_transforms()

  end subroutine set_up

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @after
  subroutine tear_down()

    use configuration_mod,        only: final_configuration

    implicit none

    call final_configuration()

  end subroutine tear_down

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_all()

    use, intrinsic :: iso_fortran_env, only : real64
    use compute_total_pv_kernel_mod,   only : compute_total_pv_code

    implicit none

    real(r_def), parameter :: tol    = 1.0e-6_r_def   ! r_def 64bit
    real(r_def), parameter :: tol32  = 1.0e-4_r_def   ! r_def 32bit
    real(r_def)            :: answer
    real(r_def), parameter :: dx = 3.0_r_def
    real(r_def), parameter :: dy = 3.0_r_def
    real(r_def), parameter :: dz = 100.0_r_def
    real(r_def), parameter :: dtheta = 10.0_r_def
    real(r_def), parameter :: rho_ref = 5.0_r_def

    real(r_def) :: lat_0, lon_0, r_0
    real(r_def) :: dlat, dlon, dr

    real(r_def)            :: use_tol

    integer(i_def) :: nlayers, ncells, ncells_3d, cell, icell
    integer(i_def) :: ncols_x, ncols_y, ncols_2d
    integer(i_def) :: ndf_w0, undf_w0, ndf_w1, undf_w1
    integer(i_def) :: ndf_w3, undf_w3, ndf_pid, undf_pid
    integer(i_def) :: ndf_wchi, undf_wchi
    integer(i_def) :: dim_space, dim_space_diff
    integer(i_def) :: nqp_h, nqp_v
    real(r_def) :: x, y, z, x0, y0, z0
    integer(i_def) :: i, j, k, df

    integer(i_def), allocatable :: map_w0(:,:)
    integer(i_def), allocatable :: map_wchi(:,:)
    integer(i_def), allocatable :: map_w1(:,:)
    integer(i_def), allocatable :: map_w3(:,:)
    integer(i_def), allocatable :: map_pid(:,:)
    real(r_def), allocatable :: basis_w0(:,:,:,:)
    real(r_def), allocatable :: diff_basis_w0(:,:,:,:)
    real(r_def), allocatable :: basis_wchi(:,:,:,:)
    real(r_def), allocatable :: diff_basis_wchi(:,:,:,:)
    real(r_def), allocatable :: basis_w1(:,:,:,:)
    real(r_def), allocatable :: basis_w3(:,:,:,:)
    real(r_def), allocatable :: wh(:), wv(:)

    real(r_def), allocatable :: chi1(:), chi2(:), chi3(:), panel_id(:)
    real(r_def), allocatable :: pv(:)
    real(r_def), allocatable :: xi(:)
    real(r_def), allocatable :: theta(:)
    real(r_def), allocatable :: rho(:)
    real(r_def)              :: f_lat, omega

     ! ------------------------------------------------------------------------ !
    ! Make mesh and function space details
    ! ------------------------------------------------------------------------ !
    ! Specify details for 3x3x3 grid -- biperiodic to make use of canned data
    nlayers = 3
    ncols_x = 3
    ncols_y = 3
    ncols_2d = ncols_x*ncols_y
    ncells_3d = ncols_x*ncols_y*nlayers
    ndf_wchi = 8
    undf_wchi = ncells_3d*ndf_wchi ! (nlayers+1)*ncols_x*ncols_y

    call get_w0_m3x3_q3x3x3_size( ndf_w0, undf_w0, ncells, &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v, &
                                  nlayers )
    call get_w1_m3x3_q3x3x3_size( ndf_w1, undf_w1, ncells, &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v, &
                                  nlayers )
    call get_w3_m3x3_q3x3x3_size( ndf_w3, undf_w3, ncells, &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v, &
                                  nlayers )

    ndf_pid = 1
    undf_pid = ncells

    ! Get dofmaps for fields
    call get_w0_m3x3_dofmap(map_w0)
    call get_w1_m3x3_dofmap(map_w1)
    call get_w3_m3x3_dofmap(map_w3)
    call get_w3_m3x3_dofmap(map_pid, 1)
    call get_wchi_m3x3_dofmap(map_wchi)

    ! Get basis functions and quadrature weights
    call get_w0_q3x3x3_diff_basis(diff_basis_w0)
    call get_w0_q3x3x3_basis(basis_w0)
    call get_w1_q3x3x3_basis(basis_w1)
    call get_w3_q3x3x3_basis(basis_w3)
    call get_wchi_q3x3x3_basis(basis_wchi)
    call get_wchi_q3x3x3_diff_basis(diff_basis_wchi)

    ! 3 point quadrature
    call get_gaussian_q3x3x3_quadrature_weights_xy(wh)
    call get_gaussian_q3x3x3_quadrature_weights_z(wv)

    ! Compute coordinates
    allocate(chi1(undf_wchi))
    allocate(chi2(undf_wchi))
    allocate(chi3(undf_wchi))
    allocate(panel_id(ncells))

    call get_wchi_3x3x3_field(chi1, chi2, chi3, &
                              dx, dy, dz, 0.0_r_def, map_wchi, nlayers)
    panel_id(:) = 1.0_r_def
    lat_0 = PI/4.0_r_def
    call llr2xyz(0.0_r_def, lat_0, planet_radius, x0, y0, z0)
    call xyz2llr(dx, dy, dz, dlon, dlat, dr)
    chi1(:) = chi1(:) + x0
    chi2(:) = chi2(:) + y0
    chi3(:) = chi3(:) + z0

    ! Create the data
    allocate(xi(undf_w1))
    allocate(theta(undf_w0))
    allocate(pv(undf_w3))
    allocate(rho(undf_w3))
    xi(:) = 3.0e-5_r_def
    theta(:) = 300.0_r_def + dtheta/2.0_r_def
    theta(map_w0(1,1)) = 300.0_r_def - dtheta/2.0_r_def
    theta(map_w0(2,1)) = 300.0_r_def - dtheta/2.0_r_def
    theta(map_w0(3,1)) = 300.0_r_def - dtheta/2.0_r_def
    theta(map_w0(4,1)) = 300.0_r_def - dtheta/2.0_r_def
    rho(:) = rho_ref
    pv(:) = 0.0_r_def

    f_lat = PI*45.0_r_def/180.0_r_def
    omega = 8.0e-5_r_def
    cell = 1
    call compute_total_pv_code(                          &
                               nlayers,                  &
                               pv,                       &
                               xi,                       &
                               theta,                    &
                               rho,                      &
                               chi1,                     &
                               chi2,                     &
                               chi3,                     &
                               panel_id,                 &
                               omega,                    &
                               f_lat,                    &
                               ndf_w3, undf_w3,          &
                               map_w3(:,cell),           &
                               basis_w3,                 &
                               ndf_w1, undf_w1,          &
                               map_w1(:,cell),           &
                               basis_w1,                 &
                               ndf_w0, undf_w0,          &
                               map_w0(:,cell),           &
                               diff_basis_w0,            &
                               ndf_wchi, undf_wchi,      &
                               map_wchi(:,cell),         &
                               basis_wchi,               &
                               diff_basis_wchi,          &
                               ndf_pid, undf_pid,        &
                               map_pid(:,cell),          &
                               nqp_h, nqp_v,             &
                               wh, wv)

    if ( r_def == real64 ) then
      use_tol = tol
    else
      use_tol = tol32
    end if
    ! Answer should be (xi + omega_3)*dtheta/dz in cell 1
    answer = (3.0e-5_r_def + 2.0_r_def*omega*(sin(lat_0+dlat/2.0_r_def)))*(dtheta/dz)/rho_ref

    ! This is only testing the vertical component of vorticity
    @assertEqual(answer, pv(map_w3(1, cell))/(dx*dy*dz) , use_tol)

    deallocate(map_w0)
    deallocate(map_wchi)
    deallocate(map_w1)
    deallocate(map_w3)
    deallocate(map_pid)
    deallocate(diff_basis_w0)
    deallocate(basis_w0)
    deallocate(basis_w1)
    deallocate(diff_basis_wchi)
    deallocate(basis_wchi)
    deallocate(wh)
    deallocate(wv)

    deallocate(chi1)
    deallocate(chi2)
    deallocate(chi3)
    deallocate(panel_id)
    deallocate(xi)
    deallocate(theta)
    deallocate(pv)

  end subroutine test_all

end module compute_total_pv_kernel_mod_test
