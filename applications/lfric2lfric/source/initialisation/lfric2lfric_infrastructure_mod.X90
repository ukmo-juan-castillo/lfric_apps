!-----------------------------------------------------------------------------
! (C) Crown copyright 2024 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief     Initialises the lfric2lfric miniapp infrastructure.
!>
!> @details   Initialises the required infrastructure for the lfric2lfric
!!            miniapp. This includes meshes and extrusions, XIOS contexts,
!!            field collections and the fields for source and destination
!!            meshes.
!>
module lfric2lfric_infrastructure_mod

  use add_mesh_map_mod,            only: assign_mesh_maps
  use blend_orography_alg_mod,     only: blend_orography
  use check_configuration_mod,     only: get_required_stencil_depth
  use constants_mod,               only: str_def, r_def, i_def, l_def, r_second
  use create_mesh_mod,             only: create_extrusion, &
                                         create_mesh
  use driver_modeldb_mod,          only: modeldb_type
  use driver_fem_mod,              only: init_fem
  use driver_io_mod,               only: init_io, &
                                         filelist_populator
  use extrusion_mod,               only: extrusion_type,         &
                                         uniform_extrusion_type, &
                                         prime_extrusion,        &
                                         twod
  use field_mod,                   only: field_type
  use field_collection_mod,        only: field_collection_type
  use fs_continuity_mod,           only: W3
  use function_space_collection_mod,only: function_space_collection
  use function_space_mod,          only: function_space_type
  use gungho_extrusion_mod,        only: dcmip_extrusion_type,                 &
                                         um_L38_29t_9s_40km_extrusion_type,    &
                                         um_L85_50t_35s_85km_extrusion_type,   &
                                         um_L70_61t_9s_40km_extrusion_type,    &
                                         um_L120_99t_21s_40km_extrusion_type,  &
                                         um_L140_122t_18s_40km_extrusion_type, &
                                         um_L70_50t_20s_80km_extrusion_type
  use sci_geometric_constants_mod, only: get_chi_inventory,     &
                                         get_panel_id_inventory
  use init_altitude_mod,           only: init_altitude
  use inventory_by_mesh_mod,       only: inventory_by_mesh_type
  use io_context_mod,              only: callback_clock_arg
  use linked_list_mod,             only: linked_list_type
  use lfric_xios_context_mod,      only: lfric_xios_context_type
  use lfric_xios_action_mod,       only: advance
  use log_mod,                     only: log_event,         &
                                         log_scratch_space, &
                                         log_level_error,   &
                                         log_level_debug
  use mesh_mod,                    only: mesh_type
  use mesh_collection_mod,         only: mesh_collection
  use model_clock_mod,             only: model_clock_type
  use namelist_mod,                only: namelist_type
  use orography_config_mod,        only: orog_init_option,          &
                                         orog_init_option_analytic, &
                                         orog_init_option_ancil,    &
                                         orog_init_option_start_dump
  use sci_geometric_constants_mod, only: get_chi_inventory,  &
                                         get_panel_id_inventory
  use setup_orography_alg_mod,     only: setup_orography_alg

  !------------------------------------
  ! lfric2lfric modules
  !------------------------------------
  use lfric2lfric_init_mesh_mod,   only: init_mesh
  use lfric2lfric_check_conf_mod,  only: lfric2lfric_check_configuration
  use lfric2lfric_file_init_mod,   only: init_lfric2lfric_dst_files, &
                                         init_lfric2lfric_src_files
  use lfric2lfric_init_mod,        only: init_lfric2lfric
  use lfric2lfric_init_coupler_mod,only: lfric2lfric_init_coupler_src, &
                                         lfric2lfric_init_coupler_dst, &
                                         lfric2lfric_end_coupler_init
#ifdef MCT
  use coupling_mod,                only: coupling_type, &
                                         get_coupling_from_collection
  use coupler_exchange_2d_mod,     only: coupler_exchange_2d_type
#endif

  !------------------------------------
  ! Configuration modules
  !------------------------------------
  use extrusion_config_mod,       only: key_from_method,              &
                                        method_uniform,               &
                                        method_geometric,             &
                                        method_quadratic,             &
                                        method_dcmip,                 &
                                        method_um_L38_29t_9s_40km,    &
                                        method_um_L85_50t_35s_85km,   &
                                        method_um_L70_61t_9s_40km,    &
                                        method_um_L120_99t_21s_40km,  &
                                        method_um_L140_122t_18s_40km, &
                                        method_um_L70_50t_20s_80km
  use lfric2lfric_config_mod,     only: mode_ics, mode_lbc,        &
                                        regrid_method_lfric2lfric, &
                                        regrid_method_map,         &
                                        regrid_method_oasis,       &
                                        source_geometry_planar,    &
                                        source_geometry_spherical


  implicit none

  private
  public :: initialise_infrastructure

  ! Source and destination XIOS context names
  character(len=*), public, parameter  :: context_dst = "lfric2lfric_destination"
  character(len=*), public, parameter  :: context_src = "lfric2lfric_source"

  ! Source and destination field collection names
  character(len=*), public, parameter  :: source_collection_name = "source_fields"
  character(len=*), public, parameter  :: target_collection_name = "target_fields"

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !> @brief          Sets up required state in preparation for lfric2lfric run.
  !> @details        Calls the `initialise_infrastructure` subroutine that
  !!                 checks the configuration namelist, initialises meshes,
  !!                 extrusions, XIOS contexts and files, field collections and
  !!                 fields.
  !> @param [in,out] modeldb       The structure holding model state
  !> @param [in,out] oasis_clock   Clock for OASIS exchanges
  subroutine initialise_infrastructure( modeldb, oasis_clock )

    implicit none

    type(modeldb_type),     intent(inout) :: modeldb
    type(model_clock_type), allocatable, &
                            intent(inout) :: oasis_clock

    ! Coordinate field
    type(field_type),             pointer :: chi(:)
    type(field_type),             pointer :: panel_id
    type(field_type)                      :: surface_altitude_dst
    type(field_type)                      :: surface_altitude_src
    type(field_type)                      :: surface_altitude_src_on_dst
    type(field_type),             pointer :: src_field
    type(field_type),             pointer :: dst_field
    type(inventory_by_mesh_type), pointer :: chi_inventory
    type(inventory_by_mesh_type), pointer :: panel_id_inventory

    type(function_space_type),    pointer :: vector_space

    !-----------------------
    ! Mesh Pointers
    !-----------------------
    type(mesh_type),     pointer :: mesh_src
    type(mesh_type),     pointer :: twod_mesh_src
    type(mesh_type),     pointer :: mesh_dst
    type(mesh_type),     pointer :: twod_mesh_dst
    type(mesh_type),     pointer :: orography_twod_mesh
    type(mesh_type),     pointer :: orography_mesh

    class(extrusion_type),        allocatable :: extrusion
    type(uniform_extrusion_type), allocatable :: extrusion_2d

    ! Pointers for namelists
    type(namelist_type), pointer :: planet_nml
    type(namelist_type), pointer :: extrusion_nml
    type(namelist_type), pointer :: lfric2lfric_nml
    type(namelist_type), pointer :: files_nml
    type(namelist_type), pointer :: finite_element_nml

    ! Namelist parameters
    character(len=str_def)                 :: mesh_names(2)
    character(len=str_def),    allocatable :: twod_names(:)
    character(len=str_def)                 :: start_dump_filename
    character(len=str_def)                 :: source_file_lbc

    ! lfric2lfric namelist parameters
    integer(kind=i_def)     :: stencil_depth
    integer(kind=i_def)     :: source_geometry
    integer(i_def)          :: mode
    integer(i_def)          :: regrid_method
    real(kind=r_def)        :: domain_bottom
    real(kind=r_def)        :: scaled_radius
    integer(kind=i_def)     :: element_order_h
    integer(kind=i_def)     :: element_order_v

    integer(kind=i_def)     :: extrusion_method
    integer(kind=i_def)     :: number_of_layers
    real(kind=r_def)        :: domain_height

    integer(kind=i_def)            :: i
    integer(kind=i_def), parameter :: one_layer = 1_i_def

    integer(kind=i_def), parameter :: dst = 1
    integer(kind=i_def), parameter :: src = 2

    type(coupling_type),         pointer :: coupling_ptr
    type(field_collection_type), pointer :: cpl_snd_2d
    type(field_collection_type), pointer :: cpl_rcv_2d
    integer(kind=i_def),         pointer :: local_index(:)
    type(coupler_exchange_2d_type)       :: coupler_exchange_2d
    integer(kind=i_def)                  :: ierror
    logical(kind=l_def)                  :: is_running

    !------------------------
    ! XIOS contexts
    !------------------------
    ! Pointer for subroutines used in init_io
    procedure(filelist_populator), pointer :: files_init_ptr
    procedure(callback_clock_arg), pointer :: before_close

    ! Source context pointer and temporary context for setup
    type(lfric_xios_context_type)          :: tmp_io_context_src
    type(lfric_xios_context_type), pointer :: io_context_src
    type(lfric_xios_context_type), pointer :: io_context_dst
    type(linked_list_type),        pointer :: file_list


    ! -------------------------------
    ! Extract namelist variables
    ! -------------------------------
    planet_nml         => modeldb%configuration%get_namelist('planet')
    extrusion_nml      => modeldb%configuration%get_namelist('extrusion')
    lfric2lfric_nml    => modeldb%configuration%get_namelist('lfric2lfric')
    files_nml          => modeldb%configuration%get_namelist('files')
    finite_element_nml => modeldb%configuration%get_namelist('finite_element')

    call planet_nml%get_value( 'scaled_radius', scaled_radius )
    call extrusion_nml%get_value( 'method', extrusion_method )
    call extrusion_nml%get_value( 'number_of_layers', number_of_layers )
    call extrusion_nml%get_value( 'domain_height', domain_height )

    ! Check lfric2lfric configuration settings are allowed
    call lfric2lfric_check_configuration( lfric2lfric_nml )

    call lfric2lfric_nml%get_value( 'mode', mode )
    call lfric2lfric_nml%get_value( 'regrid_method', regrid_method )
    call lfric2lfric_nml%get_value( 'destination_mesh_name', &
                                             mesh_names(dst) )
    call lfric2lfric_nml%get_value( 'source_mesh_name', &
                                             mesh_names(src) )
    call lfric2lfric_nml%get_value( 'source_geometry', source_geometry )
    call files_nml%get_value( 'start_dump_filename', start_dump_filename )
    call finite_element_nml%get_value( 'element_order_h', element_order_h)
    call finite_element_nml%get_value( 'element_order_v', element_order_v)

    !=======================================================================
    ! Mesh
    !=======================================================================
    !-----------------------------------------------------------------------
    ! Create the required extrusions
    !-----------------------------------------------------------------------
    select case (source_geometry)
      case (source_geometry_planar)
        domain_bottom = 0.0_r_def

      case (source_geometry_spherical)
        domain_bottom = scaled_radius

      case default
        call log_event("Invalid geometry for mesh initialisation", &
                       log_level_error)
    end select

    select case (extrusion_method)
      case (method_uniform, method_quadratic, method_geometric)
        allocate( extrusion, source=create_extrusion(                    &
                                       extrusion_method, domain_height,  &
                                       domain_bottom, number_of_layers,  &
                                       prime_extrusion ) )

      case (method_dcmip)
        allocate( extrusion, source=dcmip_extrusion_type(                &
                                       domain_bottom, domain_height,     &
                                       number_of_layers, prime_extrusion ) )

      case (method_um_L38_29t_9s_40km)
        allocate( extrusion, source=um_l38_29t_9s_40km_extrusion_type(   &
                                       domain_bottom, domain_height,     &
                                       number_of_layers, prime_extrusion ) )

      case (method_um_L85_50t_35s_85km)
        allocate( extrusion, source=um_l85_50t_35s_85km_extrusion_type(  &
                                       domain_bottom, domain_height,     &
                                       number_of_layers, prime_extrusion ) )

      case (method_um_L70_50t_20s_80km)
        allocate( extrusion, source=um_l70_50t_20s_80km_extrusion_type(  &
                                       domain_bottom, domain_height,     &
                                       number_of_layers, prime_extrusion ) )

      case (method_um_L70_61t_9s_40km)
        allocate( extrusion, source=um_l70_61t_9s_40km_extrusion_type(   &
                                       domain_bottom, domain_height,     &
                                       number_of_layers, prime_extrusion ) )

      case (method_um_L120_99t_21s_40km)
        allocate( extrusion, source=um_L120_99t_21s_40km_extrusion_type( &
                                       domain_bottom, domain_height,     &
                                       number_of_layers, prime_extrusion ) )

      case (method_um_L140_122t_18s_40km)
        allocate( extrusion, source=um_L140_122t_18s_40km_extrusion_type(&
                                       domain_bottom, domain_height,     &
                                       number_of_layers, prime_extrusion ) )

      case default
        write( log_scratch_space, '(A)' )          &
            "lfric2lfric_infrastructure_mod" //    &
            ': Unrecognised extrusion method: ' // &
            trim(key_from_method( extrusion_method ))
        call log_event( log_scratch_space, log_level_error )

    end select

    extrusion_2d = uniform_extrusion_type( domain_bottom, &
                                           domain_bottom, &
                                           one_layer, twod )

    !-----------------------------------------------------------------------
    ! Create the required meshes
    !-----------------------------------------------------------------------
    stencil_depth = get_required_stencil_depth()
    call init_mesh( modeldb%configuration,       &
                    modeldb%mpi%get_comm_rank(), &
                    modeldb%mpi%get_comm_size(), &
                    mesh_names, extrusion,       &
                    stencil_depth, regrid_method )

    allocate( twod_names, source=mesh_names )
    do i=1, size(twod_names)
      twod_names(i) = trim(twod_names(i))//'_2d'
    end do
    call create_mesh( mesh_names, extrusion_2d, &
                      alt_name=twod_names )

    !=======================================================================
    ! Build the FEM function spaces and coordinate fields
    !=======================================================================
    !-----------------------------------------------------------------------
    ! Create the FEM function spaces
    !-----------------------------------------------------------------------
    ! Create FEM specifics (function spaces and chi field)
    chi_inventory => get_chi_inventory()
    panel_id_inventory => get_panel_id_inventory()
    call init_fem( mesh_collection, chi_inventory, panel_id_inventory )

    !-----------------------------------------------------------------------
    ! Assign pointers to the correct meshes
    !-----------------------------------------------------------------------
    mesh_src      => mesh_collection%get_mesh(trim(mesh_names(src)))
    twod_mesh_src => mesh_collection%get_mesh(trim(twod_names(src)))
    mesh_dst      => mesh_collection%get_mesh(trim(mesh_names(dst)))
    twod_mesh_dst => mesh_collection%get_mesh(trim(twod_names(dst)))

    ! Log this change
    call log_event('Source mesh set to: ' // mesh_names(src),         &
                   log_level_debug)
    call log_event('Source 2D mesh set to: ' // twod_names(src),      &
                   log_level_debug)
    call log_event('Destination mesh set to: ' // mesh_names(dst),    &
                   log_level_debug)
    call log_event('Destination 2D mesh set to: ' // twod_names(dst), &
                   log_level_debug)

    !=======================================================================
    ! Setup I/O system
    !=======================================================================
    !-----------------------------------------------------------------------
    ! Create the IO context for destination files
    !-----------------------------------------------------------------------
    ! Set a pointer to the method for setting files in the destination
    ! IO context
    files_init_ptr => init_lfric2lfric_dst_files

    ! Initialise the IO context with all the required info
    call init_io( context_dst,                      &
                  mesh_names(dst),                  &
                  modeldb,                          &
                  chi_inventory,                    &
                  panel_id_inventory,               &
                  populate_filelist=files_init_ptr  )

    call modeldb%io_contexts%get_io_context(context_dst, io_context_dst)

    !=======================================================================
    ! Initialise the OASIS clock
    !=======================================================================
    ! If Oasis is used, it can only provide one coupling per clock tick - so we
    ! introduce a pseudo clock, that ticks every coupling, rather than every
    ! timestep. We don't know how many 2d fields will be passed through the
    ! coupler yet, so set the upper limit to "huge" to support everything
    oasis_clock = model_clock_type(1_i_def, huge(1_i_def), &
                                        1.0_r_second, 0.0_r_second)
    is_running = oasis_clock%tick()

    !=======================================================================
    ! Initialise destination orography
    !=======================================================================
    if ( orog_init_option == orog_init_option_analytic .or. &
         orog_init_option == orog_init_option_ancil .or.    &
         orog_init_option == orog_init_option_start_dump ) then

      vector_space => function_space_collection%get_fs( twod_mesh_dst, 0, 0, W3)
      call surface_altitude_dst%initialise(vector_space,         &
                                    name='surface_altitude_dst', &
                                    halo_depth = twod_mesh_dst%get_halo_depth())

      ! Get pointers to the destination mesh:
      orography_mesh => mesh_collection%get_mesh(mesh_names(dst))
      orography_twod_mesh => mesh_collection%get_mesh(orography_mesh, TWOD)

      ! Set up surface altitude field - this will be used to generate orography
      call init_altitude( orography_twod_mesh, surface_altitude_dst )
    end if

    !-----------------------------------------------------------------------
    ! Create the IO context for source files
    !-----------------------------------------------------------------------
    ! Because the source files are not the same as the 'prime mesh', we have
    ! to initialise the source context manually with the desired mesh

    ! Add the source context to modeldb and return a pointer to it
    call tmp_io_context_src%initialise(context_src)
    call modeldb%io_contexts%add_context(tmp_io_context_src)
    call modeldb%io_contexts%get_io_context(context_src, io_context_src)

    ! Get the file list of context and populate
    file_list => io_context_src%get_filelist()
    call init_lfric2lfric_src_files( file_list, modeldb )

    ! Get panel_id and chi from correct mesh
    call chi_inventory%get_field_array(mesh_src, chi)
    call panel_id_inventory%get_field(mesh_src, panel_id)

    ! Using correct chi and panel_id, initialise xios context for source mesh
    nullify( before_close )
    call io_context_src%initialise_xios_context( modeldb%mpi%get_comm(), &
                                                 chi,                    &
                                                 panel_id,               &
                                                 modeldb%clock,          &
                                                 modeldb%calendar,       &
                                                 before_close            )

    !=======================================================================
    ! Initialise source orography
    !=======================================================================
    if ( orog_init_option == orog_init_option_analytic .or. &
         orog_init_option == orog_init_option_ancil .or.    &
         orog_init_option == orog_init_option_start_dump ) then

      ! Get pointers to the source mesh:
      orography_mesh => mesh_collection%get_mesh(mesh_names(src))
      orography_twod_mesh => mesh_collection%get_mesh(orography_mesh, TWOD)

      call surface_altitude_src%initialise(vector_space,         &
                                    name='surface_altitude_src', &
                                    halo_depth = twod_mesh_src%get_halo_depth())

      ! Set up surface altitude field - this will be used to generate orography
      call init_altitude( orography_twod_mesh, surface_altitude_src )
    end if

    !=======================================================================
    ! Create and initialise prognostic fields
    !=======================================================================
    if (mode == mode_ics) then
      call init_lfric2lfric( modeldb, context_src, context_dst,               &
                             start_dump_filename, mode,                       &
                             source_collection_name, mesh_src, twod_mesh_src, &
                             target_collection_name, mesh_dst, twod_mesh_dst )
    else if (mode == mode_lbc) then
      call lfric2lfric_nml%get_value( 'source_file_lbc', source_file_lbc )
      call init_lfric2lfric( modeldb, context_src, context_dst,               &
                             source_file_lbc, mode,                           &
                             source_collection_name, mesh_src, twod_mesh_src, &
                             target_collection_name, mesh_dst, twod_mesh_dst )
    end if

    !=======================================================================
    ! Initialize variables for each regrid method
    !=======================================================================
    select case (regrid_method)
      case (regrid_method_map)
        if (regrid_method == regrid_method_map) then
          call assign_mesh_maps(twod_names)
        end if

      case (regrid_method_lfric2lfric)

      case (regrid_method_oasis)
#ifdef MCT
        ! Create oasis partitions and coupling variables
        ! Source fields
        call lfric2lfric_init_coupler_src(twod_mesh_src, "coupling",     &
                                       element_order_h, element_order_v, &
                                       modeldb)
        ! Destination fields
        call lfric2lfric_init_coupler_dst(twod_mesh_dst, "coupling_dst", &
                                       element_order_h, element_order_v, &
                                       modeldb)

        ! Finish coupling definition
        call lfric2lfric_end_coupler_init(modeldb, "coupling")
#else
        write(log_scratch_space,'(A)')                          &
            'ERROR: selected regrid_method=oasis, but OASIS libraries '// &
            'not available. Compile with MCT option.'
        call log_event( log_scratch_space, log_level_error )
#endif
    end select

    !=======================================================================
    ! The lateral boundary conditions of limited-area models (LAMs) are
    ! implemented by updating the data values at the boundaries with values
    ! from a "driving model". To avoid discontinuities, there is a smooth
    ! transition from the driving model data to the LAM data over a blending
    ! region. In order to be consistent, the same blending process has to be
    ! applied to the model orographies.
    !
    ! Blend source orography over the blending region of the dest orog
    !=======================================================================
    if ( orog_init_option == orog_init_option_analytic .or. &
         orog_init_option == orog_init_option_ancil .or.    &
         orog_init_option == orog_init_option_start_dump ) then

      ! Regrid the source orography onto the mesh of the destination orography
      ! ----------------------------------------------------------------------
      cpl_snd_2d => modeldb%fields%get_field_collection("cpl_snd_2d")
      call cpl_snd_2d%get_field("src_face", src_field)

      cpl_rcv_2d => modeldb%fields%get_field_collection("cpl_rcv_2d")
      call cpl_rcv_2d%get_field("dst_face", dst_field)

      call invoke(setval_x(src_field, surface_altitude_src))

      ierror=0
      coupling_ptr => get_coupling_from_collection(modeldb%values, "coupling" )
      local_index => coupling_ptr%get_local_index()
      ! send the src orog via OASIS
      coupling_ptr => get_coupling_from_collection(modeldb%values, "coupling" )
      local_index => coupling_ptr%get_local_index()
      call coupler_exchange_2d%initialise(src_field, local_index)
      call coupler_exchange_2d%set_time(oasis_clock)
      call coupler_exchange_2d%copy_from_lfric(ierror)
      call coupler_exchange_2d%clear()

      ! receive the layer via OASIS
      coupling_ptr => get_coupling_from_collection(modeldb%values, "coupling_dst" )
      local_index => coupling_ptr%get_local_index()
      call coupler_exchange_2d%initialise(dst_field, local_index)
      call coupler_exchange_2d%set_time(oasis_clock)
      call coupler_exchange_2d%copy_to_lfric(ierror)
      call coupler_exchange_2d%clear()

      ! Done the first coupling - so advance the pseudo-clock
      is_running = oasis_clock%tick()

      ! Copy the horizontally regridded src orography into dst orography mesh
      ! -----------------------------------------------------------
      call surface_altitude_dst%copy_field_properties( &
                                                    surface_altitude_src_on_dst)
      call invoke(setval_x(surface_altitude_src_on_dst, dst_field))

      ! Blend the regridded src orography with the dst orography
      ! --------------------------------------------------------
      call blend_orography(surface_altitude_dst, surface_altitude_src_on_dst, &
                           mesh_names(dst))

      call setup_orography_alg( mesh_names(dst:dst),            &
                                orography_mesh%get_mesh_name(), &
                                chi_inventory,                  &
                                panel_id_inventory,             &
                                surface_altitude_dst )
    end if

    deallocate(twod_names)
    deallocate(extrusion)

  end subroutine initialise_infrastructure

end module lfric2lfric_infrastructure_mod
