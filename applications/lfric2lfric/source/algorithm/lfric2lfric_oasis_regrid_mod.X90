!-----------------------------------------------------------------------------
! (C) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Algorithm to perform regridding using a weight file with OASIS
!> @details OASIS can only perform 2D interpolation, so the steps
!>          that need to take place are:
!>            1. Extract one vertical level and multi-data entry from a
!>               field in the source mesh
!>            2. Send the extracted data with OASIS, which performs
!>               the regridding of the 2d data to the destination mesh
!>            3. Receive the 2d field in the destination mesh with OASIS
!>            4. Insert vertical level and multi-data entry in the
!>               destination mesh into the right place in the destination
!>               field
!>            5. The OASIS clock is updated
!>
!>          This process is repeated until all full destination fields
!>          have been constructed. The update of the OASIS clock allows
!>          the definition of a single 2d coupling, rather than defining
!>          a 2d coupling field for each vertical level, multi-data
!>          entry, and field that has to be processed, and performing a
!>          single coupling time step.
!>
!>          Fields in the W2 function space are not processed and are
!>          filled with zeroes in the output. This happens because there
!>          is not a definitive format for the W2 function space yet.
module lfric2lfric_oasis_regrid_mod

  ! lfric modules
  use constants_mod,        only: i_def, r_def, l_def
  use fs_continuity_mod,    only: W3, Wtheta
  use driver_modeldb_mod,   only: modeldb_type
  use model_clock_mod,      only: model_clock_type
#ifdef MCT
  use coupling_mod,         only: coupling_type, &
                                  get_coupling_from_collection
  use coupler_exchange_2d_mod,  &
                            only: coupler_exchange_2d_type
#endif
  use field_mod,            only: field_type
  use field_collection_mod, only: field_collection_type
  use function_space_mod,   only: function_space_type
  use log_mod,              only: log_event, log_scratch_space, &
                                  log_level_info, log_level_error

  ! lfric2lfric modules
  use sci_level_insert_kernel_mod, only:                            &
                                level_insert_kernel_type
  use sci_level_extract_kernel_mod, only:                           &
                                level_extract_kernel_type

  implicit none

  private
  public :: lfric2lfric_oasis_regrid

contains

  !> @brief Perform regridding of a field collection using weight files
  !>        and OASIS
  !> @param[inout] modeldb         The structure that holds model state
  !> @param[inout] clock           Clock for oasis time
  !> @param[out]   field_dst       Field in the destination mesh obtained
  !>                               after regridding the field in the
  !>                               source mesh
  !> @param[in]    field_src       Field in the source mesh
  subroutine lfric2lfric_oasis_regrid(modeldb, clock, field_dst, field_src)


    implicit none

    type(modeldb_type),         intent(inout) :: modeldb
    type(model_clock_type),     intent(inout) :: clock
    type(field_type), pointer,  intent(inout) :: field_dst
    type(field_type), pointer,  intent(in)    :: field_src

#ifdef MCT
    ! Local variables
    integer(i_def)    :: l, k, nlayers, ndf, fs
    integer(i_def)    :: ndata, ierror
    type(function_space_type),  pointer    :: vector_space => null()
    type(field_type), pointer              :: src_field => null()
    type(field_type), pointer              :: dst_field => null()
    type(coupler_exchange_2d_type)         :: coupler_exchange_2d
    type(coupling_type), pointer           :: coupling_ptr
    type(field_collection_type), pointer   :: cpl_snd_2d => null()
    type(field_collection_type), pointer   :: cpl_rcv_2d => null()
    integer(i_def), pointer                :: local_index(:)
    logical(l_def)                         :: is_running
#endif


    call invoke(setval_c(field_dst, 0.0_r_def))

#ifdef MCT
    fs = field_src%which_function_space()

    if (fs == W3 .or. fs == Wtheta) then
      ! Find number of layers and data levels
      vector_space => field_src%get_function_space()

      nlayers = vector_space%get_nlayers()
      ndf = vector_space%get_ndf()

      nlayers = nlayers + ndf - 1
      ndata = vector_space%get_ndata()

      ! Get the 2D fields where to store layer and field level data
      cpl_snd_2d => modeldb%fields%get_field_collection("cpl_snd_2d")
      call cpl_snd_2d%get_field("src_face", src_field)

      cpl_rcv_2d => modeldb%fields%get_field_collection("cpl_rcv_2d")
      call cpl_rcv_2d%get_field("dst_face", dst_field)

      ! Extract data layer by layer, regrid it, and place in the destination field
      do l = 0, nlayers - 1
        do k = 0, ndata - 1
          ! Extract one layer and one set of data
          call invoke(name = "extract_layer",                       &
                              level_extract_kernel_type(src_field,  &
                                                 field_src, l, k))

          ! send the layer via OASIS
          ! Extract the version that was actaully placed in the collection
          coupling_ptr => get_coupling_from_collection(modeldb%values, "coupling" )
          local_index => coupling_ptr%get_local_index()
          call coupler_exchange_2d%initialise(src_field, local_index)
          call coupler_exchange_2d%set_time(clock)
          call coupler_exchange_2d%copy_from_lfric(ierror)
          call coupler_exchange_2d%clear()

          ! receive the layer via OASIS
          ! Extract the version that was actaully placed in the collection
          coupling_ptr => get_coupling_from_collection(modeldb%values, "coupling_dst" )
          local_index => coupling_ptr%get_local_index()
          call coupler_exchange_2d%initialise(dst_field, local_index)
          call coupler_exchange_2d%set_time(clock)
          call coupler_exchange_2d%copy_to_lfric(ierror)
          call coupler_exchange_2d%clear()

          ! write the received layer information in the destination field
          call invoke(name = "insert_layer",                       &
                              level_insert_kernel_type(field_dst,  &
                                                dst_field, l, k))

          ! Update the coupling time
          is_running = clock%tick()

        end do
      end do

    else
      write(log_scratch_space, '(A)') "Function space can not " //            &
                                      "be processed yet, skipping field"
      call log_event(log_scratch_space, log_level_info)
    end if
#else
    write(log_scratch_space, '(A)')  &
        "lfric2lfric_oasis_regrid: to use OASIS, " // &
        "cpp directive MCT must be set. " //          &
        "Output fields will be initialized to zero."
    call log_event(log_scratch_space, log_level_info)
#endif

  end subroutine lfric2lfric_oasis_regrid

end module lfric2lfric_oasis_regrid_mod
