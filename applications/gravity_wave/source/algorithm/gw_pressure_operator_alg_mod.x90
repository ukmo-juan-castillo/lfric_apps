!-----------------------------------------------------------------------------
! (C) Crown copyright 2017 Met Office. All rights reserved.
! For further details please refer to the file LICENCE which you should have
! received as part of this distribution.
!-----------------------------------------------------------------------------
!> @brief Application of the Helmholtz operator in the gravity wave system.
!>
!> @details The Helmholtz operator is given by
!!
!!    \f[ H = Id + \alpha^2(\Delta t)^2 c_s^2 M_3^{-1} D H_B^{-1} D^T\f]
!!
!!    with the lumped matrix \f$H_B\f$ defined by
!!
!!    \f[ H_B=\tilde{M}_2+\alpha^2(\Delta t)^2N^2\tilde{Q \tilde{M}_b^{-1}Q^T} \f]
!!
!!    This module provides a type derived from the abstract operator type which
!!    allows application of this Helmholtz operator.

module gw_pressure_operator_alg_mod

  use sci_hierarchical_linear_operator_mod, &
                               only: abstract_hierarchical_linear_operator_type
  use vector_mod,                         only: abstract_vector_type
  use r_solver_field_mod,                 only: r_solver_field_type
  use constants_mod,                      only: i_def, r_solver, l_def
  use solver_constants_mod,               only: get_inverse_mass_matrix_r_solver
  use fs_continuity_mod,                  only: W0, W2, W3, Wtheta
  use sci_r_solver_field_vector_mod,      only: r_solver_field_vector_type
  use timestepping_config_mod,            only: dt, &
                                                alpha

  use initial_temperature_config_mod,     only: bvf_square

  use operator_mod,                       only: operator_type, &
                                                r_solver_operator_type
  use field_indices_mod,                  only: igw_u, igw_p, igw_b
  use log_mod,                            only: log_event,       &
                                                LOG_LEVEL_ERROR, &
                                                LOG_LEVEL_INFO,  &
                                                log_scratch_space
  use mesh_mod,                           only: mesh_type
  use gravity_wave_constants_config_mod,  only: cs_square,  &
                                                b_space,    &
                                                b_space_w0, &
                                                b_space_w3, &
                                                b_space_wtheta
  use function_space_chain_mod,           only: multigrid_function_space_chain

  implicit none

  type, public, extends(abstract_hierarchical_linear_operator_type) :: &
                        gw_pressure_operator_type
  private
     !> Off-centering parameter in SI timestepping
     real(kind=r_solver) :: alpha
     !> Temporary fields used in operator application
     type(r_solver_field_type) :: grad_p, div_grad_p
     !> Lumped inverse \f$\tilde{H}_B^{-1}\f$
     type(r_solver_field_type) :: Hb_lumped_inv
     !> Multigrid level
     integer(kind=i_def) :: level
     !> divergence operator
     type(r_solver_operator_type) :: div
     contains
     !> Return the lumped inverse \f$\tilde{H}_B^{-1}\f$
     procedure, public  :: get_Hb_lumped_inv
     !> over-ride the abstract interface
     !> param[in] self a linear operator
     !> param[in] x a fieldvector the linear operator is applied to
     !> param[inout] y a fieldvector, the result.
     procedure, public  :: apply => apply_gw_pressure_operator
     procedure, private :: apply_gw_pressure_operator
     !> performs a deep copy (for overriding the "=" operator)
     !> @param[out] dest   gw_pressure_operator_type lhs
     !> @param[in]  source gw_pressure_operator_type rhs
     procedure, public  :: gw_pressure_operator_assign
     procedure, public  :: coarsen => coarsen_gw_pressure_operator
     procedure, private :: coarsen_gw_pressure_operator

     final              :: destroy_gw_pressure_operator

     !> Override default assignment for gw_pressure_operator_type pairs.
     generic            :: assignment(=) => gw_pressure_operator_assign

  end type gw_pressure_operator_type

  interface gw_pressure_operator_type
     module procedure gw_pressure_operator_constructor
  end interface

contains

  !> @brief Construct new instance of type.
  !>
  !> @details Extract function spaces and build the lumped approximate
  !!          inverse \f$ \tilde{H}_b^{-1} \f$ as well as other operators
  !!          such as div and grad for the Helmholtz operator application.
  !>
  !> @param[in] level Multigrid level
  !> @return Instance of the Helmholtz operator
  function gw_pressure_operator_constructor(level) result(self)
    use field_mod,                          only: field_type
    use sci_geometric_constants_mod,        only: get_coordinates, get_panel_id
    use function_space_mod,                 only: function_space_type
    use fs_continuity_mod,                  only: W2, W0, W3, Wtheta
    use finite_element_config_mod,          only: element_order_h, &
                                                  element_order_v
    use quadrature_xyoz_mod,                only: quadrature_xyoz_type
    use quadrature_rule_gaussian_mod,       only: quadrature_rule_gaussian_type
    use compute_q_operator_kernel_mod,      only: compute_q_operator_type
    use matrix_vector_kernel_mod,           only: matrix_vector_kernel_type
    use transpose_matrix_vector_kernel_mod, &
                                      only: transpose_matrix_vector_kernel_type
    use function_space_collection_mod,      only: function_space_collection
    use mesh_collection_mod,                only: mesh_collection
    use multigrid_config_mod,               only: chain_mesh_tags
    use base_mesh_config_mod,               only: prime_mesh_name
    use sci_operator_algebra_kernel_mod,    only: operator_setval_x_kernel_type
    use sci_compute_mass_matrix_kernel_w_scalar_mod, &
                                 only: compute_mass_matrix_kernel_w_scalar_type
    use sci_compute_mass_matrix_kernel_w2_mod, &
                                 only: compute_mass_matrix_kernel_w2_type
    use sci_compute_div_operator_kernel_mod, &
                                 only: compute_div_operator_kernel_type

    implicit none

    type(gw_pressure_operator_type)     :: self
    integer(kind=i_def), intent(in)     :: level
    type(function_space_type), pointer  :: wu => null(), &
                                           wb => null(), &
                                           wp => null()
    type(field_type), pointer           :: chi(:) => null()
    type(field_type), pointer           :: panel_id => null()
    type(mesh_type), pointer            :: mesh => null()
    real(kind=r_solver)                 :: const1
    type(r_solver_field_type)           :: ones, M_lumped, &
                                           ones_u, M_lumped_u, &
                                           Mb_lumped_inv, QT1
    type(operator_type)                 :: Mm
    type(r_solver_operator_type)        :: Mu, Mb
    type(quadrature_xyoz_type)          :: qr
    type(quadrature_rule_gaussian_type) :: quadrature_rule
    type(r_solver_operator_type)        :: Q
    logical(kind=l_def)                 :: extend_mesh
    type(operator_type)                 :: div_r_def


    call log_event( 'Constructing pressure operator...', LOG_LEVEL_INFO )

    self%alpha = real(alpha, r_solver)
    self%level = level

    ! Get needed function spaces
    if ( level == 1 ) then
      ! Prime mesh
      mesh => mesh_collection%get_mesh( prime_mesh_name )
    else
      ! Multigrid mesh
      mesh => mesh_collection%get_mesh( chain_mesh_tags(level) )
    end if

    wp => function_space_collection%get_fs( mesh, element_order_h, &
                                            element_order_v, W3 )
    wu => function_space_collection%get_fs( mesh, element_order_h, &
                                            element_order_v, W2 )
    select case(b_space)
      case(b_space_w0)
         wb => function_space_collection%get_fs( mesh, element_order_h, &
                                                 element_order_v, W0 )
      case(b_space_w3)
         wb => function_space_collection%get_fs( mesh, element_order_h, &
                                                 element_order_v, W3 )
      case(b_space_wtheta)
         wb => function_space_collection%get_fs( mesh, element_order_h, &
                                                 element_order_v, Wtheta )
    end select

    ! Temporaries required in operator application
    call self%grad_p%initialise( vector_space = wu )
    call self%div_grad_p%initialise( vector_space = wp )

    ! Compute inverse approximate \tilde{M}_b^{-1}
    qr = quadrature_xyoz_type(element_order_h+2, element_order_h+2, &
                              element_order_v+2, quadrature_rule)
    chi => get_coordinates(mesh%get_id())
    panel_id => get_panel_id(mesh%get_id())
    extend_mesh = .false.
    call ones%initialise( vector_space = wb )
    call M_lumped%initialise( vector_space = wb )
    call Mb_lumped_inv%initialise( vector_space = wb )
    call Mb%initialise( wb, wb )
    call invoke( compute_mass_matrix_kernel_w_scalar_type(Mb, chi, panel_id, &
                                                          extend_mesh, qr),  &
                 setval_c( ones,     1.0_r_solver ),                         &
                 setval_c( M_lumped, 0.0_r_solver ),                         &
                 matrix_vector_kernel_type(M_lumped, ones, Mb),              &
                 X_divideby_Y(Mb_lumped_inv, ones, M_lumped) )

    ! Compute Q (projection) operator
    call Q%initialise( wu, wb )
    call invoke( compute_q_operator_type(Q, qr) )

    ! Compute inverse approximate \f$ \tilde{H}_b^{-1} \f$
    call ones_u%initialise( vector_space = wu )
    call M_lumped_u%initialise( vector_space = wu )
    call QT1%initialise( vector_space = wb )
    call self%Hb_lumped_inv%initialise( vector_space = wu )
    call Mm%initialise( wu , wu )
    call Mu%initialise( wu , wu )
    const1 = self%alpha**2*real(dt**2*bvf_square, r_solver)
    call invoke( compute_mass_matrix_kernel_w2_type(Mm, chi, panel_id, qr), &
                 operator_setval_x_kernel_type( Mu, Mm ),                   &
                 setval_c(ones_u,     1.0_r_solver),                        &
                 setval_c(M_lumped_u, 0.0_r_solver),                        &
                 setval_c(QT1,        0.0_r_solver),                        &
                 transpose_matrix_vector_kernel_type(QT1, ones_u, Q),       &
                 inc_X_times_Y(QT1, Mb_lumped_inv),                         &
                 matrix_vector_kernel_type(M_lumped_u, QT1, Q),             &
                 inc_a_times_X(const1, M_lumped_u),                         &
                 matrix_vector_kernel_type(M_lumped_u, ones_u, Mu),         &
                 X_divideby_Y(self%Hb_lumped_inv, ones_u, M_lumped_u) )

    ! Compute div
    call self%div%initialise( wp, wu )
    call div_r_def%initialise( wp, wu )
    call invoke( compute_div_operator_kernel_type( div_r_def, chi,   &
                                                   panel_id, qr ),   &
                 operator_setval_x_kernel_type( self%div, div_r_def ) )

    call log_event( 'done', LOG_LEVEL_INFO )

    nullify(mesh)

  end function gw_pressure_operator_constructor

  !> @brief Performs a deep copy between gw_pressure_operator_type pairs
  !!        (for overriding the "=" operator).
  !>
  !> @param[out] dest   gw_pressure_operator_type lhs
  !> @param[in]  source gw_pressure_operator_type rhs
  subroutine gw_pressure_operator_assign(dest, source)

    implicit none
    class(gw_pressure_operator_type), intent(in)  :: source
    class(gw_pressure_operator_type), intent(out) :: dest

    ! Deep copy of the contents of the pressure_operator_type
    dest%alpha = source%alpha
    dest%level = source%level
    call source%grad_p%copy_field_properties(dest%grad_p)
    call source%div_grad_p%copy_field_properties(dest%div_grad_p)
    call source%Hb_lumped_inv%copy_field_properties(dest%Hb_lumped_inv)

    call dest%div%initialise( source%div%get_fs_to(), source%div%get_fs_from() )

    call invoke( setval_X(dest%grad_p, source%grad_p), &
                 setval_X(dest%div_grad_p, source%div_grad_p), &
                 setval_X(dest%Hb_lumped_inv, source%Hb_lumped_inv), &
                 operator_setval_x_kernel_type( dest%div, source%div ) )

  end subroutine gw_pressure_operator_assign

  !> @brief Return lumped inverse matrix.
  !>
  !> @details Return the matrix \f$\tilde{H}_b^{-1}\f$. This matrix is
  !!          also used in the mixed preconditioner and returning it here
  !!          avoids building it twice.
  !>
  !> @param [in] self Instance of object
  !> @return A copy of the lumped inverse Hb operator
  function get_Hb_lumped_inv(self) result(Hb_lumped_inv)
    implicit none
    class(gw_pressure_operator_type), intent(in) :: self
    type(r_solver_field_type) :: Hb_lumped_inv
    call self%Hb_lumped_inv%copy_field_properties(Hb_lumped_inv)
    call invoke( setval_X(Hb_lumped_inv, self%Hb_lumped_inv))
  end function get_Hb_lumped_inv

  !> @brief Apply Helmholtz operator to a pressure field to obtain \f$y=Hx\f$.
  !>
  !> @param[in,out] self Instance of gw_pressure_operator_type
  !> @param[in] x Field \f$x\f$ to apply operator to
  !> @param[in,out] y Resulting field \f$y=Hx\f$ in pressure space
  subroutine apply_gw_pressure_operator(self, x, y)
    use dg_matrix_vector_kernel_mod,        only: dg_matrix_vector_kernel_type
    use transpose_matrix_vector_kernel_mod, only: transpose_matrix_vector_kernel_type
    use sci_enforce_bc_kernel_mod,          only: enforce_bc_kernel_type

    implicit none
    class(gw_pressure_operator_type), intent(inout) :: self
    class(abstract_vector_type),      intent(in)    :: x
    class(abstract_vector_type),      intent(inout) :: y
    real(kind=r_solver) :: const

    type(mesh_type), pointer :: mesh => null()

    type(r_solver_operator_type), pointer :: M3_inv => null()

    ! Workaround for PSyclone to get pointers of the correct type for x and y
    type(r_solver_field_type), pointer :: x_vec => null(), &
                                          y_vec => null()

    select type (x)

    type is (r_solver_field_vector_type)

      select type (y)

      type is (r_solver_field_vector_type)
        ! Get pointers to x and y abstract types
        x_vec => x%get_field_from_position(1)
        y_vec => y%get_field_from_position(1)

        mesh    => x%vector(1)%get_mesh()
        M3_inv => get_inverse_mass_matrix_r_solver(W3, mesh%get_id())
        const = self%alpha**2*real(dt**2*cs_square, r_solver)
        call invoke( setval_c(self%grad_p, 0.0_r_solver),             &
                     transpose_matrix_vector_kernel_type(self%grad_p, &
                                                         x_vec,       &
                                                         self%div),   &
                     enforce_bc_kernel_type(self%grad_p),             &
                     inc_X_times_Y(self%grad_p, self%Hb_lumped_inv),  &
                     dg_matrix_vector_kernel_type(self%div_grad_p,    &
                                                  self%grad_p,        &
                                                  self%div),          &
                     dg_matrix_vector_kernel_type(y_vec,              &
                                                  self%div_grad_p,    &
                                                  M3_inv),            &
                     inc_aX_plus_Y(const, y_vec, x_vec) )

          nullify( M3_inv )

      class default

        write(log_scratch_space, '(A)') &
              "gw_pressure_operator_alg_mod: incorrect vector_type argument y"
        call log_event(log_scratch_space, LOG_LEVEL_ERROR)

      end select

    class default

      write(log_scratch_space, '(A)') &
            "gw_pressure_operator_alg_mod: incorrect vector_type argument x"
      call log_event(log_scratch_space, LOG_LEVEL_ERROR)

    end select

    nullify( mesh )
    nullify( x_vec, y_vec )

  end subroutine apply_gw_pressure_operator

  !> @brief Return a coarsened version of the operator on the
  !!        next level of the multigrid hierarchy.
  !>
  !> @param[in] self Instance of gw_pressure_operator_type
  !> @param[in,out] coarse_operator Coarsened version of the operator on
  !!                                the next multigrid level
  subroutine coarsen_gw_pressure_operator(self,coarse_operator)
    use function_space_mod, only: function_space_type
    implicit none
    class(gw_pressure_operator_type), intent(in) :: self
    class(abstract_hierarchical_linear_operator_type), allocatable, intent(inout) :: coarse_operator
    allocate(coarse_operator, &
             source=gw_pressure_operator_type(self%level+1))
  end subroutine coarsen_gw_pressure_operator

  !> @brief Finalizer for the Helmholtz operator.
  !>
  !> @param[in,out] self The pressure operator
  subroutine destroy_gw_pressure_operator(self)
    implicit none
    type(gw_pressure_operator_type), intent(inout) :: self
  end subroutine destroy_gw_pressure_operator

end module gw_pressure_operator_alg_mod
