!-----------------------------------------------------------------------------
! (c) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module controlling the transport of the shallow water miniapp's
!!        prognostic variables.

module swe_transport_control_alg_mod

  use combine_w2_field_kernel_mod,       only: combine_w2_field_kernel_type
  use constants_mod,                     only: i_def, r_def, l_def, r_tran
  use derived_config_mod,                only: bundle_size
  use sci_enforce_bc_kernel_mod,         only: enforce_bc_kernel_type
  use field_mod,                         only: field_type
  use field_indices_mod,                 only: isw_u, isw_g, isw_b, isw_q
  use finite_element_config_mod,         only: element_order, nqp_exact
  use fs_continuity_mod,                 only: W1, W3, W2v
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use geometric_constants_mod,           only: get_coordinates,      &
                                               get_panel_id,         &
                                               get_face_selector_ew, &
                                               get_face_selector_ns
  use integer_field_mod,                 only: integer_field_type
  use local_mesh_mod,                    only: local_mesh_type
  use log_mod,                           only: log_event,       &
                                               LOG_LEVEL_ERROR, &
                                               LOG_LEVEL_INFO,  &
                                               log_scratch_space
  use matrix_vector_kernel_mod,          only: matrix_vector_kernel_type
  use mesh_mod,                          only: mesh_type
  use mesh_collection_mod,               only: mesh_collection
  use model_clock_mod,                   only: model_clock_type
  use quadrature_rule_gaussian_mod,      only: quadrature_rule_gaussian_type
  use quadrature_xyoz_mod,               only: quadrature_xyoz_type
  use runtime_tools_mod,                 only: find_mesh_index
  use sci_field_vector_mod,              only: field_vector_type
  use shallow_water_settings_config_mod, only: thermal_swe,            &
                                               momentum_form,          &
                                               momentum_form_momentum, &
                                               momentum_form_vector_invariant
  use transport_config_mod,              only: cheap_update
  use transport_enumerated_types_mod,    only: scheme_mol_3d, &
                                               scheme_split,  &
                                               splitting_hv,  &
                                               splitting_vh,  &
                                               splitting_strang_vhv
  use transport_metadata_mod,            only: transport_metadata_type
  use transport_metadata_collection_mod, only: transport_metadata_collection_type
  use transport_runtime_alg_mod,         only: transport_runtime_type
  use transport_runtime_collection_mod,  only: init_transport_runtime_collection, &
                                               set_transport_runtime,             &
                                               get_transport_runtime
  use vorticity_advection_kernel_mod,    only: vorticity_advection_kernel_type

  implicit none

  private

  type(transport_metadata_collection_type) :: transport_metadata_collection

  ! Contained suroutines
  public :: swe_transport_control_alg_init
  public :: swe_transport_control_alg_step
  public :: swe_tracer_transport_alg
  public :: swe_transport_control_alg_final

contains

  !=============================================================================
  !> @brief Create all the initialisation structures required for transport in
  !!        the shallow water model.
  !> @params[in] mesh_id   The ID of the mesh to initialise on
  subroutine swe_transport_control_alg_init(mesh)

    use reconstruct_w3_field_alg_mod, only: reconstruct_w3_field_alg_init
    use wt_advective_update_alg_mod,  only: wt_advective_update_alg_init
    use transport_config_mod,         only: profile_size,            &
                                            field_names,             &
                                            equation_form,           &
                                            scheme,                  &
                                            splitting,               &
                                            horizontal_method,       &
                                            vertical_method,         &
                                            enforce_min_value,       &
                                            min_value,               &
                                            log_space,               &
                                            reversible,              &
                                            horizontal_monotone,     &
                                            vertical_monotone,       &
                                            vertical_monotone_order, &
                                            special_edges_monotone,  &
                                            ffsl_splitting

    implicit none

    type(mesh_type), pointer, intent(in) :: mesh

    integer(kind=i_def)           :: config
    type(transport_metadata_type) :: transport_metadata

    integer(kind=i_def), allocatable :: local_mesh_ids(:)
    type(local_mesh_type),   pointer :: local_mesh => null()

    ! Set up metadata field collection
    transport_metadata_collection = transport_metadata_collection_type()

    ! Set up configs using namelist entries
    do config = 1, profile_size

      write(log_scratch_space,'(3A)') 'Setting up ',trim(field_names(config)),' transport metadata'
      call log_event(log_scratch_space, LOG_LEVEL_INFO)

      transport_metadata = transport_metadata_type( field_names(config),             &
                                                    equation_form(config),           &
                                                    splitting(config),               &
                                                    scheme(config),                  &
                                                    horizontal_method(config),       &
                                                    vertical_method(config),         &
                                                    horizontal_monotone(config),     &
                                                    vertical_monotone(config),       &
                                                    vertical_monotone_order(config), &
                                                    special_edges_monotone(config),  &
                                                    enforce_min_value(config),       &
                                                    min_value(config),               &
                                                    log_space(config),               &
                                                    reversible(config),              &
                                                    ffsl_splitting(config) )

      call transport_metadata_collection%set_transport_metadata(transport_metadata)

    end do

    ! Initialise any necessary transport fields or coefficients
    call reconstruct_w3_field_alg_init( mesh )
    call wt_advective_update_alg_init( mesh )

    ! Initialise transport_runtime_collection
    ! Only one mesh
    allocate(local_mesh_ids(1))
    local_mesh => mesh%get_local_mesh()
    local_mesh_ids(1) = local_mesh%get_id()
    call init_transport_runtime_collection(local_mesh_ids)

  end subroutine swe_transport_control_alg_init


  !=============================================================================
  !> @brief Advection of prognostic variables for the shallow water miniapp.
  !> @param[in,out] advection_inc   Advection increment of the shallow water
  !!                                prognostics [u, geopot, buoyancy, q]
  !> @param[in]     advected_fields Fields to advect: [u, geopot, buoyancy, q]
  !> @param[in]     state_n         Fields at time n
  !> @param[in]     state_np1       Estimate of fields at time n+1
  !> @param[in]     model_clock     Time within the model
  !> @param[in]     outer           Outer (advection) iteration number
  !> @param[in]     wind_prev       (Optional) Estimate of end of timestep wind
  !!                                from previous outer iteration
  !> @param[in]     geopot_n        Geopotential from before transport (not
  !!                                multiplied by predictor factor)
  subroutine swe_transport_control_alg_step( advection_inc,   &
                                             advected_fields, &
                                             state_n,         &
                                             state_np1,       &
                                             model_clock,     &
                                             outer,           &
                                             wind_prev,       &
                                             geopot_n )

    use fem_constants_mod,               only: get_mass_matrix
    use operator_mod,                    only: operator_type
    use transport_field_mod,             only: transport_field
    use wind_transport_alg_mod,          only: wind_transport_alg
    use io_config_mod,                   only: subroutine_timers
    use timer_mod,                       only: timer

    implicit none

    ! Arguments
    type(field_vector_type),         intent(inout) :: advection_inc
    type(field_vector_type), target, intent(in)    :: advected_fields
    type(field_vector_type), target, intent(in)    :: state_np1
    type(field_vector_type), target, intent(in)    :: state_n
    class(model_clock_type),         intent(in)    :: model_clock
    integer(kind=i_def),             intent(in)    :: outer
    type(field_type),                intent(in), optional :: wind_prev
    type(field_type),                intent(in), optional :: geopot_n

    ! Fields from advected_fields, state_n and state_np1 vector
    type(field_type), pointer :: wind_np1 => null(), &
                                 wind_n   => null(), &
                                 wind     => null(), &
                                 geopot   => null(), &
                                 buoyancy => null(), &
                                 q        => null()

    ! Fields updated during transport (but not used in model update)
    type(field_type) :: geopot_np1
    type(field_type) :: q_np1
    type(field_type) :: buoyancy_np1
    type(field_vector_type) :: prev_inc

    ! Function space
    type(function_space_type), pointer :: w1_fs => null()
    type(function_space_type), pointer :: w2v_fs => null()

    ! Internal variables
    logical(kind=l_def) :: cheap_update_flag
    type(transport_runtime_type), pointer :: transport_runtime_get => null()
    type(transport_metadata_type), pointer :: transport_metadata => null()

    ! Internal variables
    type(field_type), pointer :: q_mass_flux_get => null()
    type(field_type) :: buoy_inc,     &
                        constant_one, &
                        q_geopot,     &
                        wind_for_adv, &
                        q_mass_flux,  &
                        q_mass_flux_vert

    ! Coordinates, Panel ID, and Mass Matrix
    type(field_type),    pointer :: chi(:)   => null()
    type(field_type),    pointer :: panel_id => null()
    type(operator_type), pointer :: mm_wb    => null()
    type(integer_field_type), pointer :: face_selector_ew => null()
    type(integer_field_type), pointer :: face_selector_ns => null()

    ! Quadrature
    type(quadrature_xyoz_type)          :: qr
    type(quadrature_rule_gaussian_type) :: quadrature_rule

    real(r_def) :: cast_dt

    if ( subroutine_timers ) call timer('swe_transport_control_alg_step')

    ! ------------------------------------------------------------------------ !
    ! Pre-transport initialisation tasks
    ! ------------------------------------------------------------------------ !

    ! Get individual advected, state_n and state_np1 fields
    wind     => advected_fields%vector(isw_u)
    q        => advected_fields%vector(isw_q)
    buoyancy => advected_fields%vector(isw_b)
    geopot   => advected_fields%vector(isw_g)
    wind_np1 => state_np1%vector(isw_u)
    wind_n   => state_n%vector(isw_u)

    ! Set up cheap update flag and store advection_inc from first outer iteration
    call wind_for_adv%initialise(vector_space = wind_n%get_function_space())
    call invoke( setval_X(wind_for_adv, wind_n) )
    if (cheap_update .AND. present(wind_prev)) then
      cheap_update_flag = .true.
      if (outer > 2) then
        call invoke( setval_X(wind_for_adv, wind_prev) )
      end if
    else
      cheap_update_flag = .false.
    end if
    prev_inc = field_vector_type(bundle_size)
    prev_inc = advection_inc

    ! Create transport_runtime object (advecting wind etc)
    if (present(geopot_n)) then
      call set_transport_runtime(wind_for_adv, wind_np1, model_clock, outer, &
                                 cheap_update_flag, rho_d_n_rdef=geopot_n)
    else
      call set_transport_runtime(wind_for_adv, wind_np1, model_clock, outer, &
                                 cheap_update_flag, rho_d_n_rdef=geopot)
    end if

    ! Initialise geopotential variables
    call geopot_np1%initialise(vector_space = geopot%get_function_space())

    cast_dt = real( model_clock%get_seconds_per_step(), r_def )

    ! ------------------------------------------------------------------------ !
    ! Transport of prognostic variables
    ! ------------------------------------------------------------------------ !

    ! ------------------------------------------------------------------------ !
    ! Transport geopotential
    call log_event( "Transporting geopotential...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('geopot')
    call transport_field( geopot_np1, geopot, &
                          cast_dt, transport_metadata )
    call invoke( X_minus_Y( advection_inc%vector(isw_g), geopot_np1, &
                            geopot ) )

    ! ------------------------------------------------------------------------ !
    ! Transport buoyancy
    if ( thermal_swe ) then

      ! Initialise updated buoyancy
      call buoyancy_np1%initialise(vector_space = buoyancy%get_function_space())

      call log_event( "Transporting buoyancy...", LOG_LEVEL_INFO)
      transport_metadata => transport_metadata_collection%get_transport_metadata('buoyancy')
      call transport_field( buoyancy_np1, buoyancy, &
                            cast_dt, transport_metadata )
      call invoke( X_minus_Y( advection_inc%vector(isw_b), buoyancy_np1, &
                              buoyancy ) )
      ! The increment is now pointwise. Depending upon the temporal discretisation
      ! this may need converting into weak form by multiplying by the mass matrix
      mm_wb => get_mass_matrix(W3, buoyancy%get_mesh_id() )
      call buoy_inc%initialise( vector_space = &
                                buoyancy_np1%get_function_space() )
      call invoke( setval_X(buoy_inc, advection_inc%vector(isw_b)),       &
                   setval_c(advection_inc%vector(isw_b), 0.0_r_def),      &
                   matrix_vector_kernel_type(advection_inc%vector(isw_b), &
                                             buoy_inc, mm_wb) )

      nullify( mm_wb )

    end if

    ! ------------------------------------------------------------------------ !
    ! Transport wind field

    ! Vector invariant or momentum form of the momentum equations determines
    ! advection terms for wind

    select case (momentum_form)

    case(momentum_form_vector_invariant)

      ! If vector invariant form, calculate the PV mass flux, Q=q*geopot*u
      ! and use this in the momentum equations.
      call log_event( "Transporting PV...", LOG_LEVEL_INFO)

      ! Get transport runtime
      transport_runtime_get => get_transport_runtime(geopot%get_mesh())

      ! Initialise PV variables
      call q_geopot%initialise(vector_space = q%get_function_space())
      call q_np1%initialise(vector_space = q%get_function_space())

      ! Initialise vorticity advection function spaces and quadrature
      w1_fs    => function_space_collection%get_fs( geopot%get_mesh(), element_order, W1 )
      w2v_fs   => function_space_collection%get_fs( geopot%get_mesh(), element_order, W2v )
      chi      => get_coordinates(geopot%get_mesh_id())
      panel_id => get_panel_id(geopot%get_mesh_id())
      qr = quadrature_xyoz_type(nqp_exact, quadrature_rule)

      ! Calculate q*phi
      call invoke( X_times_Y(q_geopot,q,geopot) )
      transport_metadata => transport_metadata_collection%get_transport_metadata('q')
      call transport_field( q_np1, q_geopot, &
                            cast_dt, transport_metadata )

      ! The PV mass flux depends on whether splitting has been used
      ! we require it to be in W2 space
      call q_mass_flux%initialise(vector_space = wind%get_function_space())

      select case ( transport_metadata%get_scheme() )
      case ( scheme_mol_3d )
        q_mass_flux_get => transport_runtime_get%get_dry_flux(geopot%get_mesh_id(), 1)
        call invoke( setval_X(q_mass_flux, q_mass_flux_get) )
      case ( scheme_split )
        ! Get the correct directional flux based on which splitting is used
        if ( transport_metadata%get_splitting() == splitting_hv ) then
          ! HV splitting requires flux from first splitting stage
          q_mass_flux_get => transport_runtime_get%get_dry_flux(geopot%get_mesh_id(), 1)
        else if ( transport_metadata%get_splitting() == splitting_vh .OR. &
                  transport_metadata%get_splitting() == splitting_strang_vhv ) then
          ! VH or VHV splitting requires flux from second splitting stage
          q_mass_flux_get => transport_runtime_get%get_dry_flux(geopot%get_mesh_id(), 2)
        else
          call log_event('Only HV, VH, or VHV splitting is valid for shallow water', &
                          LOG_LEVEL_ERROR)
        end if
        ! Combine W2h and W2v flux parts into a W2 field
        face_selector_ew => get_face_selector_ew(q_mass_flux%get_mesh_id())
        face_selector_ns => get_face_selector_ns(q_mass_flux%get_mesh_id())
        call q_mass_flux_vert%initialise( w2v_fs )
        call invoke( setval_c(q_mass_flux_vert, 0.0_r_def) )
        call invoke( combine_w2_field_kernel_type( q_mass_flux,                &
                                                   q_mass_flux_get,            &
                                                   q_mass_flux_vert,           &
                                                   face_selector_ew,           &
                                                   face_selector_ns ) )
      case default
        call log_event('Trying to transport PV with unrecognised scheme', &
                        LOG_LEVEL_ERROR)
      end select

      ! If vector_invariant form, use the PV mass flux for the velocity advection
      ! Mass flux already includes dt
      call constant_one%initialise( vector_space = w1_fs )
      call invoke( setval_c(constant_one, 1.0_r_def),                                &
                   setval_c(advection_inc%vector(isw_u), 0.0_r_def),                 &
                   vorticity_advection_kernel_type(advection_inc%vector(isw_u),      &
                                                   q_mass_flux,                      &
                                                   constant_one, chi, panel_id, qr), &
                   enforce_bc_kernel_type(advection_inc%vector(isw_u)) )

      nullify( w1_fs, w2v_fs, q_mass_flux_get, chi, panel_id )

    case(momentum_form_momentum)

      call log_event( "Transporting wind...", LOG_LEVEL_INFO)
      transport_metadata => transport_metadata_collection%get_transport_metadata('wind')
      call wind_transport_alg( advection_inc%vector(isw_u), wind, &
                               cast_dt, transport_metadata )
      ! We don't change advection_inc%vector(isw_u) as wind_transport_alg
      ! already returns weak increment

    case default
        call log_event('Unrecognised form of momentum equations', &
                        LOG_LEVEL_ERROR)

    end select    ! momentum_form

    ! If cheap update we need to add the previous iteration state increments
    if ( cheap_update_flag .AND. outer > 1) then
      ! Add the previous iteration state increments for geopotential, u and buoyancy
      ! On the second outer iteration we have
      ! advection_inc = dt increment(field,(wind_np1-wind_n)/2)
      ! prev_inc      = dt increment(field,(wind_n)/2)
      ! We set
      ! advection_inc = advection_inc + prev_inc = dt increment(field,(wind_np1+wind_n)/2)
      ! This carries forward for further outer iterations
      call invoke( inc_X_plus_Y(advection_inc%vector(isw_g),prev_inc%vector(isw_g)), &
                   inc_X_plus_Y(advection_inc%vector(isw_u),prev_inc%vector(isw_u)) )
      if (thermal_swe) then
        call invoke( inc_X_plus_Y(advection_inc%vector(isw_b),prev_inc%vector(isw_b)) )
      end if
    end if

    nullify(face_selector_ew, face_selector_ns)

    if ( subroutine_timers ) call timer('swe_transport_control_alg_step')

  end subroutine swe_transport_control_alg_step


  !=============================================================================
  !> @brief Advection of tracer variables for the shallow water miniapp.
  !> @param[in,out] tracer_const    Constant tracer to be transported
  !> @param[in,out] tracer_pv       PV tracer to be transported
  !> @param[in,out] tracer_step     Step function tracer to be transported
  !> @param[in]     mass_n          Mass field at time n for conservative transport
  !> @param[in]     mass_np1        Mass field at time n+1 for conservative transport
  !> @param[in]     wind_n          Wind field at time n
  !> @param[in]     wind_np1        Wind field at time n+1
  !> @param[in]     model_clock     Time within the model

  subroutine swe_tracer_transport_alg( tracer_const, &
                                       tracer_pv,    &
                                       tracer_step,  &
                                       mass_n,       &
                                       mass_np1,     &
                                       wind_n,       &
                                       wind_np1,     &
                                       model_clock )

    use transport_field_mod,             only: transport_field
    use io_config_mod,                   only: subroutine_timers
    use timer_mod,                       only: timer
    use transport_enumerated_types_mod,  only: equation_form_conservative, &
                                               equation_form_advective,    &
                                               equation_form_consistent

    implicit none

    ! Arguments
    type(field_type),        intent(inout) :: tracer_const
    type(field_type),        intent(inout) :: tracer_pv
    type(field_type),        intent(inout) :: tracer_step
    type(field_type),        intent(in)    :: mass_np1
    type(field_type),        intent(in)    :: mass_n
    type(field_type),        intent(in)    :: wind_np1
    type(field_type),        intent(in)    :: wind_n
    class(model_clock_type), intent(in)    :: model_clock

    ! Fields updated during transport
    type(field_type) :: tracer_np1
    type(field_type) :: tracer_n

    ! Transport metadata
    type(transport_metadata_type), pointer :: transport_metadata => null()

    ! Transport time step
    real(r_def) :: cast_dt

    ! Parameters for transport runtime
    integer(i_def), parameter :: outer = 1
    logical(l_def), parameter :: cheap_update_flag = .false.

    if ( subroutine_timers ) call timer('swe_transport_control_alg_step')

    ! Create transport_runtime object
    cast_dt = real( model_clock%get_seconds_per_step(), r_def )
    call set_transport_runtime(wind_n, wind_np1, model_clock, outer, cheap_update_flag)

    ! Initialise transported variables
    call tracer_np1%initialise(vector_space = tracer_const%get_function_space())
    call tracer_n%initialise(vector_space = tracer_const%get_function_space())

    ! ------------------------------------------------------------------------ !
    ! Transport tracer_const
    call log_event( "Transporting constant tracer...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('tracer_const')
    ! Form of transport equation
    select case ( transport_metadata%get_equation_form() )
    case ( equation_form_conservative )
      call invoke( X_times_Y(tracer_n, tracer_const, mass_n) )
    case ( equation_form_advective )
      call invoke( setval_X(tracer_n, tracer_const) )
    case ( equation_form_consistent )
      call log_event('Consistent tracer transport not available in shallow water miniapp', &
                      LOG_LEVEL_ERROR)
    case default
        call log_event('Unrecognised constant tracer transport equation', &
                        LOG_LEVEL_ERROR)
    end select
    ! Transport field
    call transport_field( tracer_np1, tracer_n, &
                          cast_dt, transport_metadata )
    ! Divide by mass if conservative
    if (transport_metadata%get_equation_form() == equation_form_conservative) then
      call invoke( inc_X_divideby_Y(tracer_np1, mass_np1))
    end if
    call invoke( setval_X(tracer_const, tracer_np1 ) )

    ! ------------------------------------------------------------------------ !
    ! Transport tracer_pv
    call log_event( "Transporting tracer PV...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('tracer_pv')
    ! Form of transport equation
    select case ( transport_metadata%get_equation_form() )
    case ( equation_form_conservative )
      call invoke( X_times_Y(tracer_n, tracer_pv, mass_n) )
    case ( equation_form_advective )
      call invoke( setval_X(tracer_n, tracer_pv) )
    case ( equation_form_consistent )
      call log_event('Consistent tracer transport not available in shallow water miniapp', &
                      LOG_LEVEL_ERROR)
    case default
        call log_event('Unrecognised PV tracer transport equation', &
                        LOG_LEVEL_ERROR)
    end select
    ! Transport field
    call transport_field( tracer_np1, tracer_n, &
                          cast_dt, transport_metadata )
    ! Divide by mass if conservative
    if (transport_metadata%get_equation_form() == equation_form_conservative) then
      call invoke( inc_X_divideby_Y(tracer_np1, mass_np1))
    end if
    call invoke( setval_X(tracer_pv, tracer_np1 ) )

    ! ------------------------------------------------------------------------ !
    ! Transport tracer_step
    call log_event( "Transporting step function tracer...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('tracer_step')
    ! Form of transport equation
    select case ( transport_metadata%get_equation_form() )
    case ( equation_form_conservative )
      call invoke( X_times_Y(tracer_n, tracer_step, mass_n) )
    case ( equation_form_advective )
      call invoke( setval_X(tracer_n, tracer_step) )
    case ( equation_form_consistent )
      call log_event('Consistent tracer transport not available in shallow water miniapp', &
                      LOG_LEVEL_ERROR)
    case default
        call log_event('Unrecognised step tracer transport equation', &
                        LOG_LEVEL_ERROR)
    end select
    ! Transport field
    call transport_field( tracer_np1, tracer_n, &
                          cast_dt, transport_metadata )
    ! Divide by mass if conservative
    if (transport_metadata%get_equation_form() == equation_form_conservative) then
      call invoke( inc_X_divideby_Y(tracer_np1, mass_np1))
    end if
    call invoke( setval_X(tracer_step, tracer_np1 ) )

    nullify( transport_metadata )

    if ( subroutine_timers ) call timer('swe_tracer_transport_alg')

  end subroutine swe_tracer_transport_alg


  !=============================================================================
  !> @brief Calls finalising routines for shallow water transport.
  subroutine swe_transport_control_alg_final()

    use reconstruct_w3_field_alg_mod,     only: reconstruct_w3_field_alg_final
    use wt_advective_update_alg_mod,      only: wt_advective_update_alg_final
    use transport_runtime_collection_mod, only: transport_runtime_collection_final

    implicit none

    call reconstruct_w3_field_alg_final()
    call wt_advective_update_alg_final()
    call transport_runtime_collection_final()

  end subroutine swe_transport_control_alg_final


end module swe_transport_control_alg_mod
