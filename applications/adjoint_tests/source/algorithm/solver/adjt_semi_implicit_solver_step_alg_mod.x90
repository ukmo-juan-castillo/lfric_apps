!-----------------------------------------------------------------------------
! (C) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module containing adjoint test for semi_implicit_solver_alg_mod subroutine step

module adjt_semi_implicit_solver_step_alg_mod

  use constants_mod,                    only: i_def, r_def, l_def, r_solver
  use log_mod,                          only: log_event,         &
                                              log_scratch_space, &
                                              LOG_LEVEL_INFO,    &
                                              LOG_LEVEL_DEBUG,   &
                                              LOG_LEVEL_ERROR
  use field_mod,                        only: field_type
  use mesh_mod,                         only: mesh_type
  use derived_config_mod,               only: bundle_size
  use field_indices_mod,                only: isol_p, isol_u, isol_w, isol_uv, &
                                              igh_p, igh_t, igh_d, igh_u
  use timing_mod,                       only: start_timing, stop_timing, &
                                              tik, LPROF
  use finite_element_config_mod,        only: element_order_h, element_order_v
  use adj_semi_implicit_solver_alg_mod, only: adj_semi_implicit_solver_type
  use semi_implicit_solver_alg_mod,     only: semi_implicit_solver_alg_step
  use function_space_collection_mod,    only: function_space_collection
  use driver_modeldb_mod,               only: modeldb_type
  use fs_continuity_mod,                only: W2, W3, Wtheta
  use mr_indices_mod,                   only: nummr
  use si_operators_alg_mod,             only: compute_si_operators
  use operator_mod,                     only: operator_type
  use sci_enforce_bc_kernel_mod,        only: enforce_bc_kernel_type
  use model_clock_mod,                  only: model_clock_type
  use function_space_mod,               only: function_space_type
  use field_array_mod,                  only: field_array_type
  use field_collection_mod,             only: field_collection_type

  implicit none

  private

  public  :: adjt_semi_implicit_solver_step_alg
  private :: adjt_semi_implicit_solver_step_alg_common

contains

  !> @brief Adjoint test for semi_implicit_solver_alg_mod subroutine step
  !> @details Does some setup, then calls the actual test via a private subroutine
  !!          twice with different flag values
  !> @param[in,out] modeldb     Structure containing the model state
  !> @param[in]     mesh        The model mesh
  !> @param[in]     model_clock The model clock
  subroutine adjt_semi_implicit_solver_step_alg( modeldb, mesh, model_clock )

    implicit none

    type(modeldb_type), target, intent(inout) :: modeldb
    type(mesh_type), pointer,   intent(in)    :: mesh
    type(model_clock_type),     intent(in)    :: model_clock

    ! Prognostic fields
    type(field_type), dimension(bundle_size) :: state
    type(field_type), dimension(bundle_size) :: rhs
    type(field_type)                         :: moist_dyn_gas_law
    type(field_type), dimension(nummr)       :: mr
    type(field_type), dimension(bundle_size) :: state_in
    type(field_type), dimension(bundle_size) :: rhs_in
    type(field_type)                         :: moist_dyn_gas_law_in
    type(field_type), dimension(nummr)       :: mr_in

    ! LS
    type(field_type),            pointer     :: ls_rho
    type(field_type),            pointer     :: ls_theta
    type(field_type),            pointer     :: ls_exner
    type(field_type),            pointer     :: ls_moist_dyn(:)
    type(field_collection_type), pointer     :: ls_fields
    type(field_collection_type), pointer     :: moisture_fields
    type(field_array_type),      pointer     :: ls_moist_dyn_array

    ! Variables for initialisation etc.
    type(adj_semi_implicit_solver_type) :: adj_semi_implicit_solver
    type(function_space_type), pointer  :: vector_space_wtheta_ptr
    type(function_space_type), pointer  :: vector_space_w2_ptr
    type(function_space_type), pointer  :: vector_space_w3_ptr
    integer(kind=i_def)                 :: i
    integer(kind=tik)                   :: id

    if ( LPROF ) call start_timing( id, 'adjt_semi_implicit_solver_step_alg' )

    ! --------------------------------------------------------------------------
    ! Setup
    ! --------------------------------------------------------------------------

    vector_space_wtheta_ptr => function_space_collection%get_fs( mesh, element_order_h, element_order_v, Wtheta )
    vector_space_w2_ptr => function_space_collection%get_fs( mesh, element_order_h, element_order_v, W2 )
    vector_space_w3_ptr => function_space_collection%get_fs( mesh, element_order_h, element_order_v, W3 )

    ! Perturbation
    call rhs(igh_u)%initialise(vector_space=vector_space_w2_ptr)
    call rhs(igh_t)%initialise(vector_space=vector_space_wtheta_ptr)
    call rhs(igh_d)%initialise(vector_space=vector_space_w3_ptr)
    call rhs(igh_p)%initialise(vector_space=vector_space_w3_ptr)

    call rhs(igh_u)%copy_field_properties(rhs_in(igh_u))
    call rhs(igh_t)%copy_field_properties(rhs_in(igh_t))
    call rhs(igh_d)%copy_field_properties(rhs_in(igh_d))
    call rhs(igh_p)%copy_field_properties(rhs_in(igh_p))

    call invoke( name="adjt_siss_1",                    &
                 setval_random(rhs(igh_u)),             &
                 setval_random(rhs(igh_t)),             &
                 setval_random(rhs(igh_p)),             &
                 setval_random(rhs(igh_d)),             &
                 enforce_bc_kernel_type(rhs(igh_u)),    &
                 setval_x( rhs_in(igh_u), rhs(igh_u) ), &
                 setval_x( rhs_in(igh_t), rhs(igh_t) ), &
                 setval_x( rhs_in(igh_p), rhs(igh_p) ), &
                 setval_x( rhs_in(igh_d), rhs(igh_d) ) )

    ! Input fields are r_def fields so preliminary work uses field_types
    call rhs(igh_u)%copy_field_properties(state(igh_u))
    call rhs(igh_t)%copy_field_properties(state(igh_t))
    call rhs(igh_d)%copy_field_properties(state(igh_d))
    call rhs(igh_p)%copy_field_properties(state(igh_p))

    call rhs(igh_u)%copy_field_properties(state_in(igh_u))
    call rhs(igh_t)%copy_field_properties(state_in(igh_t))
    call rhs(igh_d)%copy_field_properties(state_in(igh_d))
    call rhs(igh_p)%copy_field_properties(state_in(igh_p))

    call invoke( name="adjt_siss_2",                        &
                 setval_random(state(igh_u)),               &
                 setval_random(state(igh_t)),               &
                 setval_random(state(igh_p)),               &
                 setval_random(state(igh_d)),               &
                 enforce_bc_kernel_type(state(igh_u)),      &
                 setval_x( state_in(igh_u), state(igh_u) ), &
                 setval_x( state_in(igh_t), state(igh_t) ), &
                 setval_x( state_in(igh_p), state(igh_p) ), &
                 setval_x( state_in(igh_d), state(igh_d) ) )

    ! LS

    ls_fields => modeldb%fields%get_field_collection("ls_fields")

    call ls_fields%get_field( 'ls_theta', ls_theta )
    call ls_fields%get_field( 'ls_rho', ls_rho )
    call ls_fields%get_field( 'ls_exner', ls_exner )

    moisture_fields => modeldb%fields%get_field_collection("moisture_fields")
    call moisture_fields%get_field( "ls_moist_dyn", ls_moist_dyn_array )
    ls_moist_dyn => ls_moist_dyn_array%bundle

    call compute_si_operators( ls_theta, ls_rho, ls_exner, &
                               model_clock, ls_moist_dyn )
    call adj_semi_implicit_solver%initialise(rhs)

    ! Set up moist_dyn_gas_law & mr
    call moist_dyn_gas_law%initialise(vector_space=vector_space_wtheta_ptr)
    call moist_dyn_gas_law%copy_field_properties(moist_dyn_gas_law_in)

    do i = 1, nummr
      call mr(i)%initialise(vector_space=vector_space_wtheta_ptr)
      call mr(i)%copy_field_properties(mr_in(i))
      call invoke( name="adjt_siss_6",   &
                   setval_random(mr(i)), &
                   setval_x( mr_in(i), mr(i) ) )
    end do

    call invoke( name="adjt_siss_7",               &
                 setval_random(moist_dyn_gas_law), &
                 setval_x( moist_dyn_gas_law_in, moist_dyn_gas_law ) )

    ! End set up moist_dyn_gas_law & mr

    ! --------------------------------------------------------------------------
    ! Test with first_iteration = .true.
    ! --------------------------------------------------------------------------

    call adjt_semi_implicit_solver_step_alg_common( state, rhs, moist_dyn_gas_law, mr,             &
                                                    state_in, rhs_in, moist_dyn_gas_law_in, mr_in, &
                                                    adj_semi_implicit_solver, .true. )

    ! --------------------------------------------------------------------------
    ! Test with first_iteration = .false.
    ! --------------------------------------------------------------------------

    ! Reset values first
    do i = 1, nummr
      call invoke( name="adjt_siss_8", &
                   setval_x( mr(i), mr_in(i) ) )
    end do
    call invoke( name="adjt_siss_9",                                 &
                 setval_x( moist_dyn_gas_law, moist_dyn_gas_law_in ), &
                 setval_x( rhs(igh_u), rhs_in(igh_u) ),               &
                 setval_x( rhs(igh_t), rhs_in(igh_t) ),               &
                 setval_x( rhs(igh_p), rhs_in(igh_p) ),               &
                 setval_x( rhs(igh_d), rhs_in(igh_d) ),               &
                 setval_x( state(igh_u), state_in(igh_u) ),           &
                 setval_x( state(igh_t), state_in(igh_t) ),           &
                 setval_x( state(igh_p), state_in(igh_p) ),           &
                 setval_x( state(igh_d), state_in(igh_d) ) )

    call adjt_semi_implicit_solver_step_alg_common( state, rhs, moist_dyn_gas_law, mr,             &
                                                    state_in, rhs_in, moist_dyn_gas_law_in, mr_in, &
                                                    adj_semi_implicit_solver, .false. )

    call adj_semi_implicit_solver%finalise()

    if ( LPROF ) call stop_timing( id, 'adjt_semi_implicit_solver_step_alg' )

  end subroutine adjt_semi_implicit_solver_step_alg

  !> @brief Actual code for adjoint test for semi_implicit_solver_alg_mod subroutine step
  !> @param[in,out] state                    Prognostic state
  !> @param[in,out] rhs                      Prognostic rhs
  !> @param[in,out] moist_dyn_gas_law        Prognostic moist_dyn_gas_law
  !> @param[in,out] mr                       Prognostic mr
  !> @param[in,out] state_in                 Input state
  !> @param[in,out] rhs_in                   Input rhs
  !> @param[in,out] moist_dyn_gas_law_in     Input moist_dyn_gas_law
  !> @param[in,out] mr_in                    Input mr
  !> @param[in,out] adj_semi_implicit_solver Adjoint semi-implicit solver
  !> @param[in]     first_iteration          Switch to control which test to do
  subroutine adjt_semi_implicit_solver_step_alg_common( state, rhs, moist_dyn_gas_law, mr,             &
                                                        state_in, rhs_in, moist_dyn_gas_law_in, mr_in, &
                                                        adj_semi_implicit_solver, first_iteration )

    implicit none

    ! Prognostic fields
    type(field_type), dimension(bundle_size), intent(inout) :: state
    type(field_type), dimension(bundle_size), intent(inout) :: rhs
    type(field_type), dimension(bundle_size), intent(inout) :: state_in
    type(field_type), dimension(bundle_size), intent(inout) :: rhs_in
    type(field_type),                         intent(inout) :: moist_dyn_gas_law
    type(field_type),                         intent(inout) :: moist_dyn_gas_law_in
    type(field_type), dimension(nummr),       intent(inout) :: mr
    type(field_type), dimension(nummr),       intent(inout) :: mr_in

    ! Solver
    type(adj_semi_implicit_solver_type), intent(inout) :: adj_semi_implicit_solver

    ! first_iteration switch
    logical(kind=l_def), intent(in) :: first_iteration

    ! Inner product test variables
    real(kind=r_def) :: state_inner_prod(bundle_size), rhs_inner_prod(bundle_size), &
                        moist_dyn_gas_law_inner_prod, mr_inner_prod(nummr)
    real(kind=r_def) :: state_sf(bundle_size), rhs_sf(bundle_size), &
                        moist_dyn_gas_law_sf, mr_sf(nummr)
    real(kind=r_def) :: state_state_inp_inner_prod(bundle_size), rhs_rhs_inp_inner_prod(bundle_size), &
                        moist_dyn_gas_law_moist_dyn_gas_law_inp_inner_prod, mr_mr_inp_inner_prod(nummr)
    real(kind=r_def) :: inner1, inner2
    real(kind=r_def), parameter :: overall_tolerance = 1000.0_r_def
    real(kind=r_def) :: machine_tol, machine_tol_r_solver
    real(kind=r_def) :: relative_diff, relative_diff_r_solver
    real(kind=r_def), parameter :: eps = 1e-30_r_def

    integer(kind=i_def) :: i

    ! --------------------------------------------------------------------------
    ! Step the semi-implicit solver (i.e., forward code, Mx)
    ! --------------------------------------------------------------------------

    call semi_implicit_solver_alg_step( state, rhs, moist_dyn_gas_law, mr, &
                                        .false., first_iteration )

    ! --------------------------------------------------------------------------
    ! Compute <Mx,Mx>
    ! --------------------------------------------------------------------------

    call invoke( name="adjt_siss_10",                                       &
                 X_innerproduct_X( state_inner_prod(igh_u), state(igh_u) ), &
                 X_innerproduct_X( state_inner_prod(igh_t), state(igh_t) ), &
                 X_innerproduct_X( state_inner_prod(igh_d), state(igh_d) ), &
                 X_innerproduct_X( state_inner_prod(igh_p), state(igh_p) ), &
                 X_innerproduct_X( rhs_inner_prod(igh_u), rhs(igh_u) ),     &
                 X_innerproduct_X( rhs_inner_prod(igh_t), rhs(igh_t) ),     &
                 X_innerproduct_X( rhs_inner_prod(igh_d), rhs(igh_d) ),     &
                 X_innerproduct_X( rhs_inner_prod(igh_p), rhs(igh_p) ),     &
                 X_innerproduct_X( moist_dyn_gas_law_inner_prod, moist_dyn_gas_law ) )
    do i = 1, nummr
      call invoke( name="adjt_siss_11", &
                   X_innerproduct_X( mr_inner_prod(i), mr(i) ) )
    end do

    write(log_scratch_space, *) "adjt_semi_implicit_solver_step (first_iteration =", first_iteration, ") inner products:"
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "state(igh_u) inner product = ", state_inner_prod(igh_u)
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "state(igh_t) inner product = ", state_inner_prod(igh_t)
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "state(igh_d) inner product = ", state_inner_prod(igh_d)
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "state(igh_p) inner product = ", state_inner_prod(igh_p)
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "rhs(igh_u) inner product = ", rhs_inner_prod(igh_u)
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "rhs(igh_t) inner product = ", rhs_inner_prod(igh_t)
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "rhs(igh_d) inner product = ", rhs_inner_prod(igh_d)
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "rhs(igh_p) inner product = ", rhs_inner_prod(igh_p)
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "moist_dyn_gas_law inner product = ", moist_dyn_gas_law_inner_prod
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    do i = 1, nummr
      write(log_scratch_space, *) "mr(", i, ") inner product = ", mr_inner_prod(i)
      call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    end do

    ! Scaling factors are scaled up a bit to avoid numerical issues
    state_sf(igh_u) = 1.0E4_r_def / (state_inner_prod(igh_u) + eps)
    state_sf(igh_t) = 1.0E4_r_def / (state_inner_prod(igh_t) + eps)
    state_sf(igh_d) = 1.0E4_r_def / (state_inner_prod(igh_d) + eps)
    state_sf(igh_p) = 1.0E4_r_def / (state_inner_prod(igh_p) + eps)
    rhs_sf(igh_u) = 1.0E4_r_def / (rhs_inner_prod(igh_u) + eps)
    rhs_sf(igh_t) = 1.0E4_r_def / (rhs_inner_prod(igh_t) + eps)
    rhs_sf(igh_d) = 1.0E4_r_def / (rhs_inner_prod(igh_d) + eps)
    rhs_sf(igh_p) = 1.0E4_r_def / (rhs_inner_prod(igh_p) + eps)
    moist_dyn_gas_law_sf = 1.0E4_r_def / (moist_dyn_gas_law_inner_prod + eps)
    do i = 1, nummr
      mr_sf(i) = 1.0E4_r_def / (mr_inner_prod(i) + eps)
    end do

    inner1 = 0.0_r_def
    inner1 = inner1 + state_inner_prod(igh_u) * state_sf(igh_u)
    inner1 = inner1 + state_inner_prod(igh_t) * state_sf(igh_t)
    inner1 = inner1 + state_inner_prod(igh_d) * state_sf(igh_d)
    inner1 = inner1 + state_inner_prod(igh_p) * state_sf(igh_p)
    inner1 = inner1 + rhs_inner_prod(igh_u) * rhs_sf(igh_u)
    inner1 = inner1 + rhs_inner_prod(igh_t) * rhs_sf(igh_t)
    inner1 = inner1 + rhs_inner_prod(igh_d) * rhs_sf(igh_d)
    inner1 = inner1 + rhs_inner_prod(igh_p) * rhs_sf(igh_p)
    inner1 = inner1 + moist_dyn_gas_law_inner_prod * moist_dyn_gas_law_sf
    do i = 1, nummr
      inner1 = inner1 + mr_inner_prod(i) * mr_sf(i)
    end do

    call invoke( name="adjt_siss_12",                                      &
                 inc_a_times_X( state_sf(igh_u), state(igh_u) ),           &
                 inc_a_times_X( state_sf(igh_t), state(igh_t) ),           &
                 inc_a_times_X( state_sf(igh_d), state(igh_d) ),           &
                 inc_a_times_X( state_sf(igh_p), state(igh_p) ),           &
                 inc_a_times_X( rhs_sf(igh_u), rhs(igh_u) ),               &
                 inc_a_times_X( rhs_sf(igh_t), rhs(igh_t) ),               &
                 inc_a_times_X( rhs_sf(igh_d), rhs(igh_d) ),               &
                 inc_a_times_X( rhs_sf(igh_p), rhs(igh_p) ),               &
                 inc_a_times_X( moist_dyn_gas_law_sf, moist_dyn_gas_law ) )
    do i = 1, nummr
      call invoke( name="adjt_siss_13", &
                   inc_a_times_X( mr_sf(i), mr(i) ) )
    end do

    ! --------------------------------------------------------------------------
    ! Adjoint code
    ! --------------------------------------------------------------------------

    call adj_semi_implicit_solver%step( state, rhs, moist_dyn_gas_law, mr, &
                                        .false., first_iteration )

    ! --------------------------------------------------------------------------
    ! Compute <AMx,x>
    ! --------------------------------------------------------------------------

    call invoke( name="adjt_siss_14",                                                                  &
                 x_innerproduct_y( state_state_inp_inner_prod(igh_u), state_in(igh_u), state(igh_u) ), &
                 x_innerproduct_y( state_state_inp_inner_prod(igh_t), state_in(igh_t), state(igh_t) ), &
                 x_innerproduct_y( state_state_inp_inner_prod(igh_d), state_in(igh_d), state(igh_d) ), &
                 x_innerproduct_y( state_state_inp_inner_prod(igh_p), state_in(igh_p), state(igh_p) ), &
                 x_innerproduct_y( rhs_rhs_inp_inner_prod(igh_u), rhs_in(igh_u), rhs(igh_u) ),         &
                 x_innerproduct_y( rhs_rhs_inp_inner_prod(igh_t), rhs_in(igh_t), rhs(igh_t) ),         &
                 x_innerproduct_y( rhs_rhs_inp_inner_prod(igh_d), rhs_in(igh_d), rhs(igh_d) ),         &
                 x_innerproduct_y( rhs_rhs_inp_inner_prod(igh_p), rhs_in(igh_p), rhs(igh_p) ),         &
                 x_innerproduct_y( moist_dyn_gas_law_moist_dyn_gas_law_inp_inner_prod, moist_dyn_gas_law_in, moist_dyn_gas_law ) )
    do i = 1, nummr
      call invoke( name="adjt_siss_15", &
                   x_innerproduct_y( mr_mr_inp_inner_prod(i), mr_in(i), mr(i) ) )
    end do

    inner2 = 0.0_r_def
    inner2 = inner2 + state_state_inp_inner_prod(igh_u)
    inner2 = inner2 + state_state_inp_inner_prod(igh_t)
    inner2 = inner2 + state_state_inp_inner_prod(igh_d)
    inner2 = inner2 + state_state_inp_inner_prod(igh_p)
    inner2 = inner2 + rhs_rhs_inp_inner_prod(igh_u)
    inner2 = inner2 + rhs_rhs_inp_inner_prod(igh_t)
    inner2 = inner2 + rhs_rhs_inp_inner_prod(igh_d)
    inner2 = inner2 + rhs_rhs_inp_inner_prod(igh_p)
    inner2 = inner2 + moist_dyn_gas_law_moist_dyn_gas_law_inp_inner_prod
    do i = 1, nummr
      inner2 = inner2 + mr_mr_inp_inner_prod(i)
    end do

    ! Test the inner-product values for equality
    machine_tol = spacing( max( abs( inner1 ), abs( inner2 ) ) )
    relative_diff = abs( inner1 - inner2 ) / machine_tol
    machine_tol_r_solver = spacing( real( max( abs( inner1 ), abs( inner2 ) ), r_solver) )
    relative_diff_r_solver = abs( inner1 - inner2 ) / machine_tol_r_solver
    if ( relative_diff < overall_tolerance ) then
      write( log_scratch_space, * ) &
        "PASSED semi_implicit_solver_alg_mod step, first_iteration=", first_iteration, inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
    elseif ( relative_diff_r_solver < overall_tolerance ) then
      write( log_scratch_space, * ) &
        "PASSED (WITH PRECISION R_SOLVER BUT NOT R_DEF) semi_implicit_solver_alg_mod step, first_iteration=", &
        first_iteration, inner1, inner2, relative_diff_r_solver
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
    else
      write( log_scratch_space, * ) &
        "FAILED semi_implicit_solver_alg_mod step, first_iteration=", first_iteration, inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

  end subroutine adjt_semi_implicit_solver_step_alg_common

end module adjt_semi_implicit_solver_step_alg_mod
