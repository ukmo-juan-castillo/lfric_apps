!-----------------------------------------------------------------------------
! (C) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module containing adjoint test for pressure preconditioner

module adjt_pressure_precon_alg_mod

  use constants_mod,                    only: i_def, r_def, l_def, r_solver
  use log_mod,                          only: log_event,         &
                                              log_scratch_space, &
                                              LOG_LEVEL_INFO,    &
                                              LOG_LEVEL_DEBUG,   &
                                              LOG_LEVEL_ERROR
  use field_mod,                        only: field_type
  use r_solver_field_mod,               only: r_solver_field_type
  use sci_r_solver_field_vector_mod,    only: r_solver_field_vector_type
  use mesh_mod,                         only: mesh_type
  use derived_config_mod,               only: bundle_size
  use field_indices_mod,                only: isol_p, isol_u, isol_w, isol_uv, &
                                              igh_p, igh_t, igh_d, igh_u
  use timing_mod,                       only: start_timing, stop_timing, &
                                              tik, LPROF
  use finite_element_config_mod,        only: element_order_h, element_order_v
  use function_space_collection_mod,    only: function_space_collection
  use copy_field_alg_mod,               only: copy_field
  use driver_modeldb_mod,               only: modeldb_type
  use fs_continuity_mod,                only: W2, W3, Wtheta
  use si_operators_alg_mod,             only: compute_si_operators
  use sci_enforce_bc_kernel_mod,        only: enforce_bc_kernel_type
  use model_clock_mod,                  only: model_clock_type
  use function_space_mod,               only: function_space_type
  use field_array_mod,                  only: field_array_type
  use field_collection_mod,             only: field_collection_type
  use sci_preconditioner_mod,           only: abstract_preconditioner_type
  use pressure_operator_alg_mod,        only: pressure_operator_type
  use adj_pressure_operator_alg_mod,    only: adj_pressure_operator_type
  use semi_implicit_solver_alg_mod,     only: create_pressure_preconditioner
  use adj_semi_implicit_solver_alg_mod, only: create_adj_pressure_preconditioner, &
                                              construct_solver_state

  implicit none

  private

  public :: adjt_pressure_precon_alg

contains

  !> @brief Adjoint test for pressure_precon_alg_mod
  !> @details The preconditioner and its adjoint are applied to one argument with
  !!          the result stored in the other, so we use three vectors to save on
  !!          variables. This differs from other adjoint tests as most adjoint
  !!          routines would increment one argument and set the other to zero.
  !> @param[in,out] modeldb     Structure containing the model state
  !> @param[in]     mesh        The model mesh
  !> @param[in]     model_clock The model clock
  subroutine adjt_pressure_precon_alg( modeldb, mesh, model_clock )

    implicit none

    type(modeldb_type), target, intent(inout) :: modeldb
    type(mesh_type), pointer,     intent(in)    :: mesh
    type(model_clock_type),       intent(in)    :: model_clock

    ! Prognostic fields
    type(field_type),          dimension(bundle_size) :: rhs
    type(r_solver_field_type), dimension(bundle_size) :: rhs_rsol

    ! LS
    type(field_type),            pointer     :: ls_rho
    type(field_type),            pointer     :: ls_theta
    type(field_type),            pointer     :: ls_exner
    type(field_type),            pointer     :: ls_moist_dyn(:)
    type(field_collection_type), pointer     :: ls_fields
    type(field_collection_type), pointer     :: moisture_fields
    type(field_array_type),      pointer     :: ls_moist_dyn_array

    ! Variables for initialisation etc.
    type(function_space_type), pointer :: vector_space_wtheta_ptr
    type(function_space_type), pointer :: vector_space_w2_ptr
    type(function_space_type), pointer :: vector_space_w3_ptr

    ! Solver
    type(pressure_operator_type)                       :: pressure_operator
    class(abstract_preconditioner_type),   allocatable :: pressure_preconditioner
    type(adj_pressure_operator_type)                   :: adj_pressure_operator
    class(abstract_preconditioner_type),   allocatable :: adj_pressure_preconditioner

    ! Inner product test variables
    type(r_solver_field_vector_type) :: vector_x, vector_mx, vector_amx
    real(kind=r_def) :: p_inner_prod, p_p_inp_inner_prod
    real(kind=r_def) :: p_sf
    real(kind=r_def) :: inner1, inner2
    real(kind=r_def), parameter :: overall_tolerance = 1000.0_r_def
    real(kind=r_def) :: machine_tol, machine_tol_r_solver
    real(kind=r_def) :: relative_diff, relative_diff_r_solver
    real(kind=r_def), parameter :: eps = 1e-30_r_def
    integer(tik)                :: id

    if ( LPROF ) call start_timing( id, 'adjt_pressure_precon_alg' )

    ! --------------------------------------------------------------------------
    ! Setup
    ! --------------------------------------------------------------------------

    vector_space_wtheta_ptr => function_space_collection%get_fs( mesh, element_order_h, element_order_v, Wtheta )
    vector_space_w2_ptr => function_space_collection%get_fs( mesh, element_order_h, element_order_v, W2 )
    vector_space_w3_ptr => function_space_collection%get_fs( mesh, element_order_h, element_order_v, W3 )

    call rhs(igh_u)%initialise(vector_space=vector_space_w2_ptr)
    call rhs(igh_t)%initialise(vector_space=vector_space_wtheta_ptr)
    call rhs(igh_d)%initialise(vector_space=vector_space_w3_ptr)
    call rhs(igh_p)%initialise(vector_space=vector_space_w3_ptr)

    call invoke( setval_random(rhs(igh_u)), &
                 setval_random(rhs(igh_t)), &
                 setval_random(rhs(igh_p)), &
                 setval_random(rhs(igh_d)) )

    ! Input fields are r_def fields so preliminary work uses field_types

    ! Copy data to r_solver fields and proceed with everything of kind r_solver
    call rhs(igh_u)%copy_field_properties(rhs_rsol(igh_u))
    call rhs(igh_t)%copy_field_properties(rhs_rsol(igh_t))
    call rhs(igh_d)%copy_field_properties(rhs_rsol(igh_d))
    call rhs(igh_p)%copy_field_properties(rhs_rsol(igh_p))
    ! This is required to put sensible data in the halo so there is something
    ! for enforce_bc_kernel to work with

    call copy_field( rhs(igh_u), rhs_rsol(igh_u) )
    call copy_field( rhs(igh_t), rhs_rsol(igh_t) )
    call copy_field( rhs(igh_d), rhs_rsol(igh_d) )
    call copy_field( rhs(igh_p), rhs_rsol(igh_p) )

    call invoke(enforce_bc_kernel_type(rhs(igh_u)))

    ! LS

    ls_fields => modeldb%fields%get_field_collection("ls_fields")

    call ls_fields%get_field( 'ls_theta', ls_theta )
    call ls_fields%get_field( 'ls_rho', ls_rho )
    call ls_fields%get_field( 'ls_exner', ls_exner )

    moisture_fields => modeldb%fields%get_field_collection("moisture_fields")
    call moisture_fields%get_field( "ls_moist_dyn", ls_moist_dyn_array )
    ls_moist_dyn => ls_moist_dyn_array%bundle

    call compute_si_operators( ls_theta, ls_rho, ls_exner, &
                               model_clock, ls_moist_dyn )

    call create_pressure_preconditioner( rhs, pressure_operator, pressure_preconditioner )

    call create_adj_pressure_preconditioner( rhs, adj_pressure_operator, adj_pressure_preconditioner )

    ! Size = 1 as only P field needed
    vector_x = r_solver_field_vector_type(1_i_def)
    vector_mx = r_solver_field_vector_type(1_i_def)
    vector_amx = r_solver_field_vector_type(1_i_def)

    call vector_x%import_field( rhs_rsol(igh_p), 1_i_def )
    call vector_mx%initialise_field( 1_i_def, rhs_rsol(igh_p)%get_function_space() )
    call vector_amx%initialise_field( 1_i_def, rhs_rsol(igh_p)%get_function_space() )

    call vector_mx%set_scalar(0.0_r_def)
    call vector_amx%set_scalar(0.0_r_def)

    ! --------------------------------------------------------------------------
    ! Apply the preconditioner (i.e., forward code)
    ! --------------------------------------------------------------------------

    call pressure_preconditioner%apply( vector_x, vector_mx )

    ! --------------------------------------------------------------------------
    ! Compute <Mx,Mx>
    ! --------------------------------------------------------------------------

    call invoke(X_innerproduct_X( p_inner_prod, vector_mx%vector(1) ))

    write(log_scratch_space, *) "adjt_pressure_precon inner products:"
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "p inner product = ", p_inner_prod
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )

    p_sf = 1.0_r_def / (p_inner_prod + eps)

    inner1 = 0.0_r_def
    inner1 = inner1 + p_inner_prod * p_sf

    call invoke(inc_a_times_X( p_sf, vector_mx%vector(1) ))

    ! --------------------------------------------------------------------------
    ! Adjoint code
    ! --------------------------------------------------------------------------

    call adj_pressure_preconditioner%apply( vector_mx, vector_amx )

    ! --------------------------------------------------------------------------
    ! Compute <AMx,x>
    ! --------------------------------------------------------------------------

    call invoke(X_innerproduct_Y( p_p_inp_inner_prod, vector_amx%vector(1), vector_x%vector(1) ))

    inner2 = 0.0_r_def
    inner2 = inner2 + p_p_inp_inner_prod

    ! Test the inner-product values for equality
    machine_tol = spacing( max( abs( inner1 ), abs( inner2 ) ) )
    relative_diff = abs( inner1 - inner2 ) / machine_tol
    machine_tol_r_solver = spacing( real( max( abs( inner1 ), abs( inner2 ) ), r_solver) )
    relative_diff_r_solver = abs( inner1 - inner2 ) / machine_tol_r_solver
    if ( relative_diff < overall_tolerance ) then
      write( log_scratch_space, * ) "PASSED pressure_preconditioner_alg:", inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
    elseif ( relative_diff_r_solver < overall_tolerance ) then
      write( log_scratch_space, * ) "PASSED (WITH PRECISION R_SOLVER BUT NOT R_DEF) pressure_preconditioner_alg:", &
      inner1, inner2, relative_diff_r_solver
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
    else
      write( log_scratch_space, * ) "FAILED pressure_preconditioner_alg:", inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

    deallocate( pressure_preconditioner, adj_pressure_preconditioner )

    if ( LPROF ) call stop_timing( id, 'adjt_pressure_precon_alg' )

  end subroutine adjt_pressure_precon_alg

end module adjt_pressure_precon_alg_mod
