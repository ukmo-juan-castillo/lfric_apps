!----------------------------------------------------------------------------
! (c) Crown copyright 2024 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief   Calculate a scalar (that will be coupled) from a field

module process_send_fields_0d_mod

  use constants_mod,                 only: str_def, l_def, i_def, r_def, imdi, &
                                           rmdi, i_timestep
  use field_collection_mod,          only: field_collection_type
  use field_mod,                     only: field_type
  use fs_continuity_mod,             only: W3
  use sci_geometric_constants_mod,   only: get_latitude_fv
  use driver_modeldb_mod,            only: modeldb_type
  use log_mod,                       only: log_event,       &
                                           LOG_LEVEL_INFO,  &
                                           LOG_LEVEL_ERROR, &
                                           log_scratch_space
  use mesh_mod,                      only: mesh_type
  use process_send_fields_2d_mod,    only: cpl_reset_field, &
                                           ice_sheet_mass
  use value_based_mask_kernel_mod,   only: value_based_mask_kernel_type

  implicit none

  private
  public process_send_fields_0d

  contains

  !> @brief Generates scalar values to be coupled
  !> @param[inout] fld        LFRic field from which the scalar is reduced
  !> @param[inout] modeldb The working data set for a model run
  !> @param[out]   scalar     Scalar value calculated by this procedure
  subroutine process_send_fields_0d(fld, modeldb, scalar)

  implicit none
  type( field_type ), pointer, intent(inout)   :: fld
  type( modeldb_type ),        intent(inout)   :: modeldb
  real(r_def), intent(out)                     :: scalar

  ! Collection that holds all fields
  type( field_collection_type ), pointer       :: depository
  ! Field for holding latitudes of dofs
  type( field_type ), pointer                  :: latitude
  ! Mesh that fields are held on
  type(mesh_type), pointer                     :: mesh
  ! Snow mass on tiles
  type(field_type), pointer                    :: snow_mass_on_tiles_ptr
  ! Tile fraction
  type(field_type), pointer                    :: tile_fraction_ptr

  character(str_def)                           :: fld_name

  fld_name = fld%get_name()

  depository => modeldb%fields%get_field_collection("depository")

  ! We need to detect if this is the first step after a start/restart.
  ! If it is then we can initialise the coupling fields
  if (modeldb%clock%get_step() ==  modeldb%clock%get_first_step() ) then

    call cpl_reset_field(fld, depository)

    if (fld_name == "lf_greenland") then
      !Make a mask of the Northern Hemisphere
      ! Get the mesh
      mesh => fld%get_mesh()
      ! Get the latitude field
      latitude => get_latitude_fv(W3, mesh%get_id())
      call invoke(value_based_mask_kernel_type(fld, latitude, &
                                               0.0_r_def, 2.0_r_def) )
    endif
    if (fld_name == "lf_antarctic") then
      !Make a mask of the Southern Hemisphere
      ! Get the mesh
      mesh => fld%get_mesh()
      ! Get the latitude field
      latitude => get_latitude_fv(W3, mesh%get_id())
      call invoke(value_based_mask_kernel_type(fld, latitude, &
                                               -2.0_r_def, 0.0_r_def) )
    endif
  endif

  ! Calculate the scalar icesheet mass

  ! Get snow_depth and tile fractions fields
  call depository%get_field("tile_snow_mass", snow_mass_on_tiles_ptr)
  call depository%get_field('tile_fraction', tile_fraction_ptr)

  call ice_sheet_mass( fld,                    &
                       snow_mass_on_tiles_ptr, &
                       tile_fraction_ptr,      &
                       scalar )

  end subroutine process_send_fields_0d

end module process_send_fields_0d_mod
